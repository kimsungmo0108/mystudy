엄진영 강사님
id : 210 866 3081 pw : 123456
https://github.com/eomjinyoung
https://github.com/eomjinyoung/bitcamp-study/tree/main
token → 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
★ cmd 에서 intl.cpl → 운영체제에서 언어 변경

2023.11.14(화)

Application → client/server → client Application/Application server → web Browser/web Application server
web Browser → HTML/CSS/JS road
web Application server → DBMS/JAVA 실행
Spring Boot → servlet container 와 Spring Framwork
servlet container → web server가 위임 해서 Spring Framwork 명령해서 결과값 반환
Spring Framwork → JAVA 파일들을 실행해서 반환
아키텍처 → 목표하는 대상에 대하여 그 구성과 동작 원리, 구성 요소 간의 관계 및 시스템 외부 환경과의 관계 등을 설명하는 설계도 혹은 청사진



2023.11.15(수)

stereotype : 정형화된 표현
instruction set : 기계어
Application(photoshop) → CPU에게 기계어로 명령 → CPU는 실행 → Application(photoshop)에게 결과값 반환
Qualcomm cpu(퀄컴)
Intel cpu(인텔)
Apple M2(애플)
ARM cpu(암)
cpu가 다르면 기계어도 다르다
★ cpu에 맞는 기계어로 작성해도 운영체제에 맞는 형식이어야 한다.
App → windows OS → Intel cpu   여기서만 동작
App → mac OS → intel cpu
★ 각 OS 기계어
windows OS → PE(Portable Executable)
mac OS → Mach-O
Linux → ELF(Executable and Linkable Format)

APP 만들기
assembly language(어셈블리어) → 기계어를 사람에 언어로 표현(기계어 형식과 흡사한 문법 Low-Level Language)
어셈블리어에서 기계어로 변환 → assembly compiler(운영체제 회사가 지원)가 compile(변환)
어셈블리어는 OS에 종속적이고, OS마다 약간씩 달라서 OS마다 따로 작성해야 한다(불편).
→ OS에 상관없이 같은 문법으로 명령을 작성할 필요가 있다.(C언어가 등장)
★ C언어(source 코드) → C Compiler로 compile(어셈블리어로 변환) → Assembly Compiler로 compile(기계어로 변환) → APP에서 실행
C언어(HIGH-Level Language)
→ OS에 상관없이 동일한 문법
→ 좀 더 인간에 친숙한 문법

JAVA APP 만들기
★ .Java(sourece code)를 JAVA compiler로 compile → .class(Bytecode 또는 portable-code)(기계어는 아니고 흡사한 명령어들) → Bytecode Player에 입력 → windows OS 실행 → Intel cpu 실행
Bytecode player → Engine, Interpreter(해석기), View, VM(Virtual Machine), JVM(Java Virtual Machine)
각 OS 및 cpu 별로 컴파일 해야하는 불편함이 있어 중간에 Bytecode로 변환해서 사용한다.
자바 캐치프레이즈 → 모든 플랫폼(OS+cpu)에서 하나의 코드로 동일한 결과를 얻기 
"Write once, Run Anywhere"("작성은 한 번만, 돌리는 건 어디서든")
단점 : 기계어를 직접 실행하는 방식이 아니기 때문에 실행속도가 느리다.

Java SE(Standard Edition)
JRE(Java runtime Environment)자바 실행 환경
→ JVM + 실행 관련 파일
JDK(Java Development Kit)
→ JRE(JVM + 실행 관련 파일) + 컴파일러, 디버거, 프로파일러 등 개발도구
Java EE(Enterprise Edition) → 기업용 서버 APP 제작에 필요한 도구
Java ME(Micro Edition) → 임베디드 APP 제작에 필요한 도구
개발자(우리) → JDK + Jave EE 일부 설치

JDK 설치
→ JDK 설치 경로를 OS에 등록 → 어느 디렉토리에서도 JDK를 실행할 수 있도록 등록 → PATH 환경변수 = JDK/bin;.......
→ JDK 설치 경로를 'JAVA_HOME'이라는 이름으로 등록 → Java App이 쉽게 JDK를 찾을 수 있도록 등록 → JAVA_HOME = JDK 디렉토리 설정
JAVA_HOME 설정 이유 → 어떤 프로그램에서는 JDK 경로를 알아야 프로그램이 실행이 되므로 

CLI(Command Line Interface) → 글자를 입력하여 컴퓨터에 명령을 내리는 방식이다.
→ GUI와 대립

cmd 명령어
echo %PATH% = echo $PATH
JAVA -version

★cmd, git bash에서 실행
javac Hello.java → Hello.class 생성 → java Hello
jshell → int a = 100;
ctrl + d로 나오기
테스트 할때 java Hello.java
REPL(Read → Evaluation실행, 평가 → print → loop) = jshell → 간단히 자바 명령을 실행, 테스트 하는 용도

★ git 저장소
github.com → git server 운영(repository에 소스파일 저장)
git → software(소스) configuration(형상, 변화) management(SCM) → 형상관리 시스템, 소스 변화 관리 = 버전 관리
→ 소프트웨어의 변경 사항을 관리하는 데 사용되는 프로세스
개발자 → git client 사용(repository) → repository에서 소스파일 저장 하고 읽기



2023.11.16(목)

SCM(Software Configuration Management 소프트웨어 형상관리)
→ 소프트웨어의 변경사항을 체계적으로 추적하고 통제한다
도구 종류 → CVS(Concurrent Version System), SVN(Subversion), GIT
QA(QM)(소프트웨어 품질보증(품질관리)) → 소스관리(공유, 소스 접근 제어 등), 버전관리(변경 기록, 롤백, 제품에 사용될 소스 관리 등), 빌드구조, 개발환경, 문서
빌드
컴파일 → 테스트(테스트 후 보고서) → 문서 → 패킹 → 배포
★ 버전 관리 시스템 = 형상관리 분야에서 소스관리와 변경관리를 처리하는 프로그램
1. 로컬 버전관리 시스템 RCS(Revision Control System) →Local(개발자 pc)에서 개발도구로 소스파일을 편집(생성, 변경, 삭제)하고 폴더에 보관
단점 → 팀원 간 공유 불가

2. 중앙 집중식 버전관리 시스템 = 모든 기록은 서버에 보관(중앙 서버에서 파일을 받아(checkout) 사용할 수 있다)
장점 → 팀원끼리 소스 파일 공유 가능
개발자가 서버에서 다운로드 → checkout, 개발자가 서버에 업로드 → checkin
CVS(concurrent Version System) → checkin할 때 파일 통째로 업로드
단점 → 네트워크로 주고 받을 데이터양이 크다
SVN(Subversion) → checkin할 때 파일에서 변경 부분만 업로드
장점 → CVS에 비해 통신양이 줄어든다
문제! → 만약 서버에 문제가 생기면? → 변경기록이 날아간다 → 로컬에도 변경 기록이 없다
단점 → 소스파일 복구는 가능하지만 기록은 복구 불가!!!!!!!!

3. 분산 버전관리 시스템 → 기록을 여러 컴퓨터에 분산 보관
★ GIT 사용법 (git bash)(Bourne again shell)
장점 → 서버의 분제가 발생하더라도 원상복구 가능!!
① Clone은 모든 데이터를 가진 진정한 백업 → 저장소를 히스토리와 더불어 전부 복제
클론 하는법 → $ git clone URL(백업 할 주소)
★ mystudy 밑에 숨겨진 폴더를 보게되면 .git이 있다 이곳에 변경 기록을 보관하는 폴더이다
.git 폴더를 제외하고 나머지가 working directory(작업 폴더)이다

★ markdown
READ.md 파일 → 컴파일해서 HTML 파일로 만든다. → 웹 브라우저가 HTML을 다운로드 받아서 렌더링
텍스트 파일과 Markup
plain text → data들만 있는 텍스트
markdown → data와 metadata, tag(#, ![alt text](image link) 등)가 같이 쓰인다, HTML보다는 간결하다.
HTML → data와 metadata, markup, tag(<h1></h1>, <p></p> 등)가 같이 쓰인다
텍스트 파일(text file) <=> 바이너리 파일(binary file)
텍스트 파일 → 텍스트 편집기으로 편집 가능한 것 (.txt  .java  .html  .xml  .rtf  .css  .js  .yml)
→ 메모장, vi, 리유닉스 텍스트 편집기(nano, emacs), vscode
바이너리 파일 → 전용 편집기로 편집 가능한 것(.jpg  .png  .mp4  .pdf  .xls  .ppt)
→ 포토샵, 프리미어, 엑셀, 파워포인터, 워드, 아레아한글

② git add
현재 작업 디렉토리 → mystudy/
local → .git/
       → README.md
       → test.md
       → test.html
       → test.txt		→저장소에 보관
★ → 대상 파일을 백업 명단에 추가 → $ git add 대상파일
★ 내보낼려면 → $ git restore --staged test.html
→ 백업 → $ git commit -m "백업내용"
$ git config --global user.name "kimsungmo0108"
$ git config --global user.email "rlatjdah8585@daum.net"

③ git push → 로컬 저장소의 변경 내용을 서버 저장소에 업로드
token → 일회권 발행권
untracked → git의 버전 관리 대상이 아닌 상태
unmodified → 마지막 커밋 이후에 아무것도 수정하지 않은 상태
modified → 파일의 내용을 변경한 상태
staged →  다음 커밋에서 저장하도록 staging area에 등록되고 표시된 상태

④ git pull → 서버 저장소의 변경사항을 로컬 저장소로 다운로드
$ git pull → 변경 파일을 working directory로 꺼낸다 → 기존 파일에 변경 내용을 합친다(★merge)

⑤ git log → commit 된 모든 기록
snapshot → commit 할 때 파일들에 모든 상태(삭제, 버전 업, 생성)를 기록한다
→ 그래서 복구 해야하는 파일들을 불러올 수 있다
git log --oneline → 기록들을 간략하게
★ $ git checkout 복구암호키(해시 SHA-1) → 저장소에서 특정 commit의 파일을 working directory로 꺼내기
최신 commit → $ git checkout main
브랜치 → 커밋 사이를 이동할 때 사용하는 포인터 같은 것 



2023.11.17(금)

전날 복습
program → 특정 작업을 수행하는 명령어들
소프트웨어 형상(software configuration) → program + 문서(실행파일 + 사용자 가이드 + 개발 문서) + zip + 인스톨러
버전관리 시스템 → 특성에 대한 변경을 제어, 변경 처리 상태를 기록 및 보고
관리 → tracking + controlling

GIT 사용법
⑥ 충돌과 해결 방법
충돌
→ 이미 서버에서 받았던 mystudy 폴더를 mystudy2라는 폴더로 clone
$ git clone https://github.com/kimsungmo0108/mystudy mystudy2
→ mystudy2에서 test.html파일을 변경 후 commit과 push
→ mystudy에서 test.html파일을 변경 후 commit과 push → reject(거부), 충돌 발생(comflict)
해결
→ mystudy에서 git pull 하면 서버에서 알아서 합쳐준다(merge)
→ 병합된 test.html파일을 commit과 push → server에 업로드
→ mystudy2에서 git pull을 해도 ok
→ ★ pull할 때 폴더에 파일이 없으면 백업이 안된다

★ 컴파일러 버전과 클래스 파일
Hello.java
→ Javac 11 → Hello.class(바이트 코드) → JVM 11 → JVM 11 이상 실행 가능
→ javac 17 → Hello.class(바이트 코드) → JVM 17 → JVM 17 이상 실행 가능
→ javac 21 → Hello.class(바이트 코드) → JAM 21 → JVM 21 이상 실행 가능
→ JVM 상위 버전은 javac 하위 버전을 실행 가능, JVM 하위 버전은 javac 상위 버전을 실행 불가능

버전 관리 시스템의 관리 대상
관리 대상 → 소스파일, 문서, 설정파일
비관리 대상 → 개발도구 설정파일, 빌드(컴파일) 결과파일(.class .exe .jar 등) → 개발자의 환경에 따라 달라지는 파일은 관리 대상이 아니다 → 빌드 결과물도 관리 대상이 아니다
★ 관리 대상에서 제외 시킬 방법은? → .gitignore(무시) 파일에 등록 → *.class 하고 저장 → 개발 툴마다 무시할 파일이름 gitignore.io 사이트에서 생성 가능
* wildcard
temp/ → 폴더 제외 → 한 줄에 한 항목 
/로 시작하면 하위 디렉토리에는 적용되지 않는다
!로 시작하는 파일은 무시하지 않는다
바이트코드(.class)는 commit하면 안 된다 → 개발자 환경에 따라 다른 파일은 올리면 안 된다 → 운영체제에서 자동으로 생성되는 파일

인터프리트 소개 및 테스트
소스파일 → (읽기 → 문법검사 → 해석) → 인터프리터 → 실행 → OS
$ node Hello.js
종류 → .js → nodejs, .py → python, .php → PHP 엔진, 등
★ 인터프리트 특징
→ 소스파일을 직접 읽어서 실행
→ 실행할 때 소스파일 필요
→ 인터프리터가 있어야 한다
→ 실행할 때마다 매번 문법검사(컴파일 방식에 비해서 속도가 느리다)
→ 코드에 오류가 있더라도 실행 하기 전까지 알 수 없다

컴파일 방식
소스파일 → 컴파일러(문법검사 → 기계어 변환) → 실행파일 → 실행 → OS
gcc.exe → c 컴파일러 
→ $ gcc Hello.c or $ gcc -o Hello.exe Hello.c → Hello.c(명령 프롬프트cmd) or ./Hello.exe(git bash)
g++.exe → c++ 컴파일러 
→ 
★ 컴파일 특징
→ 컴파일할 때 문법검사, 기계어 변환
→ 실행할 때 바로 실행 : 인터프리터 x, 컴파일러 x
→ 기계어기 때문에 실행속도 빠르다(인터프리터 방식에 비해서)
→ 소스코드를 노출하지 않는다(자산 보호)
단점
→ OS에 종속

Hybrid 방식 → 자바
소스파일 → 컴파일러(문법검사, 가상의 기계어 변환) → 바이트코드(기계어가 아닌 중간언어이기 때문에 직접 실행불가) → JVM(ByteCode 인터프리터) → 실행 → OS
★ 소스파일~바이트코드(컴파일 방식) → 바이트코드~OS실행(인터프리트 방식)
★ 자바 특징
→ 컴파일 방식의 이점을 취한다
→ 소스코드를 비노출(자산 보호)
→ 컴파일 과정 문법검사 완료
→ 가상의 기계어로 번역
→ 특정 cpu에 비종속 → cpu마다 컴파일 x
→ OS에 JVM이 설치되어 있으면 실행가능
단점
→ 진짜 기계어를 실행하는 것보다 느리다 → 그러나 OS 상관없이 실행할 수 있다는 것이 더 이득이 되기 때문에 이 방법 사용

Java vs C#
자바 → 소스 → 컴파일 → 바이트코드 → 실행 → JVM
C# → 소스(C#, Visual Basic) → 컴파일 → 공통중간언어CIL(Common Intermediate Language) → 실행 → .NET

① 이전 방식
Bytecode → 명령어 하나씩 읽기 → JVM → 실행 → OS

② ★ JIT(Just in Time) 컴파일 방식 (개선 방식)
JIT(Just in Time) → 바로 그 시점에 → 실행 시점에 자주 실행하는 코드를 진짜 기계어로 바꿔놓고 그 기계어를 실행하여 실행속도를 높이는 방식
ByteCode → 명령어 읽기 → JVM → 실행 → OS
		        → JVM(자주 실행되는 일부 명령은 실행시점(JIT)에 기계어로 바꿔 보관)
		        → cache(보관소)(캐시에 보관된 기계어는 실행 완료할 때 제거된다 영구히 보관하는 것이 아니다)
		        → 실행(일부로 기계어 직접 실행) → OS

③ ★ AOT(Ahead of Time) 컴파일 방식 → JIT 방식은 실행 시점에 컴파일 하기 때문에 실행이 느려지는 문제가 있다
PlayStore에서 APP 다운 → 1. download 2. 설치할 때 기계어로 변환 → Android → 3. 미리 전체 컴파일 → cache에 기계어를 보관 → 4. 실행
→ 실행 속도가 빠르다
→ 설치할 때 기계어로 바꾸기 때문에 설치시간이 길어졌다
모바일 APP 배포와 컴파일 
개발자가 APP제작 → playstore에 업로드 → APP 다운로드 → 컴파일 → 기계어 → phone1(Qualcomm)
				  → APP 다운로드 → 컴파일 → 기계어 → phone2(MediaTek)
				  → APP 다운로드 → 컴파일 → 기계어 → phone3(Exynos)
AOP(Aspect-oriented Programing) → AOP는 프로그래밍 패러다임이다

자바 프로젝트 표준 디렉토리 구조
① Maven 빌드 도구의 프로젝트 표준 디렉토리 구조
② 빌드란? 
→ 컴파일 → 테스트 → 보고서/문서 생성 → 배포파일 준비 → 배포
→ 소프트웨어 제작 전체 과정
③ ★ 빌드 도구란?
→ build 작업을 수행하는 도구 
→ build 도구 → 사용 → 컴파일러 → 컴파일 수행
	      → 사용 → 디버거 → 디버깅 수행
	      → 사용 → 문서 생성기 → 문서 생성 
	      → 사용 → 배포 파일 생성기 → 배포 파일 생성
	      → 사용 → 테스트 도구 → 테스트 수행

④ 빌드 스크립트 파일
빌드 스크립트 파일 → 읽기 → 빌드 도구 → 스크립트 파일에 설정된 정보를 사용하여 빌드 수행 → 빌드 자동화
빌드 스크립트 파일(명령을 담은 파일)
→ 빌드에 사용할 정보(소스 폴더의 경로, 배포 파일의 이름 등)
→ 빌드 순서
→ 빌드할 때 사용할 도구
→ 등
빌드 자동화
사람이 일일이 빌드 과정에 개입할 필요없다
전체 과정을 자동화 시킬 수 있다

⑤ 현업에서 사용하는 빌드 도구
Ant(apache.org) → build.xml(build script file)
Maven → pom.xml(project object model.xml)
Gradle → build.gradle
★Ant → 의존 라이브러리 관리 기능을 포함(자동 다운) → Maven
Ant → 개발자가 직접 소스코드의 위치와 소스코드의 빌드가 된 파일의 위치, 산출물을 어디에 위치시켜야 하는지 정확하게 지정해주어야 한다
Maven → 어디에 소스코드가 위치하고, 소스코드 컴파일, 컴파일 된 소스코드의 산출물의 위치 등이 이미 다 지정되어 있어 따로 일일히 작업을 해주지 않아도 된다.
★ 라이브러리
인간의 도서관 → 책
소프트웨어의 도서관 → 컴파일된 코드(자바, c++, c) 또는 날것의 코드(자바스크립트, 파이썬)
프로젝트에서 사용하는 외부 부품/프로젝트에서 사용하는 다른 개발자가 만든 코드(컴파일 된 상태)
★ Gradle → 빌드 스크립트를 작성할 때 xml 대신 groovy 언어 사용 → Gradle(Groovy, kotlin 언어 사용)
→ 프로그래밍 언어를 사용함으로써 보다 정밀하게 빌드 과정을 제어할 수 있다
→ 그래서 안드로이드 기본 개발 도구로 Gradle을 사용한다



2023.11.20(월)

자바 프로젝트 준비
① src, bin 폴더 분리
src → 소스 파일
bin → 빌드 결과 파일, 컴파일 결과 파일
기본 컴파일
$ javac src/Hello.java
★ 목적 컴파일
$ javac -d src/Hello.java
★ 자바 목적 파일 실행
$ java -classpath bin Hello
$ java -cp bin Hello
★ GIT 저장소와 프로젝트 폴더
1. GIT 저장소 = 프로젝트 폴더 → 보통 방식, 일대일 저장
mystudy/
  → src/
2. GIT 저장소 = 여러 개의 프로젝트 폴더 → 메인 프로젝트 1, 서브 프로젝트 여러 개
mystudy/
  → projectA → main project
    →src
  → projectB → sub project
    →src
★ Maven 표준 프로젝트 디렉토리 구조
java-project/
  → src/
    → main/ → Application 소스 파일을 두는 폴더
      → java/ → 자바 소스 파일(.java)
      → resources/ → 설정 파일(.xml, .properties)
      → kotlin/ → 코틀린 소스 파일 (.kt)
      → 등
    → test/ → 단위 테스트 소스 파일을 두는 폴더
      → java/
      → resources/

② Gradle 설치 및 설정
1. 설치 gradle.org → path 환경변수 설정
★ 2. 프로젝트 디렉토리 이동 → $ gradle init(application, java, groovy) → 빌드 스크립트 파일 자동화
DSL(Domain-Specific Language) → 특정 영역에서 사용하는 언어
→ 빌드 스크립트(build.gradle) 특정 영역에 코드를 작성할 때 사용할 언어
★ gradle init
java-basic/ → root project
    → .gradle/ → gradle 설정파일, Local마다 다를 수 있다, 공유 X
    → app/ → main project
        → src/
            → main/
                → java/
                → resources/
            → test/
                → java/
                → resources/
        → ★ build.gradle → gradle 빌드 스크립트 파일
    → gradle/ → gradle을 로컬에 설치해주는 도구, 로컬에 gradle이 설치 안된 경우에 사용된다
    → gradlew → Linux/Unix 용 → 로컬에 gradle이 설치 안된 경우에 사용한다
    → gradlew.bat → windowd 용 → 로컬에 gradle이 설치 안된 경우에 사용한다
    → settings.gradle → gradle 빌드 스크립트 보조 파일
    → .gitattributes → git 관련 파일
    → .gitignore → 형상 관리 시스템에 추적을 무시

③ Gradle 사용법
https://docs.gradle.org/current/userguide/plugin_reference.html → gradle 사이트
1. 가이드 → Gradle로 수행할 수 있는 작업 목록 출력
→ $ gradle tasks
→ $ gradle tasks --all
Gradle → 1. 읽기(빌드 스크립트에 설정된 정보를 바탕으로 실행) → build.gradle/setting.gradle
          → 2. 빌드 스크립트에 설정된 것을 바탕으로 실행

Gradle 빌드 스크립트 파일(build.gradle)
plugins{
  → Gradle을 실행할 때 사용할 플러그인
  → id "플러그인명" → 'java' 플러그인 → 자바 소스 빌드 작업을 수행
		 → ' e' 플러그인 → 자바 소스 빌드 작업을 수행
		 → 'application' 플러그인 → java 플러그인 + 실행
		 → 'jar' 플러그인 → 패킹 작업을 수행
		 → 등 여러가지가 있다
}
repositories{
  → 외부 라이브러리를 다운로드 받을 서버 정보
}
dependencies{
  → 외부 라이브러리 정보
}

★ 2. 프로젝트 실행
→ $ gradle run 
→ $ java -classpath app/build/classes/java/main    Hello
패키지 폴더 실행
→ $ java -classpath app/build/classes/java/main   com.eomcs.App
→ $ gradle -i(information) 명령
→ 해당 폴더 이동 → ./app.bat → 배포한 파일 실행 

★ 3. 'java' gradle 플러그인 ★
$ gradle compileJava → 애플리케이션 소스 컴파일 
→ gradle은 java를 컴파일 할 능력이 없다
개발자 → 사용(컴파일러 사용법을 자세히 알아야 한다 예 : -d, -classpath) → Java 컴파일러 → 컴파일 수행
          → 사용(gradle의 빌드 스크립트 작성법을 알아야 한다) → Gradle → 사용 → Java 컴파일러
java-basic/ → app/ → src/ → main/ → java/ → 이 폴더에 있는 자바 소스를 컴파일
	  → app/ → build/ → classes/ → java/ → main/ → 이 폴더에 .class 파일을 둔다

$ gradle processResources → 실행할 때 사용한 설정파일을 build/resources/test 폴더에 복사
→ 단위 테스트 설정 파일 복사
java-basic/ → app/ → src/ → main/ → resources/ → 이 폴더에 있는 파일을 
	  → app/ → build/ → resources/ → main/ → 그대로 복사

$ gradle classes → application 실행할 수 있도록 컴파일
→ compileJava 실행 
→ processResources 실행

$ gradle compileTestJava → 단위 테스트 소스 컴파일
→ main과 test 폴더에 있는 파일 같이 컴파일
→ .class 파일도 main과 test 폴더에 둔다
java-basic/ → app/ → src/ → test/ → java/ 
		          → main/ → java/ → main과 test 폴더 안에 있는 파일들 같이 컴파일
	  → app/ → build/ → classes/ → java/ → test/ 
			    	  → main/ → java/ → main과 test 폴더 안에 .class 파일을 둔다

$ gradle processTestResources → 단위 테스트 설정 파일 복사
java-basic/ → app/ → src/ → test/, main/ → resources/ → 이 폴더에 있는 파일을 
	  → app/ → build/ → resources/ → test/, main/ → 그대로 복사

$ gradle testClasses → 단위 테스트 관련 파일을 컴파일
→ compileJava → processResoures → classes → compileTestJava → processTestResources → testClasses

$ gradle -i(information 모든 빌드 명령어에서 사용 가능) test → 단위 테스트를 실행한 후에 보고서 생성
→ build/reports/tests/보고서
→ compileJava → processResources → classes → compileTestJava → processTestRsources → testclasses → test

$ gradle jar → 애플리케이션 패킹(테스트 x, 패킹만)
build/libs/app.jar → *.jar파일 생성 → 확장자명을 *.zip로 바꾸고 압축 풀기
→ compileJava → processResources → classes → jar 

$ gradle build
test → 애플리케이션 컴파일 및 단위 테스트
jar → 배포 파일 생성
(distribution : 분포, 배포)

$ gradle clean → build 폴더 삭제

$gradle -i run → build 스크립트 파일에 지정된 메인 클래스 실행
→ compileJava → processResources → classes → run

★ java 언어
→ 리터럴(Literal), 변수(variables), 연산자(operator), 조건문(conditional, 분기문), 반복문(loop)
리터럴 → 데이터를 표기한 것
숫자 → 정수, 부동소수점(실수)
문자 → '가', 'A'
문자열 → "문자열입니다", "abcdef"
논리 → true, false

소스파일과 클래스 블록, .class 
→ 자바의 컴파일 기본단위는 클래스 블록이다 
→ 한 소스를 컴파일하면 클래스당 .class 파일 생성
→ 컴파일 기본단위는 소스파일이 아니다
C.java--------------------------------------
class C1 {}(클래스 블럭)	 C1.class
class C2 {}--------------------→ C2.class
class C3 {}		 C3.class
---------------------------------------------



2023.11.21(화)

① 소스 파일과 클래스 블록 .class파일
javac -d build/classes/java/main  /src/main/java/com/eomcs/D.java 
→ com/eomcs 폴더에 있는 자바 소스를 컴파일 했는데 com/eomcs 폴더가 아닌 main 폴더에 .class 파일이 있다
→ 특정 폴더에 소속된다고 지정하지 않아서 루트 폴더의 클래스로 간주

② ★ 패키지
package com.eomcs; 
$ javac -d build/classes/java/main  /src/main/java/com/eomcs/E.java
(/src/main/java 소스폴더)(/com/eomcs 패키지폴더)E.java
(build/classes/java/main 목적폴더)(/com/eomcs 패키지폴더)E1.class, E2.class 
★ $ java -classpath 목적폴더 패키지폴더.이름 → 패키지 폴더는 닷으로 구분
$ java   -classpath   build/classes/java/main   com.eomcs.E1
→ 클래스가 소속된 그룹이름
→ 디렉토리로 다룬다
→ 클래스를 역할에 따리 관리하기 위해서 → 정리정돈
→ 도서관에서 분류에 따라 서가를 분리하여 책을 정리해 두듯이
→ 소스를 관리하기 쉽게하기 위해 단순히 디렉토리로 분류하는 것은 소용없다 → 문법으로 명시해야 한다 → 패키지 문법
→ 컴파일할 때 목적 폴더 밑에 패키지 폴더가 없다면 자동으로 생성하고 패키지 폴더에 .class 파일 생성

③ 패키지 이름과 도메인 명
package com/eomcs; 
→ 보통 패키지 이름은 도메인 명을 사용한다 → 개발자 간, 회사 간에 이름 충돌 방지
→ 도메인 명을 꺼꾸로 사용 → 상위에서 하위로 분류하기 쉽게
/src/main/java/com/microsoft/
/src/main/java/com/facebook/
/src/main/java/com/oracle/
/src/main/java/org/apache/
패키지명 작성 관례
com.microsoft.office.msword
| 도메인명 |제품명(서비스명)| 하위 분류명(역할명) |

④ 패키지 private 클래스
java/com/eomcs/F.java → class F1{}, class F2{}
java/com/eomcs/Test.java → class Test{}
class F1{} → public으로 공개 전
class F2{}, class Test{} → 공개 여부에 상관없이 같은 패키지에 소속된경우 접근가능
패키지 멤버 클래스(패키지 클래스) → 패키지에 소속된 클래스
다른 클래스를 사용하는 소스 파일을 컴파일 하기
Test.java
class Test{
  F1 v1;  → 다른 클래스 사용
  F2 v2;  → 다른 클래스 사용
}
$ javac -d     목적폴더경로        -classpath        소스파일에서 사용하는 다른 클래스 경로(파일)         소스파일 경로
$ javac -d     build/classes/java/main     -classpath      build/classes/java/main      src/main/java/com/eomcs/Test.java

java/Test2.java 
class Test2{
  F1 v1;  → 다른 패키지에서 클래스 사용하려면 패키지명까지 적어야한다
  F2 v2;  → com.eomcs.F2 v2;로 변경 하지만 사용은 불가능
}

공개 클래스
public class는 소스파일에서 하나만 설정 가능
com/eomcs/G.java → 파일명을 G1.java로 변경
pubilc class G1{} → 공개 클래스는 유지보수할 때 소스파일을 찾기 쉽도록 하기 위해 반드시 소스파일명과 일치 시켜야 한다
★ class G2{} → 패키지 private 클래스
→ 만약 java/Test2.java에서 com.eomcs.G1 v3;은 사용가능
→ com.eomcs.G2는 사용불가능
일반 적인 경우 
→ 1개 소스파일 - 1개의 클로스 블록
→ 소스파일명 = 클래스 블록명 일치
→ 클래스가 정의된 소스 파일을 찾기 쉽다
→ 유지보수가 쉽다

main() 메서드 → 프로그램 entry point(진입점 = 입구)
$ java Hello
→ classpath에 지정된 경로에서 Hello.class 파일을 찾는다 
  → JDK 설치 폴더에서 찾기
  → -classpath에서 찾기
  → OS CLASSPATH에서 찾기
  → 현재폴더에서 찾기
→ .class 파일의 bytecode를 검증한다
→ main() 메서드 실행

20년간 진화해온 APP 아키텍처를 압축경험
1. myapp(standalone) → 변수 → 배열 → 조건문/반복문 → 메서드 → 컬렉션API → File I/O
2. myapp s/w → 네트워킹 API, File I/O 기능 분리 → 스레드 적용(멀티 프로세싱) → DBMS 적용+JDBC API
3. myapp AS → App 기능을 서버에서 실행 → IoC 컨테이너 적용(객체 생성 자동화)
4. myapp web AS → Mybatis 도입 → JSP 도입 → JSTL/EL 도입 → 프론트 컨트롤러 패턴 적용
5. myapp SpringFramework → Thymeleaf 뷰 템플릿 적용 → 임베디드 서블릿 컨테이너 도입
6. myapp SpringBoot → REST API + AJAX → SpringSecurity 적용

주석 사용법
① 일반 주석(comments)/javadoc comments/annotation
일반 주석
→ // 주석입니다 → 한줄 전체 주석
→ /* 주섭입니다 */ → 표시한 부분만 주석

② ★ javadoc comments
→ /** 주석입니다 */
/** 클래스 설명 */
class A{
  /** 변수 설명 */
  int a;			→ javadoc 실행 → API(HTML) → 개발자가 작성한 코드의 사용법을 설명한 문서
  
  /** 메서드 설명 */
  void main(){
  }
}
$ javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java com.eomcs.lang.ex02
javadoc 등장 전
개발자 → 1. 작성 → 소스파일(.java .c .cpp 등)
개발자 → 2. 작성 → API 문서(.doc .ppt .hwp .pdf 등)
→ 소스 코드를 바꾸면 API 문서도 그에 맞춰 변경해야 하지마 개발자들이 귀찮아서 안하는게 현실이다
→ 코드와 문서가 일치하지 않는 문제 발생
→ 해결 → 소스+문서 결합 → 문서 생성 자동화(javadoc 등)

③ annotation
소스 파일
/* 일반 주석*/ → 컴파일 과정에서 버린다
// 일반 주석

/** javadoc */ → javadoc에 의해서 HTML 파일에 삽입

@annotation → 컴파일 할 때 .class 파일에 포함 
→ 컴파일 할 때 사용/실행 할 때 사용/다른 문서를 생성할 때 사용

IDE(Integrated Development Environment 통합 개발 환경)
단순 에디터 -----------------------→ IDE → 개발의 전반적인 작업을 해당 도구를 사용해서 처리해줌 
IDE = 단순 에디터 + 컴파일, 실행, 디버깅, 테스팅, 패킹, 버전관리 등
→ JDK, git, 개발도구 사용 
→ 편집기, 위저드 기능의 자동화 도구(Eclipse IDE, IntelliJ, Netbeans 등)
VScode는 단순 에디터와 IDE에 중간
→ 플러그인을 사용한 반자동 IDE 도구
★ bin/main/소스파일 → 이클립스가 컴파일 한 클래스 파일들 



2023.11.22(수)

Gradle 자바 프로젝트를 Eclipse IDE로 import
gradle → 구성 → java-basic(root project) 
		→ app(main project) → import → Eclipse IDE
	                 |→ .settings/ → 프로젝트에 대한 더 상세한 설정
	                 |→ .classpath → 소스폴더, 컴파일한 목적폴더, 외부라이브러리 정보
	                 |→ .project → 프로젝트 설정파일(어떤 프로젝트인지 알아야 그에 맞는 에디터나 화면을 준비하기 위해서)
	                 |    → Eclipse IDE가 사용하는 설정파일
build.gradle(빌드 스크립트 파일) → $ gradle eclipse → .settings/ .classpath .project 생성
+ 'eclipse' 플러그인 장착
+ eclipse {-} 설정등록
$ gradle cleanEclipse → 이클립스 설정파일(.settings/ .classpath .project) 삭제

Eclipse VS ItelliJ
eclipse → 사용 → JDK → 빌드
빌드 → 사용 → 소스파일 개별 빌드 → 일부 소스에 오류가 있어도 실행 가능
IntelliJ → Gradle → JDK → 빌드
빌드 → 전체 소스 빌드 → 일부 소스에 오류가 있으면 실행 불가능

★실습★
1. 'test-app' Gradle 자바 프로젝트를 생성한 후 Eclipse IDE로 임포트하시오
git bash
$ mkdir test-app → $ cd test-app → $ gradle init(appication , java, groovy) → $ gradle eclipse 
eclipse
메뉴 → file → import → 경로 설정 → 열기
2. 'myapp' Gradle 자바 프로젝트를 생성한 후 Eclipse IDE로 임포트하시오
    → 패키지명 : bitcamp.myapp
3. 'myapp' 프로젝트 IntelliJ에서 열기
jdk 17버전 설치 및 환경변수 설정, 확인
→ PATH, JAVA_HOME 환경변수 설정 → $ echo $JAVA_HOME → $ java -version → $ javac -version → $ echo $PATH
→ build.gradle 파일에 버전 수정 → intellij에서 오픈 → 경로 설정
.idea → IntellJ에서 쓰는 설정파일, IntelliJ가 자동으로 생성

프로그램
data(성적) → software(데이터 가공) → information(순위, 표준편차, 분포도)
		     	         → data'(평균, 합계)
software(데이터 가공) → hardware → CPU(연산)
			        → RAM(data 보관)
DATA 보관 방법
① 종이 → 100 그리기(10진수 표기법)
173 → 1*100 + 7*10 + 3*1 (10진수)
100 → (0)144 → 1*64 + 4*8 + 4*1 (8진수)
100 → (0b)1100100 → 1*64 + 1*32 + 1*8 (2진수)
100 → (0x)64 → 6*16 + 4*1 (16진수) → 10진수 다음에 16진수를 컴퓨터에서 많이 쓰인다
10진수(100) → 16진수(64) → 2진수(144) → 8진수(1100100)

② 컴퓨터 → RAM(휘발성) or HDD, CD-ROM, SSD(조금씩 휘발성) 등
RAM은 전하(전기)를 보관한다 → 숫자, 문자, 색상, 문자열, 소리 등을 전기신호로 변환해서 저장한다
□■■□ → off on on off (비트)
HDD → 원판에 자석 가루에 저장
NS SN SN NS → off on on off → 자석방향으로 변환해서 저장한다(수직 기록 방식)
HDD Head가 쓰고 읽는다
숫자 → on/off로 변환해야 한다 → 표기하기 불편 → 더 간결한 표기법 0/1 2진수(1010111100)로 표기한다
→ 숫자를 2진수로 변환해서 RAM(전기신호), HDD(마그네틱 신호)에 저장할 수 있다
→ 2진수를 활용해서 Data를 표현
→ 2진수를 바꾸면 저장을 할 수 있어서 2진수로 변환하는 규칙이 있어야 한다

③ 숫자(정수) → 2진수 변환 규칙
1. sign-magnitude(부호 절대값)
1111 1111 ~ 0111 1111 (-127~+127)
→ 8비트가 기본, 맨 앞 비트가 +인지 -인지 결정
→ 0001(+1) + 1001(-1) 하면 1010(-2)가 나온다 
→ 인간의 연산 방식과 다르게 동작해서 컴퓨터 세계에서는 잘 안 쓰인다, 엉뚱한 결과를 교정 하려면 cpu에 추가적인 회로가 필요하다(cpu 설계가 복잡하다)
→ 장점으로는 이해하기 쉽다

2. 1의 보수(보충해주는 수)(1's complement)
→ 모든 비트를 반대 값으로 바꾼다
10의 보수
5 → 5  6 → 4  7 → 3  4 → 6
9의 보수
5 → 4  6 → 3  7 → 2  4 → 5
00011000(+24) → 1의 보수(00011000에서 더했을 때 1인 수) → 11100111
+4 + (-2) = 2 → 0100(+4) + 1101(-2) = 10001(4비트인 경우는 앞에 비트를 날린다) 0001(+1)
→ 즉, 결과에 1을 더해야 하는 작업이 필요하다
단점 극복 → 음수로 만들 때 미리 1을 더해둔다 → 2의 보수

★ 3. 2의 보수 → 자바에서 음수를 저장할 때 사용(일반적으로 사용) ★
→ 1의 보수를 만든 다음 1을 더한다
→ +2의 음수 → 0010 + 1101 +1 = 1110(-2)
→ 0100(+4) +1110(-2) = 0010(+2)
오른쪽에서부터 1을 찾는다, 찾은 1의 왼쪽평에 있는 모든 비트를 반대 값으로 바꾼다
→ 0010 100(1) → 1101 0111
2의 n승에서 음수 값 만큼 뺀다(8비트일 때)
→ -44 = 256 - 44 = 212 →1101 0100

4. K-초과
→ K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다
→ K = 2**(비트 수-1)
8비트일 경우 → K = 2**(8-1) = 2**7 = 128, 결과 = 128 + 값
→ 1111 1111 = 128+127 ~ 0000 0000 = 128+(-128)

5. IEEE 부동소수점
→ K = 2**(비트 수-1)-1 공식을 사용
8비트일 경우 → K = 2**(8-1)-1 = 2**7-1 = 127, 결과 = 127 + 값
→ 1111 1111 = 127 + 128 ~ 0000 0000 = 127 + (-127)

6. Excess-K(K 초과법)
→ K = 2**(비트 수-1)
8비트일 경우
→ 2**(8-1) → 2**7 → 128
→ 0 1 ~ 255 → -128 + (+128)      -127 + (+128) ~ 127 + 128

★ 7. 비트 크기와 저장할 수 있는 값의 범위
8bit → -128 ~ +127
16bit → -32768 ~ +326767
32bit → 약 -21억 ~ 약 21억
64bit → 약 -922경 ~ 약 922경
→ 메모리 기본 단위 → 8bit(1byte)
정수를 저장하는 메모리 크기 분류 
8bit(1byte) → byte
16bit(2byte) → short
32bit(4byte) → int
64bit(8byte) → long
자바에서 정수를 저장하는 메모리 크기에 대한 별칭 → byte, short, int, long

정수 →2의 보수 규칙에 의해 변환 → RAM, HDD저장

★ ④ 부동소수점(floating point) → 부동(float) (단정도) → IEEE-754 
→ 부동소수점을 얼마나 정밀하게 저장할 수 있느냐는 메모리 크기에 달려있다
정규화(소수점 없애기)
3.14
→ 31.4*10**1 → 31.4E-1
→ 314*10**2 → 314E-2
→ 0.314*10**1 → 0.314E1
→ 0.0314*10**2 → 0.0314E2
★ 부동소수점 정규화 → 왼쪽 1만 남기고 소수점을 이동한다 (K = 2**(비트 수-1) -1 사용)
소수점 변환 규칙
12.375 → 12 = 1100
0.375 2진수 → 소수 부분은 2를 계속 곱해서 일의 자리를 뺀 것이 1bit이다
0.375*2 = 0.75 → 0
0.75*2 = 1.5 → 1 
0.5*2 = 1 → 1
→ 1100.011
→ 1100.011 → 1.100011*2**3 → 맨 왼쪽은 무조건 1이기 때문에 버린다 → 0.100011*2**3
0□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□31
0 → 부호 → 양수면 0 음수면 1
1~8 → 지수부 → 3+(2**8-1) → 3 + (128-1) → 3 + 127 → 130 → 10000010 → Excess-k방식
9~31 → 가수부 → 소수점 오른쪽 수만 가수부에 저장, 나머지는 0을 채운다 → 10001100000000000000000 → sign-magnitude방식
10진수 → 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16진수 → 0 1 2 3 4 5 6 7 8 9  a   b   c  d   e   f
2진수 4bit → 16진수 1bit → 간결하게 표현할 수 있다 → 간결한 표기, 변환용이, 그래서 16진수를 많이 사용한다
0x 0100 0001 0100 0110 0000 0000 0000 0000
0x   4     1       4      6      0      0      0      0 (32bit)
IEEE-754 부동소수점 (64bit) (double) (배정도)
→ float보다 2배 이상 더 정밀한 값을 보장 할 수 있다
부호 → 1bit 
지수부 → 11bit
가수부 → 52bit

★ 값을 입출력하는 크기
리터럴 데이터 → 4byte → 32bit → 0*32
정수
8bit(1byte) → byte
16bit(2byte) → short
32bit(4byte) → int 
64bit(8byte) → long
실수
float → 4byte → 32bit → 소수점을 빼고 7자리 이하면 98% 확률로 저장 가능 → 7자리 넘어가면 잘려서 저장될 수 있다
double → 8byte → 64bit → 16자리까지 저장 가능, 그 이후는 잘려서 저장된다
→ 시스템에서 필요한 만큼 소수점 이하 자리수를 적절히 짤라 사용하다
→ 37543.2741 → 375432741 → 9자리



2023.11.23(목)

★ RAM, HDD 등은 Byte(1Byte = 8bit) 단위로 읽고 쓴다 → 메모리 기본단위 = 입출력 기본단위

문자를 2진수로 변환하는 규칙(charser, 문자집합) → ASCII, ISO-8859-1, ECU-KR, 조합형, MS949, Unicode, UTF-8

자바에서 컴파일 하면서 encoding(변환하기)
$ javac -d bin/main -encoding UTF-8 src/main/java/com/ohoracs/basic/ex03/Exam35.java
① ASCII(American Standartd Code for Information Interchange)(7bit)
→ ASCII 코드는 인쇄 가능 문자 95자, 인쇄 불가능 문자 33자로 구성
인쇄 가능 문자 95자 → 알파벳 대소문자(영어), 숫자, 특수문자 등
A → 100 0001 (0x41)
B → 100 0010 (0x42)
......
a → 110 0001 (0x61)
b → 110 0010 (0x62)
c → 110 0011 (0x63)
.......
0 → 011 0000 (0x30)
1 → 011 0001 (0x31)
2 → 011 0010 (0x32)
.......
! → 010 0001 (0x21)
? → 011 1111 (0x3F)
# → 010 0011 (0x23)
& → 010 0110 (0x26)
+ → 010 10011 (0x2B)
space bar → 010 0000 (0x20)
......
인쇄 불가능 문자 33자
CR(Carriage Return) → 000 1110 (0x0D) → 커서를 그 줄에 맨 앞으로 옮기는 것
LF(Line Feed) → 000 1010 (0x0A) → 커서를 다음 줄(아랫 줄)로 옮기는 것
......
윈도우는 enter를 치면 LF와 CR을 입력
리눅스, 유닉스는 enter를 치면 CR만 입력

문자를 저장하는 원리
AB12 (Enter)
ab (Enter)
2진수로 변환
→ 41 42 31 32 0D 0A 61 62 0D 0A → 총 10byte로 변환한다
→ 키보드에서 Enter 키를 입력하면, 줄바꿈 코드값이 삽입된다

② ISO-8859-1(1, 2, 3, 4, 5, ..... = ISO-latin-1(1, 2, 3, 4, 5, ......) → 8bit = ASCII+유럽문자
A → 0100 0001 (0x41)

③ EUC-KR(= ISO-8859-1 + 한글문자) (16bit = 2byte) (국제표준) → 한글 문자에 대한 코드를 정의
A → 0x41
B → 0x42
......
가 → 0xB0A1
각 → 0xB0A2
간 → 0xB0A3
똘 → 0xB6CA
똠 → x (정의되어 있지 않다) → 또ㅁ → B6C7 A4B1
똡 → x (정의되어 있지 않다) → 또ㅂ → B6C7 A4B2
뜻 → 0xB6E6
똥 → 0xB6CB
방 → 0xB9E6
각 → 0xB0A2
하 → 0xC7CF
→ 한글 2350자 + 한자(한중일 공통 한자) + 한자(한국 전용 한자) + 등
→ 가각똠방각하AB → B0A1 B0A2 B6C7 A4B1 B9E6 B0A2 C7CF 41 42 → 가 각 또 ㅁ 방 각 하 A B

④ 조합형(16bit) = 1 + 초성(5bit, 32자)+중성(5bit, 32자)+종성(5bit, 32자) → 모든 한글 표현 가능(국제 표준이 아니다)
00000 → 없음
00001 → 채움 → 채움+ㅏ+채움 (15bit)
00010 → ㄱ     ㄱ
00011 → ㄲ ㅏ ㄲ
00100 → ㄴ ㅐ ㄳ
00101 → ㄷ ㅑ ㄴ
00110 → ㄸ ㅒ ㄵ
00111 → ㄹ ㅓ ㄶ
......
ㅏ → 1 00001 00011 00001(16bit) → 0x 8 4 6 1
깨 → 1 00011 00100 00001(16bit) → 0x 8 B 8 1
단 → 1 00101 00011 00101(16bit) → 0x 0 4 6 5
ㅏ깨단 → 0x84618B819465

⑤ MS949(CP949)(16bit) = EUC-KR + 나머지 한글 → 11172자 한글 지원 → 국제 표준이 아니다 ★저장을 하더라도 다른 운영체제에서는 읽을 수 없다★
가 → 0xB0A1
각 → 0xB0A2
......
똘 → 0xB6CA
뜸 → 0x8C63
똥 → 0xB6CB
→ EUC-KR
......
똡 → 0x8C64
똣 → 0x8C66
→ MS949에서 추가
.......

⑥ unicode (2byte~4byte) → 어떤 문자는 2byte, 어떤 문자는 4byte이다
→ 영어도 2byte 사용 → 메모리 낭비 → 메모리 낭비를 줄이기 위해서 UTF-8 등장
A → 0x0041
B → 0x0042
C → 0x0043
......
가 → 0xAC00
각 → 0xAC01
간 → 0xAC04
......
똘 → 0xB618
똠 → 0xB620
똡 → 0xB621
똣 → 0xB623
똥 → 0xB625
......
→ 새로 정의 했기 때문에 한글은 순서대로 코드값이 부여됨 11172자+@
→ unicode를 읽으려면 전용 에디터가 필요하다
→ Java는 문자를 다룰 때 unicode(UCS2 = UTF-16BE)를 사용한다

LE vs ★BE
가 → 00AC     AC00
A → 4100      0041
→ 코드가 뒤집힌다

⑦ UTF-8 (Universal Coded Character Set Transformation Format -8) → 전 세계 공통으로 토드화되 글자(캐릭터)의 집합, 변형, 포맷
unicode(UTF-16 BE) → 변형 → UTF-8
A → 0x0041 → 0x41
000000~00007F(3byte)  
→ 0000 0000 0000 0000 0000 0000 ~ 0000 0000 0000 0000  0100 0001 
→ 뒤에 7자리만 갖고 온다 → 0xxx xxxx → 0100 0001 → 결국 기존의 ASCII와 동일해졌다
000080~0007FF(3byte)
→ 0000 0000 0000 0000 1000 0000 ~ 0000 0000 0000 0111 1111 1111
→ 뒤에 11자리 갖고 온다 → 0000 0xxx xxxx xxxx → 110x xxxx 10xx xxxx → 110으로 시작하고 나머지 바이트들은 10으로 시작한다
→ 예 : 0000 0100 1010 1100 → 110 10010 10 101100
000800~00FFFF(3byte)
→ 뒤에 16자리 갖고 온다 → xxxx xxxx xxxx xxxx → 1110 xxxx 10xx xxxx 10xx xxxx → 1110으로 시작하고 나머지 바이트들은 10으로 시작한다
→ 예 : 0xAC00(가) → 1010 1100 0000 0000 → 1110 1010 10 110000 10 000000

논리값 
→ 4byte int 메모리에 저장
→ 배열 값인 경우 1byte 메모리에 저장
→ ture = 1, false = 0 값으로 저장 
→ 집점 정수 값을 지정해서는 안된다

★ 리터럴(Literal)
① 정수 literal
32bit → 4byte → int
→ 100 → 0x 0000 0064
64bit → 8byte → long
→ 100L, 100l(엘) → 0x 0000 0000 0000 0064

② 부동소수점 literal
32bit → 4byte → float
→ 3.14 → 3.14f, 3.14F
64bit → 8byte → double
→ 3.14 → 3.14, 3.14d, 3.14D

③ 문자 literal
★ 'A' → single quatation → 연산자 = 주어진 문자의 unicode(UCS2 = UTF-16BE (2byte)) 값을 리턴한다
→ 0x0041을 리턴
'가' → 0xAC00을 리턴

이미지 표현 방식
raster(bitmap)
→ 픽셀 단위로 나누고 픽셀을 색을 칠한다 
→ 확대하면 계단 현상 이미지가 깨진다 
→ 장점은 화면에 빠르게 나타난다, 단순한 그림이나 복잡한 그림이나 파일 크기가 같다 → 각 점을 3byte로 표현하기 때문
vector(truetype) 
→ 수학적인 공식으로 점과 점을 연결해서 선을 표현한다 면은 색상 값을 가진다 
→ 확대해도 이미지가 깨지지 않는다 
→ 정교한 작업 요구, 그릴 때 마다 명령어를 실행해야 하기 때문에 출력 속도가 느리다, 파일의 크기가 커진다

이스케이프 문자(escape character) = 문자 제어 코드
→ 화면에 출력하는 문자가 아니라 문자 출력을 제어하는 문자이다.
제어 문자
\n - Line Feed(LF), 0x0a → 줄 바꿈
\r - Carrage Return(CR), 0x0d 
→ 커서를 처음으로 돌리고 문자를 덮어쓴다
→ jshell> System.out.println("abcd\r123"); → 123d 출력
\f - Form Feed, 0x0c → 줄 바꿈해서 열을 유지한다(행+1열@)
→ abc\f
        def
\t - Tab, 0x09 → tab을 해준다 탭 크기만큼
\b - Backspace, 0x08 → 커서를 뒤로 움직인다
\' - Single Quote, 0x27 → ' 출력
\" - Double Quote, 0x22 → " 출력
\\ - Backslash, 0x5c → \ 출력

ASCII 1byte(7bit) → ISO-8859-1 1byte → ECU-KR 2byte → 조합형 2byte → MS949 2byte → unicode(UTF-16BE) 2~4byte → UTF-8 3byte



2023.11.24(금)

과제
콘솔에서 글씨 색깔, 볼드체 바꾸기
System.out.println("\u001b[30m"~"\u001b[47m" + "print" + "\u001b[0m")
System.out.println("\u001b[31m\u001b[1m[과제관리 시스템]\u001b[0m");
\u001b = \033
\033[0;31m(일반, 레드) \033[1;31m(볼드, 레드)

★ ANSI escape code
Color Name	Color code	Background Color	Background Color code
BLACK	\u001B[30m	BLACK_BACKGROUND	\u001B[40m
RED	\u001B[31m	RED_BACKGROUND	\u001B[41m
GREEN	\u001B[32m	GREEN_BACKGROUND	\u001B[42m
YELLOW	\u001B[33m	YELLOW_BACKGROUND	\u001B[43m
BLUE	\u001B[34m	BLUE_BACKGROUND	\u001B[44m
PURPLE	\u001B[35m	PURPLE_BACKGROUND	\u001B[45m
CYAN	\u001B[36m	CYAN_BACKGROUND	\u001B[46m
WHITE	\u001B[37m	WHITE_BACKGROUND	\u001B[47m

ANSI CODE 내용 → \u001B[1~7m
 0 Normal Characters
 1 Bold Characters
 4 UnderLined Characters
 5 Blinking Characters
 7 Reverse Video Characters

변수(variables) → 값을 담을 메모리
변수 선언 → 값을 담을 메모리를 준비시키는 명령문 → JVM이 관리하는 메모리에서 일부 메모리를 데이터를 저장 할 용도로 표시
→ 만들메모리종류(데이터 타입) 메모리이름(베리어블); → int a; → int a=10;

자바 기본 데이터 타입 → primitive data type
정수 → byte(1)128, short(2)32768, int(4)약21억, long(8)약922경
실수(부동소수점) → float(4)7자리, double(8)15자리
논리 → boolean(int를 가리킴, 배열이면 byte) 1/0
문자 → char(2) 0~65535유니코드(UTF-16, UCS2)

JVM과 메모리
모든 메모리는 OS가 관리 → 메모리를 사용하려면 OS에게 요청해야 한다
JVM(프로그램) 실행 → OS가 JVM이 사용할 메모리를 제공(자원 제공) → OS가 제공한 메모리 사용 → JVM 종료하면 JVM이 사용하던 메모리를 모두 회수(자원 회수)
프로그램 실행 → 프로세스process(실행중인 프로그램)

변수선언과 메모리 관계
int a; → 4byte 정수
char c; → 2byte unicode
int a, b, c;
JVM이 할당 받은 메모리에서 각 크기에 해당하는 메모리를 할당

변수에 값 저장하기
★ 변수 선언에서 '='은 assignment, 배정, 할당연산자
byte a;
a = -72;
-72 변환 후 저장 → 0100 1000 → 1011 1000 → ■□■■ ■□□□ 
char c;
c = '가'; 
0xAC00 변환 후 저장 → 1010 1100 0000 0000 → ■□■□ ■■□□ □□□□ □□□□
변수 초기화 문장(variables initializer)
int a = 100;  
     a = 100; → 초기화 문장
int x=20, y, z=10; → 가능

문자열 → 크기는 JVM에 따라 다르다, 메모리의 시작주소를 저장 → 레퍼런스(reference)
String s;
s="ABC"; → 6byte
unicode 변환 
→ 0041 0042 0043 → 00 41 00 42 00 43(6byte) 3글자(4byte) .....(문자열에 대한 부가정보)등 저장 
→ 전체 크기 알 수 없다(신경 안 써도됨)
문자열을 저장하고 있는 메모리 → String instance(인스턴스)

변수명
일반 변수 → camel(낙타) 표기법 → firstName → 첫번째 알파벳은 소문자, 각 단어의 시작은 대문자
상수(constants) → 변수에 값을 한번만 저장 할 수 있다(보통 대문자) → final int PI = 3.14f; → final int FIRST_NAME; → 단어와 단어 사이는 밑줄(underline)삽입
→ 변수명 자체가 뭘 의미 하는지 알 수 있다

변수 사용
String ANSI_RED = "\033[0;31";
String appTitle = "[과제관리 시스템]";
String munu1 = "1. 과제";
int a = 100;
System.out.println(100); → 직접 리터럴을 전달 할 수 있다
System.out.println(a); → 변수 a가 전달되는 것이 아니라 변수 a에 들어있는 값이 절단된다 
메소드 → 특정한 기능을 수행하는 도구

배열 → 같은 유형 메모리를 여러개 만드는 문법
자바 방식 → 데이터타입[] 레퍼런스 = new 데이터타입[변수개수];
classic 방식(c 방식) → 데이터타입 레퍼런스[] = new 데이터타입[변수개수];
→ int[] arr = new int[3]; → int 메모리를 연속해서 준비시킨다(자동 초기화)
 → 배열 메모리의 시작 바이트 주소를 저장하는 변수 → int 배열 reference
배열 메모리 → int 배열 instance

배열에 값 저장하기
int arr[] = new int[3];
arr1[1] = 271;
arr1[-1] = 100; → 인덱스 범위를 벗어나면 실행할 때 오류 발생 → out of index(RuntimeException) → 컴파일은 되지만 실행할 때 오류 발생

인스턴스와 가비지(garbage), 가비지 콜렉터(garbage collector)
int[] a = new int[3];  300번지 → 주소를 잃어버려 사용하지 못하는 인스턴스 → garbage →garbage collector가 해제하기 전까지는계속 garbage 상태로 존재한다 → 메모리 낭비
int[] a = new int[2];  400번지
a[1] = 100;  404번지에 저장
garbage collector 실행 
→ 메모리가 부족해지면 JVM OS에 메모리를 추가로 요청하기 전에 garbage collector를 통해 garbage를 메모리에서 제거하여 사용할 메모리를 확보한다



2023.11.27(월)

static type binding vs dynamic type binding
static type binding(정적 바인딩)
→ 변수의 타입이 고정된다
java
int a;
a = 100; → o
a = '가'; → 0xac00 → o
a = 3.14f; → x
a = 3.14; → x
a = true; → x
dynamn type binding(동적 바인딩)
→ 값을 할당할 때 변수의 타입이 결정된다 → 변수의 타입이 변동
javascript
var a;
a = 100; → number 타입 
a = 'aaa'; → string 타입
a = true → blooean 타입

명시적 형변환(explicit type conversion = explicit type casting)
→ 컴파일러에게 강제로 값을 넣을 것을 명령하는 것

만약 메모리의 크기를 벗어나는 큰 수의 값을 넣으려 한다면
→ 뒤의 바이트를 저장한다
short temp = 200; 
200(int) → 00000000 00000000 00000000 11001000
b2 = (byte)temp; → temp → 11001000(-56)
System.out.println(b2); → -56출력

★ 로컬 변수와 클래스 변수 사용
int a;
static int b;

MyClass obj1 = new MyClass();
System.out.println(obj1.a);
System.out.println(MyClass.b);

산술 연산자 주의사항
byte x=10. y=20. z;
z = x+y; → x
z = 10+20; → o
→ 리터럴 값인 경우 메모리에 넣을 수 있다면 허용한다
→ byte, short 변수의 연산은 무조건 int 단위로 이뤄진다
→ byte, short 변수는 연산을 수행하기 전에 int 메모리에 값을 저장한 후 연산수행!
→ 기본 연산 단위가 int이다
→ byte 연산 byte → int
→ short 연산 short →  int
→ int 연산 int → int
→ long 연산 long → long
→ float 연산 float → float
→ double 연산 double → double
int x=21억;
int y=21억;
int z=x+y; → int 범위 밖(오버플로우)값이 다르게 나온다
long r = x+y; → (x+y)를 연산해도 int형이기 때문에 값은 int z랑 같다
→ 연산 하기 전에 변환해서 연산을 해야한다
→ (long)x x타입을 long으로 바꾸라는 뜻이 아니다
→ x 변수에 들어있는 값을 long 임시 변수를 만들어 저장하라는 뜻이다 

암시적 형변환 → byte, short, char → int → long → float → double
→ 타입이 다르면 연산 불가 그래서 자동으로 타입을 같게 하는 것

부동소수점 비교
System.out.println((d1 + d2) == (x + y)); → 이렇게 하지 말 것

double EPSILON = 0.00001;
★ System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON); → 비교할 두 실수를 빼서 절댓값을 구한 뒤 개발자가 정해둔 범위보다 작으면 무시하자 ★

관계연산자
boolean a = false;
boolean b = false;
boolean r = a && (b=true); → b=true → a&&b
boolean r = a && (b=true);
첫 번째 피연산자 만으로 결과가 확정되기 때문에 두번째 문장을 실행하지 않는다 따라서 b는 여전히 false이다
boolean r = a & (b=true); → b=true → a&b
boolean r = a & (b=true); 
첫 번째 피연산자로 결과를 알 수 있다하더라도 뒤의 문장 끝까지 실행한다

LED vs OLED
LED → 빛을 쏘개되면 해당하는 색상을 보여준다(빛의 밝기로 조절) → 빛의 세기가 한번 통과되기 때문에 조금 어둡다
OLED → 화면 자체에서 빛을 발산한다 → 빛의 조금 밝다 → 오래 발산하면 열이 나고, 갈변된다
→ 지금은 기술이 극대화 돼서 비슷비슷하다
RGB = 8bit, 8bit, 8bit = 24bit = 3byte = 1pixel → 빛의 세기를 메모리에 저장
빛 RGB 검정색0~255희색
색 RYB 흰색0~255검정색
해상도 : 1920*1080(pixel 개수) → 가로*세로 → 2073600 → 약 200만 → 200만 화소
2073600 * 3 = 6220800 약 6.2MB
해상도 : 1200만 화소 * 3 = 3600만 byte = 약36MB → BITMAP(.bmp) 압축 → GIF, PNG(무손실 압축, 100% 원본 복구가능) , JPEG(손실 압축, 원본 복구 불가능)
동영상 → 1초당 화면 저장 → 24장 프레임 (영화), 약 30장 프레임 (TV)
HD급(1920*1080) → 6MB*24 = 144MB/초 → 144MB*60 = 8.6GB/1분 → 8.6GB*80 = 691GB/1영화 → MPEG(.mp4 압축)
 
   10110001
& 00111000
= 00110000
masking → AND 비트 연산자를 사용하여 특정 값을 차단할 수 있다
        R               G              B
   10110101  00010010   11111100
|  00000000  11001100   00000000
= 10110101  11011110   11111100
초록색 강화 → 원래 비트 값보다 더 큰 수로 변경되었다

% 연산은 빼기 연산을 여러 번 수행한다 그에 비해 & 비트 연산은 한번만 수행한다
54 % 1 → 54 & 0b1, 54 & 0x1
   00110110
& 00000001
= 00000000 (0) → 비트 연산 1번 수행 → 단 비트 연산을 활용할 경우, 2**n으로 나눌 때만 가능하다 → 2**n으로 나눈 나머지를 구할 때!
54 % 5 → & 연산 불가능
54 % 4 → & 연산 가능 54 & 0b0011
54 % 8 → & 연산 가능 54 & 0b0111

★ 연산자를 이용하여 짝수/홀수 알아내기 ★
System.out.println(57 % 2 == 0 ? "짝수" : "홀수");
System.out.println((57 & 0x1) == 0 ? "짝수" : "홀수");
(a == b ? c : d); → a와 b를 비교해서 참이면 c, 거짓이면 d를 실행

특정 위치의 비트 값만 추출학 싶을 때 사용한다
int data = 0b1111_1001_0111_1111;
System.out.println(Integer.toBinaryString(data & 0b0000_1111_1100_0000));
출력 → 100101000000 → 앞에 0은 버리고 출력한다

비트 이동 연산자
왼쪽 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.(양수일 경우) → 음수를 비트 이동 했다면 부호 비트까지 옮겨서 양수가 될 수도 있다
i = 11; // [00000000000000000000000000001011]
System.out.println(i << 1); //   0[00000000000000000000000000010110] → 22
System.out.println(i << 2); //  00[00000000000000000000000000101100] → 44
System.out.println(i << 3); // 000[00000000000000000000000001011000] → 88
int 타입 비트 이동 → 0~31까지 유효(n%32)
long 타입 비트 이동 → 0~63까지 유효(n%64)
3 << 33, 65, 97 → 3 << 1 같다
3 << 35
→ 31보다 큰 비트를 이동해야 한다면 32로 나눠서 나머지 값만큼 이동한다(n%32)
→ 3 << (35 % 32) → 3 << 3 → 3 * 2**3 → 24
→ 3 << (35 & 데이터타입비트-1) → 3 << (35 & 31) → 100011 & 011111 = 000011 → 3 << 3 → 3 * 2**3 → 24
→ 그냥 곱하기 보다 빠르다(value * 2**n 할 때)

오른쪽 비트 이동
105 >> 1
105 → 0000000000000001101001 → [ 000000000000000000110100]1
→ 왼쪽에 부호 비트를 붙인다 양수면 0, 음수면 1
→ value >> n → value / 2**n
→ value >> 1 → valsue / 2**1
→ value >> 2 → valsue / 2**2
→ value >> 3 → valsue / 2**3
→ 나눗셈 연산을 수행하는 것보다 실행속도가 빠르다 단 2**n으로 나눌 때만! → 소수점이 있을 경우 그 수보다 바로 밑 정수 값이 결과이다

>>> 이동
오른쪽으로 비트를 이동시킨 후 음수, 양수 상관없이 0을 채운다
int i = -87; // [11111111111111111111111110101001]
System.out.println(i >>> 1);
[ 1111111111111111111111111010100]1
[01111111111111111111111111010100]1     →      2147483604

비트 이동 연산으로 값 추출
int i = 0x27a130ff;
[00100111_10100001_00110000_11111111] → 27a130ff
담을 변수 = i >> 24 or 16, 8&0xff;
00000000_00100111_10100001_00110000  → 0x0027a130
& 00000000_00000000_00000000_11111111  → 0x000000ff
--------------------------------------
00000000_00000000_00000000_00110000

메모리 절약
lang2 = lang2 | 0x80 → 비트 연산자를 이용해서 적은 메모리를 더 많은 true/false를 저장 할 수 있다
touch Hello.txt
chmod 755 Hello.txt
final int CSS           = 0x01; // 0000 0001
final int HTML          = 0x02; // 0000 0010
final int PHP           = 0x04; // 0000 0100
final int PYTHON        = 0x08; // 0000 1000
final int JAVASCRIPT    = 0x10; // 0001 0000
final int JAVA          = 0x20; // 0010 0000
final int CPP           = 0x40; // 0100 0000
final int C             = 0x80; // 1000 0000

★ 문자열을 숫자로 변환
String s = '12345';
int a = Integer.valueOf(s);
int b = Integer.parselnt(s);



2023.11.28(화)

조건 연산자
변수 = 조건 ? 표현식1 : 표현식2
조건이 참이면 표현식1, 거짓이면 표현식2 리턴
→ 표현식은 반드시 값을 리턴해야 한다
statement → expression(값을 리턴하는 statement) → 표현식
statement는 expression을 포함하고 있다
statement
200 → expression(o)
"Hello" → expression(o)
true → expression(o)
System.out.println("Hi"); → expression(x)
Math.abs(-200); → expression(o)
3*2 → expression(o)
if(){} → expression(x)

test()라는 명령블록(함수, 메소드)에 전달하는 값을 아규먼트(argument)
전달받은 값을 담는 변수 파라미터(parameter)

증감 연산자 → ++, --
전위 연산자(prefix operator) → ++변수, --변수
후위 연산자(postfix poerator) → 변수++, 변수--
int a = 100;
++a; → a = a + 1 → 101
++a; → a = a + 1 → 102
--a; → a = a - 1 → 101
--a; → a = a - 1 → 100

후위 연산자
int a = 100;
→ int temp(임시 변수) = a; → a = a + 1 → b = temp → b = 100, a = 101
b = a; → a = a + 1
→ 항상 r-value를 먼저 실행한 후에 할당(=) 연산을 수행한다
int a = 100;
a++;
★ 추측 1 → 항상 r-value를 먼저 실행한다
→ int temp = a; → a = a + 1 → a = temp → 100
추측 2
a = a → a = a + 1 → 101
++a++ → a = a + 1 → 101++ → 값에 대해 ++ 연산을 사용할 수 없다

흐름 제어문
조건문(if, if~else, if~else if~else, switch~case~default), 반복문(while, do~while, for), 흐름제어문(continue, break)
조건문
if~else → if문은 if와 else만 있다 
→ if~else if~else 이렇게 보이기만 할 뿐이다
switch~case~default 
→ switch(byte, short, int, char, 문자열, Enum만 가능) 
→ case(리터럴 값만 가능하다, 변수 불가능, fianl a 상수는 가능) 
→ break를 안 해주면 밑에 있는 case문까지 실행 되기 때문에 적절히 사용해야 한다
enum Level {
    GUEST, MEMBER, ADMIN
}
Level level = Level.MEMBER;           → enum 변수에는 그 타입에 정의된 값만 저장할 수 있다 → 안전한 코드 작성 가능

반복문
while(조건, true) {} → 조건이 참이면 계속 반복한다, 무한반복 하고 싶으면 true를 넣으면 된다
break → 자신이 소속된 가장 가까운 반복문을 나간다
continue → 다음 문장을 실행하지 않고 즉시 조건 검사로 이동한다

myloop: 반복문
myloop: 반복문1{반복문2{}}
break myloop; → myloop 라벨에 소속된 문장을 나간다

do~while → 최소 한 번은 실행하고 다음에 조건을 확인하여 반복을 계속할지 결정하는 반복문이다
do{ 
  문장;
}while(조건, true);

for(초기화; 조건; 증감){
  반복 실행 코드
}
for(int i = 0 ; ; ){
}
→ for 문 안에 선언된 변수는 for 문을 나가는 순간 제거된다

리스트
ArrayList<String> list = new ArrayList<>();

키보드 입력 다루기 
① read() 사용 → data를 읽을 때 사용하는 도구(메소드 = 수단, 방법)
레퍼런스.read()
레퍼런스 → 정보를 담고 있는 메모리의 주소
정보 → data를 어디에서 읽어야 하는지에 대한 정보 → read()가 작업할 때 필요한 정보를 갖고 있는 메모리 → 인스턴스(Instence) → 객체(object)

입력값 받기
Scanner keyScan = new Scanner(System.in);
System.out.print("나이를 입력하세요? ");
int age = keyScan.nextInt();
char c = keyScan.nextLine();
keyScan.close();

★ 배열로 5명의 이름을 연속적으로 입력받기
String[] names = new String[5];
Scanner nameScan = new Scanner(System.in);
for (int i = 0; i < 5; i++) {
	System.out.println("5명의 이름을 적어주세요");
	names[i] = nameScan.nextLine();
      	// System.out.println("입력된 이름 : " + names[i]);
    }
for (String s : names) {
      	System.out.println("입력된 이름 : " + s);
    }
nameScan.close();

★ 메소드와 레퍼런스(= 객체 = 인스턴스)
System.out.println("Hello");
println("Hello") → println = 연산자(method) = message, "Hello" = 피연산자(argument) = parameter → 실제 작업을 수행하는 명령 = 메소드 = 메시지 = 특별한 연산자
System.out → 피연산자(argument) → JVM 기본 출력 장치의 정보가 들어있는 메모리의 주소 → 터미널(terminal)
→ println()이 정보(System.out)를 사용해서 출력할 대상을 결정한다

★ Hello를 파일에 출력하기
OutputStream output = new FileoutputStream("test.txt");
PrintStream output2 = new PrintStream(output);
output2.pintln("Hello");
---------------------------------------------------------------------
PrintStream output2 = System.out;
output2.println("Hello");
---------------------------------------------------------------------
output2.close();
---------------------------------------------------------------------
밥 a = new 밥(쌀);
밥그릇 b = new 밥그릇(a);
b.먹자("달걀");

★ 입력 받기
java.io.InputStream keyboard = System.in;
java.util.Scanner keyboardScanner = new java.util.Scanner(keyboard);
→ java.util.Scanner keyboardScanner = new java.util.Scanner(System.in);

System.out.print("이름? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("전화? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("이메일? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("나이? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("재직여부? ");
System.out.println(keyboardScanner.nextLine());
keyboardScanner.close();

nextLine(), nextInt(), nextBoolean()
String name = keyboardScanner.next(); → 한 개의 토큰을 읽을 때 유용하다.



2023.11.29(수)

System.in → 표준 입력 장치의 정보가 저장된 메모리의 주소를 보관하고 있는 레퍼런스
주소 → 메모리(표준입력장치 정보(스트림 입구), keyboard 등) → 프로그램 외부에서 데이터가 들어올 수 있는 기본 입구
표준입력, 출력스트림(흐름)
$ wc(enter) → aaa bbb ccc(사용자가 키보드로 입력한다) → 전달 → wc프로그램 → 표준입력장치에 출력
다른 프로그램의 출력
$ cat Hello.c |(pipeline) wc(enter) → cat프로스램이 Hello.c파일 읽어서 전달(표준출력장치) → wc프로그램 → 표준입력장치에 출력
모든 프로그램                        ┌→ 표준오류스트림(System.err) → 오류가 발생했을 때 오류 정보를 내보낼 때 사용하는 특별한 출구
★ 다른 프로그램의 출력스트림과 연결, 키보드로 입력 
→ 표준입력스트림(system.in)(프로그램 외부에서 데이터가 들어올 수 있는 기본 입구) 
→ 프로그램 
→ 표준출력스트림(System.out)(프로그램 실행결과를 외부로 내보낼 수 있는 기본 출구)
→ 터미널 연결, 다른 프로그램의 표준입력스트림과 연결, 파일과 연결
데이터 입력 → 표준입력스트림 → 프로그램 → 표준출력스트림
                          ┌→ 오류스트림
표준입력스트림 → 프로그램 → 표준출력스트림
	             ↑   ↕ 
	    	↓  ★ networt 외부 네트워크로 데이터를 주고 받기 위해 입/출구를 뚫는 것 = 소켓(socket)
	★ 외부파일로 데이터를 읽고/쓰기 위해 입/출구를 뚫는 것 = File I/O스트림
System.in → 수행할 수 있는 명령 read(), read(byte[]) → 한 줄 단위로 입력된 문자열을 읽는 작업을 수행시킬 명령은 없다
→ new Scanner(System.in) → 표준입력스트림을 좀 더 정교하게 제어하려면 추가 데이터와 도구(메소드)가 필요하다
Scanner
Scanner + 추가도구 → System.in → nextLine(), nextInt(), next() → 한 줄을 읽는다
★ 메소드 실행(호출)
Scanner keyIn = new Scanner(System.in);
keyIn.nextLine();
keyIn → 레퍼런스 = 정보가 들어있는 메모리의 주소 → Scanner 정보 = Scanner 객체 
→ keyIn 변수에 Scanner 정보가 들어있는 것은 아니지만 정보가 들어있는 변수로 간주하여 표현
→ 의사소통을 단순하게, 이해를 쉽게
nextLine() → 레퍼런스에 적혀있는 주소로 찾아가서 그 메모리의 저장된 정보를 이용하여 작업을 수행한다
틀린 표현 → "keyIn(scanner reference) 객체에 대해 nextLine()을 호출"
맞는 표현 → nextLine() 메소드를 실행하려면 scanner 정보(객체)(scanner instance)를 이용하여 실행
★ scanner 객체에 nextInt() 메소드 호출

nextInt(), nextLine(), ....
나이? 30(enter)
nextInt() → 30까지 읽고 30(int)를 리턴 → nextLine() → 30 다음에 (enter)를 읽어서 빈문자열""을 출력


















8.4







