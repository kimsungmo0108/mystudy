엄진영 강사님
id : 210 866 3081 pw : 123456
https://github.com/eomjinyoung
https://github.com/eomjinyoung/bitcamp-study/tree/main
token → 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
★ cmd 에서 intl.cpl → 운영체제에서 언어 변경
-------------------------------------------------------------------------------------



2023.11.14(화)
-------------------------------------------------------------------------------------
Application → client/server → client Application/Application server → web Browser/web Application server
web Browser → HTML/CSS/JS road
web Application server → DBMS/JAVA 실행
Spring Boot → servlet container 와 Spring Framwork
servlet container → web server가 위임 해서 Spring Framwork 명령해서 결과값 반환
Spring Framwork → JAVA 파일들을 실행해서 반환
아키텍처 → 목표하는 대상에 대하여 그 구성과 동작 원리, 구성 요소 간의 관계 및 시스템 외부 환경과의 관계 등을 설명하는 설계도 혹은 청사진
-------------------------------------------------------------------------------------



2023.11.15(수)
-------------------------------------------------------------------------------------
stereotype : 정형화된 표현
instruction set : 기계어
Application(photoshop) → CPU에게 기계어로 명령 → CPU는 실행 → Application(photoshop)에게 결과값 반환
Qualcomm cpu(퀄컴)
Intel cpu(인텔)
Apple M2(애플)
ARM cpu(암)
cpu가 다르면 기계어도 다르다
★ cpu에 맞는 기계어로 작성해도 운영체제에 맞는 형식이어야 한다.
App → windows OS → Intel cpu   여기서만 동작
App → mac OS → intel cpu
★ 각 OS 기계어
windows OS → PE(Portable Executable)
mac OS → Mach-O
Linux → ELF(Executable and Linkable Format)
-------------------------------------------------------------------------------------
APP 만들기
assembly language(어셈블리어) → 기계어를 사람에 언어로 표현(기계어 형식과 흡사한 문법 Low-Level Language)
어셈블리어에서 기계어로 변환 → assembly compiler(운영체제 회사가 지원)가 compile(변환)
어셈블리어는 OS에 종속적이고, OS마다 약간씩 달라서 OS마다 따로 작성해야 한다(불편).
→ OS에 상관없이 같은 문법으로 명령을 작성할 필요가 있다.(C언어가 등장)
★ C언어(source 코드) → C Compiler로 compile(어셈블리어로 변환) → Assembly Compiler로 compile(기계어로 변환) → APP에서 실행
C언어(HIGH-Level Language)
→ OS에 상관없이 동일한 문법
→ 좀 더 인간에 친숙한 문법
-------------------------------------------------------------------------------------
JAVA APP 만들기
★ .Java(sourece code)를 JAVA compiler로 compile → .class(Bytecode 또는 portable-code)(기계어는 아니고 흡사한 명령어들) → Bytecode Player에 입력 → windows OS 실행 → Intel cpu 실행
Bytecode player → Engine, Interpreter(해석기), View, VM(Virtual Machine), JVM(Java Virtual Machine)
각 OS 및 cpu 별로 컴파일 해야하는 불편함이 있어 중간에 Bytecode로 변환해서 사용한다.
자바 캐치프레이즈 → 모든 플랫폼(OS+cpu)에서 하나의 코드로 동일한 결과를 얻기 
"Write once, Run Anywhere"("작성은 한 번만, 돌리는 건 어디서든")
단점 : 기계어를 직접 실행하는 방식이 아니기 때문에 실행속도가 느리다.
-------------------------------------------------------------------------------------
Java SE(Standard Edition)
JRE(Java runtime Environment)자바 실행 환경
→ JVM + 실행 관련 파일
JDK(Java Development Kit)
→ JRE(JVM + 실행 관련 파일) + 컴파일러, 디버거, 프로파일러 등 개발도구
Java EE(Enterprise Edition) → 기업용 서버 APP 제작에 필요한 도구
Java ME(Micro Edition) → 임베디드 APP 제작에 필요한 도구
개발자(우리) → JDK + Jave EE 일부 설치
-------------------------------------------------------------------------------------
JDK 설치
→ JDK 설치 경로를 OS에 등록 → 어느 디렉토리에서도 JDK를 실행할 수 있도록 등록 → PATH 환경변수 = JDK/bin;.......
→ JDK 설치 경로를 'JAVA_HOME'이라는 이름으로 등록 → Java App이 쉽게 JDK를 찾을 수 있도록 등록 → JAVA_HOME = JDK 디렉토리 설정
JAVA_HOME 설정 이유 → 어떤 프로그램에서는 JDK 경로를 알아야 프로그램이 실행이 되므로 
-------------------------------------------------------------------------------------
CLI(Command Line Interface) → 글자를 입력하여 컴퓨터에 명령을 내리는 방식이다.
→ GUI와 대립
-------------------------------------------------------------------------------------
cmd 명령어
echo %PATH% = echo $PATH
JAVA -version
-------------------------------------------------------------------------------------
★cmd, git bash에서 실행
javac Hello.java → Hello.class 생성 → java Hello
jshell → int a = 100;
ctrl + d로 나오기
테스트 할때 java Hello.java
REPL(Read → Evaluation실행, 평가 → print → loop) = jshell → 간단히 자바 명령을 실행, 테스트 하는 용도
-------------------------------------------------------------------------------------
★ git 저장소
github.com → git server 운영(repository에 소스파일 저장)
git → software(소스) configuration(형상, 변화) management(SCM) → 형상관리 시스템, 소스 변화 관리 = 버전 관리
→ 소프트웨어의 변경 사항을 관리하는 데 사용되는 프로세스
개발자 → git client 사용(repository) → repository에서 소스파일 저장 하고 읽기
-------------------------------------------------------------------------------------



2023.11.16(목)
-------------------------------------------------------------------------------------
SCM(Software Configuration Management 소프트웨어 형상관리)
→ 소프트웨어의 변경사항을 체계적으로 추적하고 통제한다
도구 종류 → CVS(Concurrent Version System), SVN(Subversion), GIT
QA(QM)(소프트웨어 품질보증(품질관리)) → 소스관리(공유, 소스 접근 제어 등), 버전관리(변경 기록, 롤백, 제품에 사용될 소스 관리 등), 빌드구조, 개발환경, 문서
빌드
컴파일 → 테스트(테스트 후 보고서) → 문서 → 패킹 → 배포
★ 버전 관리 시스템 = 형상관리 분야에서 소스관리와 변경관리를 처리하는 프로그램
1. 로컬 버전관리 시스템 RCS(Revision Control System) →Local(개발자 pc)에서 개발도구로 소스파일을 편집(생성, 변경, 삭제)하고 폴더에 보관
단점 → 팀원 간 공유 불가
-------------------------------------------------------------------------------------
2. 중앙 집중식 버전관리 시스템 = 모든 기록은 서버에 보관(중앙 서버에서 파일을 받아(checkout) 사용할 수 있다)
장점 → 팀원끼리 소스 파일 공유 가능
개발자가 서버에서 다운로드 → checkout, 개발자가 서버에 업로드 → checkin
CVS(concurrent Version System) → checkin할 때 파일 통째로 업로드
단점 → 네트워크로 주고 받을 데이터양이 크다
SVN(Subversion) → checkin할 때 파일에서 변경 부분만 업로드
장점 → CVS에 비해 통신양이 줄어든다
문제! → 만약 서버에 문제가 생기면? → 변경기록이 날아간다 → 로컬에도 변경 기록이 없다
단점 → 소스파일 복구는 가능하지만 기록은 복구 불가!!!!!!!!
-------------------------------------------------------------------------------------
3. 분산 버전관리 시스템 → 기록을 여러 컴퓨터에 분산 보관
★ GIT 사용법 (git bash)(Bourne again shell)
장점 → 서버의 분제가 발생하더라도 원상복구 가능!!
① Clone은 모든 데이터를 가진 진정한 백업 → 저장소를 히스토리와 더불어 전부 복제
클론 하는법 → $ git clone URL(백업 할 주소)
★ mystudy 밑에 숨겨진 폴더를 보게되면 .git이 있다 이곳에 변경 기록을 보관하는 폴더이다
.git 폴더를 제외하고 나머지가 working directory(작업 폴더)이다

★ markdown
READ.md 파일 → 컴파일해서 HTML 파일로 만든다. → 웹 브라우저가 HTML을 다운로드 받아서 렌더링
텍스트 파일과 Markup
plain text → data들만 있는 텍스트
markdown → data와 metadata, tag(#, ![alt text](image link) 등)가 같이 쓰인다, HTML보다는 간결하다.
HTML → data와 metadata, markup, tag(<h1></h1>, <p></p> 등)가 같이 쓰인다
텍스트 파일(text file) <=> 바이너리 파일(binary file)
텍스트 파일 → 텍스트 편집기으로 편집 가능한 것 (.txt  .java  .html  .xml  .rtf  .css  .js  .yml)
→ 메모장, vi, 리유닉스 텍스트 편집기(nano, emacs), vscode
바이너리 파일 → 전용 편집기로 편집 가능한 것(.jpg  .png  .mp4  .pdf  .xls  .ppt)
→ 포토샵, 프리미어, 엑셀, 파워포인터, 워드, 아레아한글

② git add
현재 작업 디렉토리 → mystudy/
local → .git/
       → README.md
       → test.md
       → test.html
       → test.txt		→저장소에 보관
★ → 대상 파일을 백업 명단에 추가 → $ git add 대상파일
★ 내보낼려면 → $ git restore --staged test.html
→ 백업 → $ git commit -m "백업내용"
$ git config --global user.name "kimsungmo0108"
$ git config --global user.email "rlatjdah8585@daum.net"

③ git push → 로컬 저장소의 변경 내용을 서버 저장소에 업로드
token → 일회권 발행권
untracked → git의 버전 관리 대상이 아닌 상태
unmodified → 마지막 커밋 이후에 아무것도 수정하지 않은 상태
modified → 파일의 내용을 변경한 상태
staged →  다음 커밋에서 저장하도록 staging area에 등록되고 표시된 상태

④ git pull → 서버 저장소의 변경사항을 로컬 저장소로 다운로드
$ git pull → 변경 파일을 working directory로 꺼낸다 → 기존 파일에 변경 내용을 합친다(★merge)

⑤ git log → commit 된 모든 기록
snapshot → commit 할 때 파일들에 모든 상태(삭제, 버전 업, 생성)를 기록한다
→ 그래서 복구 해야하는 파일들을 불러올 수 있다
git log --oneline → 기록들을 간략하게
★ $ git checkout 복구암호키(해시 SHA-1) → 저장소에서 특정 commit의 파일을 working directory로 꺼내기
최신 commit → $ git checkout main
브랜치 → 커밋 사이를 이동할 때 사용하는 포인터 같은 것 
-------------------------------------------------------------------------------------



2023.11.17(금)
-------------------------------------------------------------------------------------
전날 복습
program → 특정 작업을 수행하는 명령어들
소프트웨어 형상(software configuration) → program + 문서(실행파일 + 사용자 가이드 + 개발 문서) + zip + 인스톨러
버전관리 시스템 → 특성에 대한 변경을 제어, 변경 처리 상태를 기록 및 보고
관리 → tracking + controlling

GIT 사용법
⑥ 충돌과 해결 방법
충돌
→ 이미 서버에서 받았던 mystudy 폴더를 mystudy2라는 폴더로 clone
$ git clone https://github.com/kimsungmo0108/mystudy mystudy2
→ mystudy2에서 test.html파일을 변경 후 commit과 push
→ mystudy에서 test.html파일을 변경 후 commit과 push → reject(거부), 충돌 발생(comflict)
해결
→ mystudy에서 git pull 하면 서버에서 알아서 합쳐준다(merge)
→ 병합된 test.html파일을 commit과 push → server에 업로드
→ mystudy2에서 git pull을 해도 ok
→ ★ pull할 때 폴더에 파일이 없으면 백업이 안된다
-------------------------------------------------------------------------------------
★ 컴파일러 버전과 클래스 파일
Hello.java
→ Javac 11 → Hello.class(바이트 코드) → JVM 11 → JVM 11 이상 실행 가능
→ javac 17 → Hello.class(바이트 코드) → JVM 17 → JVM 17 이상 실행 가능
→ javac 21 → Hello.class(바이트 코드) → JAM 21 → JVM 21 이상 실행 가능
→ JVM 상위 버전은 javac 하위 버전을 실행 가능, JVM 하위 버전은 javac 상위 버전을 실행 불가능
-------------------------------------------------------------------------------------
버전 관리 시스템의 관리 대상
관리 대상 → 소스파일, 문서, 설정파일
비관리 대상 → 개발도구 설정파일, 빌드(컴파일) 결과파일(.class .exe .jar 등) → 개발자의 환경에 따라 달라지는 파일은 관리 대상이 아니다 → 빌드 결과물도 관리 대상이 아니다
★ 관리 대상에서 제외 시킬 방법은? → .gitignore(무시) 파일에 등록 → *.class 하고 저장 → 개발 툴마다 무시할 파일이름 gitignore.io 사이트에서 생성 가능
* wildcard
temp/ → 폴더 제외 → 한 줄에 한 항목 
/로 시작하면 하위 디렉토리에는 적용되지 않는다
!로 시작하는 파일은 무시하지 않는다
바이트코드(.class)는 commit하면 안 된다 → 개발자 환경에 따라 다른 파일은 올리면 안 된다 → 운영체제에서 자동으로 생성되는 파일
-------------------------------------------------------------------------------------
인터프리트 소개 및 테스트
소스파일 → (읽기 → 문법검사 → 해석) → 인터프리터 → 실행 → OS
$ node Hello.js
종류 → .js → nodejs, .py → python, .php → PHP 엔진, 등
★ 인터프리트 특징
→ 소스파일을 직접 읽어서 실행
→ 실행할 때 소스파일 필요
→ 인터프리터가 있어야 한다
→ 실행할 때마다 매번 문법검사(컴파일 방식에 비해서 속도가 느리다)
→ 코드에 오류가 있더라도 실행 하기 전까지 알 수 없다
-------------------------------------------------------------------------------------
컴파일 방식
소스파일 → 컴파일러(문법검사 → 기계어 변환) → 실행파일 → 실행 → OS
gcc.exe → c 컴파일러 
→ $ gcc Hello.c or $ gcc -o Hello.exe Hello.c → Hello.c(명령 프롬프트cmd) or ./Hello.exe(git bash)
g++.exe → c++ 컴파일러 
→ 
★ 컴파일 특징
→ 컴파일할 때 문법검사, 기계어 변환
→ 실행할 때 바로 실행 : 인터프리터 x, 컴파일러 x
→ 기계어기 때문에 실행속도 빠르다(인터프리터 방식에 비해서)
→ 소스코드를 노출하지 않는다(자산 보호)
단점
→ OS에 종속
-------------------------------------------------------------------------------------
Hybrid 방식 → 자바
소스파일 → 컴파일러(문법검사, 가상의 기계어 변환) → 바이트코드(기계어가 아닌 중간언어이기 때문에 직접 실행불가) → JVM(ByteCode 인터프리터) → 실행 → OS
★ 소스파일~바이트코드(컴파일 방식) → 바이트코드~OS실행(인터프리트 방식)
★ 자바 특징
→ 컴파일 방식의 이점을 취한다
→ 소스코드를 비노출(자산 보호)
→ 컴파일 과정 문법검사 완료
→ 가상의 기계어로 번역
→ 특정 cpu에 비종속 → cpu마다 컴파일 x
→ OS에 JVM이 설치되어 있으면 실행가능
단점
→ 진짜 기계어를 실행하는 것보다 느리다 → 그러나 OS 상관없이 실행할 수 있다는 것이 더 이득이 되기 때문에 이 방법 사용
-------------------------------------------------------------------------------------
Java vs C#
자바 → 소스 → 컴파일 → 바이트코드 → 실행 → JVM
C# → 소스(C#, Visual Basic) → 컴파일 → 공통중간언어CIL(Common Intermediate Language) → 실행 → .NET

① 이전 방식
Bytecode → 명령어 하나씩 읽기 → JVM → 실행 → OS

② ★ JIT(Just in Time) 컴파일 방식 (개선 방식)
JIT(Just in Time) → 바로 그 시점에 → 실행 시점에 자주 실행하는 코드를 진짜 기계어로 바꿔놓고 그 기계어를 실행하여 실행속도를 높이는 방식
ByteCode → 명령어 읽기 → JVM → 실행 → OS
		        → JVM(자주 실행되는 일부 명령은 실행시점(JIT)에 기계어로 바꿔 보관)
		        → cache(보관소)(캐시에 보관된 기계어는 실행 완료할 때 제거된다 영구히 보관하는 것이 아니다)
		        → 실행(일부로 기계어 직접 실행) → OS

③ ★ AOT(Ahead of Time) 컴파일 방식 → JIT 방식은 실행 시점에 컴파일 하기 때문에 실행이 느려지는 문제가 있다
PlayStore에서 APP 다운 → 1. download 2. 설치할 때 기계어로 변환 → Android → 3. 미리 전체 컴파일 → cache에 기계어를 보관 → 4. 실행
→ 실행 속도가 빠르다
→ 설치할 때 기계어로 바꾸기 때문에 설치시간이 길어졌다
모바일 APP 배포와 컴파일 
개발자가 APP제작 → playstore에 업로드 → APP 다운로드 → 컴파일 → 기계어 → phone1(Qualcomm)
				  → APP 다운로드 → 컴파일 → 기계어 → phone2(MediaTek)
				  → APP 다운로드 → 컴파일 → 기계어 → phone3(Exynos)
AOP(Aspect-oriented Programing) → AOP는 프로그래밍 패러다임이다
-------------------------------------------------------------------------------------
자바 프로젝트 표준 디렉토리 구조
① Maven 빌드 도구의 프로젝트 표준 디렉토리 구조
② 빌드란? 
→ 컴파일 → 테스트 → 보고서/문서 생성 → 배포파일 준비 → 배포
→ 소프트웨어 제작 전체 과정
③ ★ 빌드 도구란?
→ build 작업을 수행하는 도구 
→ build 도구 → 사용 → 컴파일러 → 컴파일 수행
	      → 사용 → 디버거 → 디버깅 수행
	      → 사용 → 문서 생성기 → 문서 생성 
	      → 사용 → 배포 파일 생성기 → 배포 파일 생성
	      → 사용 → 테스트 도구 → 테스트 수행

④ 빌드 스크립트 파일
빌드 스크립트 파일 → 읽기 → 빌드 도구 → 스크립트 파일에 설정된 정보를 사용하여 빌드 수행 → 빌드 자동화
빌드 스크립트 파일(명령을 담은 파일)
→ 빌드에 사용할 정보(소스 폴더의 경로, 배포 파일의 이름 등)
→ 빌드 순서
→ 빌드할 때 사용할 도구
→ 등
빌드 자동화
사람이 일일이 빌드 과정에 개입할 필요없다
전체 과정을 자동화 시킬 수 있다

⑤ 현업에서 사용하는 빌드 도구
Ant(apache.org) → build.xml(build script file)
Maven → pom.xml(project object model.xml)
Gradle → build.gradle
★Ant → 의존 라이브러리 관리 기능을 포함(자동 다운) → Maven
Ant → 개발자가 직접 소스코드의 위치와 소스코드의 빌드가 된 파일의 위치, 산출물을 어디에 위치시켜야 하는지 정확하게 지정해주어야 한다
Maven → 어디에 소스코드가 위치하고, 소스코드 컴파일, 컴파일 된 소스코드의 산출물의 위치 등이 이미 다 지정되어 있어 따로 일일히 작업을 해주지 않아도 된다.
★ 라이브러리
인간의 도서관 → 책
소프트웨어의 도서관 → 컴파일된 코드(자바, c++, c) 또는 날것의 코드(자바스크립트, 파이썬)
프로젝트에서 사용하는 외부 부품/프로젝트에서 사용하는 다른 개발자가 만든 코드(컴파일 된 상태)
★ Gradle → 빌드 스크립트를 작성할 때 xml 대신 groovy 언어 사용 → Gradle(Groovy, kotlin 언어 사용)
→ 프로그래밍 언어를 사용함으로써 보다 정밀하게 빌드 과정을 제어할 수 있다
→ 그래서 안드로이드 기본 개발 도구로 Gradle을 사용한다
-------------------------------------------------------------------------------------



2023.11.20(월)
-------------------------------------------------------------------------------------
자바 프로젝트 준비
① src, bin 폴더 분리
src → 소스 파일
bin → 빌드 결과 파일, 컴파일 결과 파일
기본 컴파일
$ javac src/Hello.java
★ 목적 컴파일
$ javac -d src/Hello.java
★ 자바 목적 파일 실행
$ java -classpath bin Hello
$ java -cp bin Hello
★ GIT 저장소와 프로젝트 폴더
1. GIT 저장소 = 프로젝트 폴더 → 보통 방식, 일대일 저장
mystudy/
  → src/
2. GIT 저장소 = 여러 개의 프로젝트 폴더 → 메인 프로젝트 1, 서브 프로젝트 여러 개
mystudy/
  → projectA → main project
    →src
  → projectB → sub project
    →src
★ Maven 표준 프로젝트 디렉토리 구조
java-project/
  → src/
    → main/ → Application 소스 파일을 두는 폴더
      → java/ → 자바 소스 파일(.java)
      → resources/ → 설정 파일(.xml, .properties)
      → kotlin/ → 코틀린 소스 파일 (.kt)
      → 등
    → test/ → 단위 테스트 소스 파일을 두는 폴더
      → java/
      → resources/

② Gradle 설치 및 설정
1. 설치 gradle.org → path 환경변수 설정
★ 2. 프로젝트 디렉토리 이동 → $ gradle init(application, java, groovy) → 빌드 스크립트 파일 자동화
DSL(Domain-Specific Language) → 특정 영역에서 사용하는 언어
→ 빌드 스크립트(build.gradle) 특정 영역에 코드를 작성할 때 사용할 언어
★ gradle init
java-basic/ → root project
    → .gradle/ → gradle 설정파일, Local마다 다를 수 있다, 공유 X
    → app/ → main project
        → src/
            → main/
                → java/
                → resources/
            → test/
                → java/
                → resources/
        → ★ build.gradle → gradle 빌드 스크립트 파일
    → gradle/ → gradle을 로컬에 설치해주는 도구, 로컬에 gradle이 설치 안된 경우에 사용된다
    → gradlew → Linux/Unix 용 → 로컬에 gradle이 설치 안된 경우에 사용한다
    → gradlew.bat → windowd 용 → 로컬에 gradle이 설치 안된 경우에 사용한다
    → settings.gradle → gradle 빌드 스크립트 보조 파일
    → .gitattributes → git 관련 파일
    → .gitignore → 형상 관리 시스템에 추적을 무시

③ Gradle 사용법
https://docs.gradle.org/current/userguide/plugin_reference.html → gradle 사이트
1. 가이드 → Gradle로 수행할 수 있는 작업 목록 출력
→ $ gradle tasks
→ $ gradle tasks --all
Gradle → 1. 읽기(빌드 스크립트에 설정된 정보를 바탕으로 실행) → build.gradle/setting.gradle
          → 2. 빌드 스크립트에 설정된 것을 바탕으로 실행

Gradle 빌드 스크립트 파일(build.gradle)
plugins{
  → Gradle을 실행할 때 사용할 플러그인
  → id "플러그인명" → 'java' 플러그인 → 자바 소스 빌드 작업을 수행
		 → ' e' 플러그인 → 자바 소스 빌드 작업을 수행
		 → 'application' 플러그인 → java 플러그인 + 실행
		 → 'jar' 플러그인 → 패킹 작업을 수행
		 → 등 여러가지가 있다
}
repositories{
  → 외부 라이브러리를 다운로드 받을 서버 정보
}
dependencies{
  → 외부 라이브러리 정보
}
-------------------------------------------------------------------------------------
★ 2. 프로젝트 실행
→ $ gradle run 
→ $ java -classpath app/build/classes/java/main    Hello
패키지 폴더 실행
→ $ java -classpath app/build/classes/java/main   com.eomcs.App
→ $ gradle -i(information) 명령
→ 해당 폴더 이동 → ./app.bat → 배포한 파일 실행 
-------------------------------------------------------------------------------------
★ 3. 'java' gradle 플러그인 ★
$ gradle compileJava → 애플리케이션 소스 컴파일 
→ gradle은 java를 컴파일 할 능력이 없다
개발자 → 사용(컴파일러 사용법을 자세히 알아야 한다 예 : -d, -classpath) → Java 컴파일러 → 컴파일 수행
          → 사용(gradle의 빌드 스크립트 작성법을 알아야 한다) → Gradle → 사용 → Java 컴파일러
java-basic/ → app/ → src/ → main/ → java/ → 이 폴더에 있는 자바 소스를 컴파일
	  → app/ → build/ → classes/ → java/ → main/ → 이 폴더에 .class 파일을 둔다
-------------------------------------------------------------------------------------
$ gradle processResources → 실행할 때 사용한 설정파일을 build/resources/test 폴더에 복사
→ 단위 테스트 설정 파일 복사
java-basic/ → app/ → src/ → main/ → resources/ → 이 폴더에 있는 파일을 
	  → app/ → build/ → resources/ → main/ → 그대로 복사
-------------------------------------------------------------------------------------
$ gradle classes → application 실행할 수 있도록 컴파일
→ compileJava 실행 
→ processResources 실행
-------------------------------------------------------------------------------------
$ gradle compileTestJava → 단위 테스트 소스 컴파일
→ main과 test 폴더에 있는 파일 같이 컴파일
→ .class 파일도 main과 test 폴더에 둔다
java-basic/ → app/ → src/ → test/ → java/ 
		          → main/ → java/ → main과 test 폴더 안에 있는 파일들 같이 컴파일
	  → app/ → build/ → classes/ → java/ → test/ 
			    	  → main/ → java/ → main과 test 폴더 안에 .class 파일을 둔다
-------------------------------------------------------------------------------------
$ gradle processTestResources → 단위 테스트 설정 파일 복사
java-basic/ → app/ → src/ → test/, main/ → resources/ → 이 폴더에 있는 파일을 
	  → app/ → build/ → resources/ → test/, main/ → 그대로 복사
-------------------------------------------------------------------------------------
$ gradle testClasses → 단위 테스트 관련 파일을 컴파일
→ compileJava → processResoures → classes → compileTestJava → processTestResources → testClasses
-------------------------------------------------------------------------------------
$ gradle -i(information 모든 빌드 명령어에서 사용 가능) test → 단위 테스트를 실행한 후에 보고서 생성
→ build/reports/tests/보고서
→ compileJava → processResources → classes → compileTestJava → processTestRsources → testclasses → test
-------------------------------------------------------------------------------------
$ gradle jar → 애플리케이션 패킹(테스트 x, 패킹만)
build/libs/app.jar → *.jar파일 생성 → 확장자명을 *.zip로 바꾸고 압축 풀기
→ compileJava → processResources → classes → jar 
-------------------------------------------------------------------------------------
$ gradle build
test → 애플리케이션 컴파일 및 단위 테스트
jar → 배포 파일 생성
(distribution : 분포, 배포)
-------------------------------------------------------------------------------------
$ gradle clean → build 폴더 삭제
-------------------------------------------------------------------------------------
$gradle -i run → build 스크립트 파일에 지정된 메인 클래스 실행
→ compileJava → processResources → classes → run
-------------------------------------------------------------------------------------
★ java 언어
→ 리터럴(Literal), 변수(variables), 연산자(operator), 조건문(conditional, 분기문), 반복문(loop)
리터럴 → 데이터를 표기한 것
숫자 → 정수, 부동소수점(실수)
문자 → '가', 'A'
문자열 → "문자열입니다", "abcdef"
논리 → true, false
-------------------------------------------------------------------------------------
소스파일과 클래스 블록, .class 
→ 자바의 컴파일 기본단위는 클래스 블록이다 
→ 한 소스를 컴파일하면 클래스당 .class 파일 생성
→ 컴파일 기본단위는 소스파일이 아니다
C.java--------------------------------------
class C1 {}(클래스 블럭)	 C1.class
class C2 {}--------------------→ C2.class
class C3 {}		 C3.class
---------------------------------------------
-------------------------------------------------------------------------------------



2023.11.21(화)
-------------------------------------------------------------------------------------
① 소스 파일과 클래스 블록 .class파일
javac -d build/classes/java/main  /src/main/java/com/eomcs/D.java 
→ com/eomcs 폴더에 있는 자바 소스를 컴파일 했는데 com/eomcs 폴더가 아닌 main 폴더에 .class 파일이 있다
→ 특정 폴더에 소속된다고 지정하지 않아서 루트 폴더의 클래스로 간주

② ★ 패키지
package com.eomcs; 
$ javac -d build/classes/java/main  /src/main/java/com/eomcs/E.java
(/src/main/java 소스폴더)(/com/eomcs 패키지폴더)E.java
(build/classes/java/main 목적폴더)(/com/eomcs 패키지폴더)E1.class, E2.class 
★ $ java -classpath 목적폴더 패키지폴더.이름 → 패키지 폴더는 닷으로 구분
$ java   -classpath   build/classes/java/main   com.eomcs.E1
→ 클래스가 소속된 그룹이름
→ 디렉토리로 다룬다
→ 클래스를 역할에 따리 관리하기 위해서 → 정리정돈
→ 도서관에서 분류에 따라 서가를 분리하여 책을 정리해 두듯이
→ 소스를 관리하기 쉽게하기 위해 단순히 디렉토리로 분류하는 것은 소용없다 → 문법으로 명시해야 한다 → 패키지 문법
→ 컴파일할 때 목적 폴더 밑에 패키지 폴더가 없다면 자동으로 생성하고 패키지 폴더에 .class 파일 생성

③ 패키지 이름과 도메인 명
package com/eomcs; 
→ 보통 패키지 이름은 도메인 명을 사용한다 → 개발자 간, 회사 간에 이름 충돌 방지
→ 도메인 명을 꺼꾸로 사용 → 상위에서 하위로 분류하기 쉽게
/src/main/java/com/microsoft/
/src/main/java/com/facebook/
/src/main/java/com/oracle/
/src/main/java/org/apache/
패키지명 작성 관례
com.microsoft.office.msword
| 도메인명 |제품명(서비스명)| 하위 분류명(역할명) |

④ 패키지 private 클래스
java/com/eomcs/F.java → class F1{}, class F2{}
java/com/eomcs/Test.java → class Test{}
class F1{} → public으로 공개 전
class F2{}, class Test{} → 공개 여부에 상관없이 같은 패키지에 소속된경우 접근가능
패키지 멤버 클래스(패키지 클래스) → 패키지에 소속된 클래스
다른 클래스를 사용하는 소스 파일을 컴파일 하기
Test.java
class Test{
  F1 v1;  → 다른 클래스 사용
  F2 v2;  → 다른 클래스 사용
}
$ javac -d     목적폴더경로        -classpath        소스파일에서 사용하는 다른 클래스 경로(파일)         소스파일 경로
$ javac -d     build/classes/java/main     -classpath      build/classes/java/main      src/main/java/com/eomcs/Test.java
-------------------------------------------------------------------------------------
java/Test2.java 
class Test2{
  F1 v1;  → 다른 패키지에서 클래스 사용하려면 패키지명까지 적어야한다
  F2 v2;  → com.eomcs.F2 v2;로 변경 하지만 사용은 불가능
}
-------------------------------------------------------------------------------------
공개 클래스
public class는 소스파일에서 하나만 설정 가능
com/eomcs/G.java → 파일명을 G1.java로 변경
pubilc class G1{} → 공개 클래스는 유지보수할 때 소스파일을 찾기 쉽도록 하기 위해 반드시 소스파일명과 일치 시켜야 한다
★ class G2{} → 패키지 private 클래스
→ 만약 java/Test2.java에서 com.eomcs.G1 v3;은 사용가능
→ com.eomcs.G2는 사용불가능
일반 적인 경우 
→ 1개 소스파일 - 1개의 클로스 블록
→ 소스파일명 = 클래스 블록명 일치
→ 클래스가 정의된 소스 파일을 찾기 쉽다
→ 유지보수가 쉽다
-------------------------------------------------------------------------------------
main() 메서드 → 프로그램 entry point(진입점 = 입구)
$ java Hello
→ classpath에 지정된 경로에서 Hello.class 파일을 찾는다 
  → JDK 설치 폴더에서 찾기
  → -classpath에서 찾기
  → OS CLASSPATH에서 찾기
  → 현재폴더에서 찾기
→ .class 파일의 bytecode를 검증한다
→ main() 메서드 실행
-------------------------------------------------------------------------------------
20년간 진화해온 APP 아키텍처를 압축경험
1. myapp(standalone) → 변수 → 배열 → 조건문/반복문 → 메서드 → 컬렉션API → File I/O
2. myapp s/w → 네트워킹 API, File I/O 기능 분리 → 스레드 적용(멀티 프로세싱) → DBMS 적용+JDBC API
3. myapp AS → App 기능을 서버에서 실행 → IoC 컨테이너 적용(객체 생성 자동화)
4. myapp web AS → Mybatis 도입 → JSP 도입 → JSTL/EL 도입 → 프론트 컨트롤러 패턴 적용
5. myapp SpringFramework → Thymeleaf 뷰 템플릿 적용 → 임베디드 서블릿 컨테이너 도입
6. myapp SpringBoot → REST API + AJAX → SpringSecurity 적용
-------------------------------------------------------------------------------------
주석 사용법
① 일반 주석(comments)/javadoc comments/annotation
일반 주석
→ // 주석입니다 → 한줄 전체 주석
→ /* 주섭입니다 */ → 표시한 부분만 주석

② ★ javadoc comments
→ /** 주석입니다 */
/** 클래스 설명 */
class A{
  /** 변수 설명 */
  int a;			→ javadoc 실행 → API(HTML) → 개발자가 작성한 코드의 사용법을 설명한 문서
  
  /** 메서드 설명 */
  void main(){
  }
}
$ javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java com.eomcs.lang.ex02
javadoc 등장 전
개발자 → 1. 작성 → 소스파일(.java .c .cpp 등)
개발자 → 2. 작성 → API 문서(.doc .ppt .hwp .pdf 등)
→ 소스 코드를 바꾸면 API 문서도 그에 맞춰 변경해야 하지마 개발자들이 귀찮아서 안하는게 현실이다
→ 코드와 문서가 일치하지 않는 문제 발생
→ 해결 → 소스+문서 결합 → 문서 생성 자동화(javadoc 등)

③ annotation
소스 파일
/* 일반 주석*/ → 컴파일 과정에서 버린다
// 일반 주석

/** javadoc */ → javadoc에 의해서 HTML 파일에 삽입

@annotation → 컴파일 할 때 .class 파일에 포함 
→ 컴파일 할 때 사용/실행 할 때 사용/다른 문서를 생성할 때 사용
-------------------------------------------------------------------------------------
IDE(Integrated Development Environment 통합 개발 환경)
단순 에디터 -----------------------→ IDE → 개발의 전반적인 작업을 해당 도구를 사용해서 처리해줌 
IDE = 단순 에디터 + 컴파일, 실행, 디버깅, 테스팅, 패킹, 버전관리 등
→ JDK, git, 개발도구 사용 
→ 편집기, 위저드 기능의 자동화 도구(Eclipse IDE, IntelliJ, Netbeans 등)
VScode는 단순 에디터와 IDE에 중간
→ 플러그인을 사용한 반자동 IDE 도구
★ bin/main/소스파일 → 이클립스가 컴파일 한 클래스 파일들 
-------------------------------------------------------------------------------------



2023.11.22(수)
-------------------------------------------------------------------------------------
Gradle 자바 프로젝트를 Eclipse IDE로 import
gradle → 구성 → java-basic(root project) 
		→ app(main project) → import → Eclipse IDE
	                 |→ .settings/ → 프로젝트에 대한 더 상세한 설정
	                 |→ .classpath → 소스폴더, 컴파일한 목적폴더, 외부라이브러리 정보
	                 |→ .project → 프로젝트 설정파일(어떤 프로젝트인지 알아야 그에 맞는 에디터나 화면을 준비하기 위해서)
	                 |    → Eclipse IDE가 사용하는 설정파일
build.gradle(빌드 스크립트 파일) → $ gradle eclipse → .settings/ .classpath .project 생성
+ 'eclipse' 플러그인 장착
+ eclipse {-} 설정등록
$ gradle cleanEclipse → 이클립스 설정파일(.settings/ .classpath .project) 삭제
-------------------------------------------------------------------------------------
Eclipse VS ItelliJ
eclipse → 사용 → JDK → 빌드
빌드 → 사용 → 소스파일 개별 빌드 → 일부 소스에 오류가 있어도 실행 가능
IntelliJ → Gradle → JDK → 빌드
빌드 → 전체 소스 빌드 → 일부 소스에 오류가 있으면 실행 불가능
-------------------------------------------------------------------------------------
★실습★
1. 'test-app' Gradle 자바 프로젝트를 생성한 후 Eclipse IDE로 임포트하시오
git bash
$ mkdir test-app → $ cd test-app → $ gradle init(appication , java, groovy) → $ gradle eclipse 
eclipse
메뉴 → file → import → 경로 설정 → 열기
2. 'myapp' Gradle 자바 프로젝트를 생성한 후 Eclipse IDE로 임포트하시오
    → 패키지명 : bitcamp.myapp
3. 'myapp' 프로젝트 IntelliJ에서 열기
jdk 17버전 설치 및 환경변수 설정, 확인
→ PATH, JAVA_HOME 환경변수 설정 → $ echo $JAVA_HOME → $ java -version → $ javac -version → $ echo $PATH
→ build.gradle 파일에 버전 수정 → intellij에서 오픈 → 경로 설정
.idea → IntellJ에서 쓰는 설정파일, IntelliJ가 자동으로 생성
-------------------------------------------------------------------------------------
프로그램
data(성적) → software(데이터 가공) → information(순위, 표준편차, 분포도)
		     	         → data'(평균, 합계)
software(데이터 가공) → hardware → CPU(연산)
			        → RAM(data 보관)
DATA 보관 방법
① 종이 → 100 그리기(10진수 표기법)
173 → 1*100 + 7*10 + 3*1 (10진수)
100 → (0)144 → 1*64 + 4*8 + 4*1 (8진수)
100 → (0b)1100100 → 1*64 + 1*32 + 1*8 (2진수)
100 → (0x)64 → 6*16 + 4*1 (16진수) → 10진수 다음에 16진수를 컴퓨터에서 많이 쓰인다
10진수(100) → 16진수(64) → 2진수(144) → 8진수(1100100)

② 컴퓨터 → RAM(휘발성) or HDD, CD-ROM, SSD(조금씩 휘발성) 등
RAM은 전하(전기)를 보관한다 → 숫자, 문자, 색상, 문자열, 소리 등을 전기신호로 변환해서 저장한다
□■■□ → off on on off (비트)
HDD → 원판에 자석 가루에 저장
NS SN SN NS → off on on off → 자석방향으로 변환해서 저장한다(수직 기록 방식)
HDD Head가 쓰고 읽는다
숫자 → on/off로 변환해야 한다 → 표기하기 불편 → 더 간결한 표기법 0/1 2진수(1010111100)로 표기한다
→ 숫자를 2진수로 변환해서 RAM(전기신호), HDD(마그네틱 신호)에 저장할 수 있다
→ 2진수를 활용해서 Data를 표현
→ 2진수를 바꾸면 저장을 할 수 있어서 2진수로 변환하는 규칙이 있어야 한다

③ 숫자(정수) → 2진수 변환 규칙
1. sign-magnitude(부호 절대값)
1111 1111 ~ 0111 1111 (-127~+127)
→ 8비트가 기본, 맨 앞 비트가 +인지 -인지 결정
→ 0001(+1) + 1001(-1) 하면 1010(-2)가 나온다 
→ 인간의 연산 방식과 다르게 동작해서 컴퓨터 세계에서는 잘 안 쓰인다, 엉뚱한 결과를 교정 하려면 cpu에 추가적인 회로가 필요하다(cpu 설계가 복잡하다)
→ 장점으로는 이해하기 쉽다
-------------------------------------------------------------------------------------
2. 1의 보수(보충해주는 수)(1's complement)
→ 모든 비트를 반대 값으로 바꾼다
10의 보수
5 → 5  6 → 4  7 → 3  4 → 6
9의 보수
5 → 4  6 → 3  7 → 2  4 → 5
00011000(+24) → 1의 보수(00011000에서 더했을 때 1인 수) → 11100111
+4 + (-2) = 2 → 0100(+4) + 1101(-2) = 10001(4비트인 경우는 앞에 비트를 날린다) 0001(+1)
→ 즉, 결과에 1을 더해야 하는 작업이 필요하다
단점 극복 → 음수로 만들 때 미리 1을 더해둔다 → 2의 보수
-------------------------------------------------------------------------------------
★ 3. 2의 보수 → 자바에서 음수를 저장할 때 사용(일반적으로 사용) ★
→ 1의 보수를 만든 다음 1을 더한다
→ +2의 음수 → 0010 + 1101 +1 = 1110(-2)
→ 0100(+4) +1110(-2) = 0010(+2)
오른쪽에서부터 1을 찾는다, 찾은 1의 왼쪽평에 있는 모든 비트를 반대 값으로 바꾼다
→ 0010 100(1) → 1101 0111
2의 n승에서 음수 값 만큼 뺀다(8비트일 때)
→ -44 = 256 - 44 = 212 →1101 0100
-------------------------------------------------------------------------------------
4. K-초과
→ K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다
→ K = 2**(비트 수-1)
8비트일 경우 → K = 2**(8-1) = 2**7 = 128, 결과 = 128 + 값
→ 1111 1111 = 128+127 ~ 0000 0000 = 128+(-128)
-------------------------------------------------------------------------------------
5. IEEE 부동소수점
→ K = 2**(비트 수-1)-1 공식을 사용
8비트일 경우 → K = 2**(8-1)-1 = 2**7-1 = 127, 결과 = 127 + 값
→ 1111 1111 = 127 + 128 ~ 0000 0000 = 127 + (-127)
-------------------------------------------------------------------------------------
6. Excess-K(K 초과법)
→ K = 2**(비트 수-1)
8비트일 경우
→ 2**(8-1) → 2**7 → 128
→ 0 1 ~ 255 → -128 + (+128)      -127 + (+128) ~ 127 + 128
-------------------------------------------------------------------------------------
★ 7. 비트 크기와 저장할 수 있는 값의 범위
8bit → -128 ~ +127
16bit → -32768 ~ +326767
32bit → 약 -21억 ~ 약 21억
64bit → 약 -922경 ~ 약 922경
→ 메모리 기본 단위 → 8bit(1byte)
정수를 저장하는 메모리 크기 분류 
8bit(1byte) → byte
16bit(2byte) → short
32bit(4byte) → int
64bit(8byte) → long
자바에서 정수를 저장하는 메모리 크기에 대한 별칭 → byte, short, int, long
-------------------------------------------------------------------------------------
정수 →2의 보수 규칙에 의해 변환 → RAM, HDD저장
-------------------------------------------------------------------------------------
★ ④ 부동소수점(floating point) → 부동(float) (단정도) → IEEE-754 
→ 부동소수점을 얼마나 정밀하게 저장할 수 있느냐는 메모리 크기에 달려있다
정규화(소수점 없애기)
3.14
→ 31.4*10**1 → 31.4E-1
→ 314*10**2 → 314E-2
→ 0.314*10**1 → 0.314E1
→ 0.0314*10**2 → 0.0314E2
★ 부동소수점 정규화 → 왼쪽 1만 남기고 소수점을 이동한다 (K = 2**(비트 수-1) -1 사용)
소수점 변환 규칙
12.375 → 12 = 1100
0.375 2진수 → 소수 부분은 2를 계속 곱해서 일의 자리를 뺀 것이 1bit이다
0.375*2 = 0.75 → 0
0.75*2 = 1.5 → 1 
0.5*2 = 1 → 1
→ 1100.011
→ 1100.011 → 1.100011*2**3 → 맨 왼쪽은 무조건 1이기 때문에 버린다 → 0.100011*2**3
0□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□31
0 → 부호 → 양수면 0 음수면 1
1~8 → 지수부 → 3+(2**8-1) → 3 + (128-1) → 3 + 127 → 130 → 10000010 → Excess-k방식
9~31 → 가수부 → 소수점 오른쪽 수만 가수부에 저장, 나머지는 0을 채운다 → 10001100000000000000000 → sign-magnitude방식
1 8 23 bit
10진수 → 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16진수 → 0 1 2 3 4 5 6 7 8 9  a   b   c  d   e   f
2진수 4bit → 16진수 1bit → 간결하게 표현할 수 있다 → 간결한 표기, 변환용이, 그래서 16진수를 많이 사용한다
0x 0100 0001 0100 0110 0000 0000 0000 0000
0x   4     1       4      6      0      0      0      0 (32bit)
IEEE-754 부동소수점 (64bit) (double) (배정도)
→ float보다 2배 이상 더 정밀한 값을 보장 할 수 있다
부호 → 1bit 
지수부 → 11bit
가수부 → 52bit
-------------------------------------------------------------------------------------
★ 값을 입출력하는 크기
리터럴 데이터 → 4byte → 32bit → 0*32
정수
8bit(1byte) → byte
16bit(2byte) → short
32bit(4byte) → int 
64bit(8byte) → long
실수
float → 4byte → 32bit → 소수점을 빼고 7자리 이하면 98% 확률로 저장 가능 → 7자리 넘어가면 잘려서 저장될 수 있다
double → 8byte → 64bit → 16자리까지 저장 가능, 그 이후는 잘려서 저장된다
→ 시스템에서 필요한 만큼 소수점 이하 자리수를 적절히 짤라 사용하다
→ 37543.2741 → 375432741 → 9자리
-------------------------------------------------------------------------------------



2023.11.23(목)
-------------------------------------------------------------------------------------
★ RAM, HDD 등은 Byte(1Byte = 8bit) 단위로 읽고 쓴다 → 메모리 기본단위 = 입출력 기본단위
-------------------------------------------------------------------------------------
문자를 2진수로 변환하는 규칙(charser, 문자집합) → ASCII, ISO-8859-1, ECU-KR, 조합형, MS949, Unicode, UTF-8
-------------------------------------------------------------------------------------
자바에서 컴파일 하면서 encoding(변환하기)
$ javac -d bin/main -encoding UTF-8 src/main/java/com/ohoracs/basic/ex03/Exam35.java
① ASCII(American Standartd Code for Information Interchange)(7bit)
→ ASCII 코드는 인쇄 가능 문자 95자, 인쇄 불가능 문자 33자로 구성
인쇄 가능 문자 95자 → 알파벳 대소문자(영어), 숫자, 특수문자 등
A → 100 0001 (0x41)
B → 100 0010 (0x42)
......
a → 110 0001 (0x61)
b → 110 0010 (0x62)
c → 110 0011 (0x63)
.......
0 → 011 0000 (0x30)
1 → 011 0001 (0x31)
2 → 011 0010 (0x32)
.......
! → 010 0001 (0x21)
? → 011 1111 (0x3F)
# → 010 0011 (0x23)
& → 010 0110 (0x26)
+ → 010 10011 (0x2B)
space bar → 010 0000 (0x20)
......
인쇄 불가능 문자 33자
CR(Carriage Return) → 000 1110 (0x0D) → 커서를 그 줄에 맨 앞으로 옮기는 것
LF(Line Feed) → 000 1010 (0x0A) → 커서를 다음 줄(아랫 줄)로 옮기는 것
......
윈도우는 enter를 치면 LF와 CR을 입력
리눅스, 유닉스는 enter를 치면 CR만 입력

문자를 저장하는 원리
AB12 (Enter)
ab (Enter)
2진수로 변환
→ 41 42 31 32 0D 0A 61 62 0D 0A → 총 10byte로 변환한다
→ 키보드에서 Enter 키를 입력하면, 줄바꿈 코드값이 삽입된다

② ISO-8859-1(1, 2, 3, 4, 5, ..... = ISO-latin-1(1, 2, 3, 4, 5, ......) → 8bit = ASCII+유럽문자
A → 0100 0001 (0x41)

③ EUC-KR(= ISO-8859-1 + 한글문자) (16bit = 2byte) (국제표준) → 한글 문자에 대한 코드를 정의
A → 0x41
B → 0x42
......
가 → 0xB0A1
각 → 0xB0A2
간 → 0xB0A3
똘 → 0xB6CA
똠 → x (정의되어 있지 않다) → 또ㅁ → B6C7 A4B1
똡 → x (정의되어 있지 않다) → 또ㅂ → B6C7 A4B2
뜻 → 0xB6E6
똥 → 0xB6CB
방 → 0xB9E6
각 → 0xB0A2
하 → 0xC7CF
→ 한글 2350자 + 한자(한중일 공통 한자) + 한자(한국 전용 한자) + 등
→ 가각똠방각하AB → B0A1 B0A2 B6C7 A4B1 B9E6 B0A2 C7CF 41 42 → 가 각 또 ㅁ 방 각 하 A B

④ 조합형(16bit) = 1 + 초성(5bit, 32자)+중성(5bit, 32자)+종성(5bit, 32자) → 모든 한글 표현 가능(국제 표준이 아니다)
00000 → 없음
00001 → 채움 → 채움+ㅏ+채움 (15bit)
00010 → ㄱ     ㄱ
00011 → ㄲ ㅏ ㄲ
00100 → ㄴ ㅐ ㄳ
00101 → ㄷ ㅑ ㄴ
00110 → ㄸ ㅒ ㄵ
00111 → ㄹ ㅓ ㄶ
......
ㅏ → 1 00001 00011 00001(16bit) → 0x 8 4 6 1
깨 → 1 00011 00100 00001(16bit) → 0x 8 B 8 1
단 → 1 00101 00011 00101(16bit) → 0x 0 4 6 5
ㅏ깨단 → 0x84618B819465

⑤ MS949(CP949)(16bit) = EUC-KR + 나머지 한글 → 11172자 한글 지원 → 국제 표준이 아니다 ★저장을 하더라도 다른 운영체제에서는 읽을 수 없다★
가 → 0xB0A1
각 → 0xB0A2
......
똘 → 0xB6CA
뜸 → 0x8C63
똥 → 0xB6CB
→ EUC-KR
......
똡 → 0x8C64
똣 → 0x8C66
→ MS949에서 추가
.......

⑥ unicode (2byte~4byte) → 어떤 문자는 2byte, 어떤 문자는 4byte이다
→ 영어도 2byte 사용 → 메모리 낭비 → 메모리 낭비를 줄이기 위해서 UTF-8 등장
A → 0x0041
B → 0x0042
C → 0x0043
......
가 → 0xAC00
각 → 0xAC01
간 → 0xAC04
......
똘 → 0xB618
똠 → 0xB620
똡 → 0xB621
똣 → 0xB623
똥 → 0xB625
......
→ 새로 정의 했기 때문에 한글은 순서대로 코드값이 부여됨 11172자+@
→ unicode를 읽으려면 전용 에디터가 필요하다
→ Java는 문자를 다룰 때 unicode(UCS2 = UTF-16BE)를 사용한다

LE vs ★BE
가 → 00AC     AC00
A → 4100      0041
→ 코드가 뒤집힌다

⑦ UTF-8 (Universal Coded Character Set Transformation Format -8) → 전 세계 공통으로 토드화되 글자(캐릭터)의 집합, 변형, 포맷
unicode(UTF-16 BE) → 변형 → UTF-8
A → 0x0041 → 0x41
000000~00007F(3byte)  
→ 0000 0000 0000 0000 0000 0000 ~ 0000 0000 0000 0000  0100 0001 
→ 뒤에 7자리만 갖고 온다 → 0xxx xxxx → 0100 0001 → 결국 기존의 ASCII와 동일해졌다
000080~0007FF(3byte)
→ 0000 0000 0000 0000 1000 0000 ~ 0000 0000 0000 0111 1111 1111
→ 뒤에 11자리 갖고 온다 → 0000 0xxx xxxx xxxx → 110x xxxx 10xx xxxx → 110으로 시작하고 나머지 바이트들은 10으로 시작한다
→ 예 : 0000 0100 1010 1100 → 110 10010 10 101100
000800~00FFFF(3byte)
→ 뒤에 16자리 갖고 온다 → xxxx xxxx xxxx xxxx → 1110 xxxx 10xx xxxx 10xx xxxx → 1110으로 시작하고 나머지 바이트들은 10으로 시작한다
→ 예 : 0xAC00(가) → 1010 1100 0000 0000 → 1110 1010 10 110000 10 000000
-------------------------------------------------------------------------------------
논리값 
→ 4byte int 메모리에 저장
→ 배열 값인 경우 1byte 메모리에 저장
→ ture = 1, false = 0 값으로 저장 
→ 집점 정수 값을 지정해서는 안된다
-------------------------------------------------------------------------------------
★ 리터럴(Literal)
① 정수 literal
32bit → 4byte → int
→ 100 → 0x 0000 0064
64bit → 8byte → long
→ 100L, 100l(엘) → 0x 0000 0000 0000 0064

② 부동소수점 literal
32bit → 4byte → float
→ 3.14 → 3.14f, 3.14F
64bit → 8byte → double
→ 3.14 → 3.14, 3.14d, 3.14D

③ 문자 literal
★ 'A' → single quatation → 연산자 = 주어진 문자의 unicode(UCS2 = UTF-16BE (2byte)) 값을 리턴한다
→ 0x0041을 리턴
'가' → 0xAC00을 리턴
-------------------------------------------------------------------------------------
이미지 표현 방식
raster(bitmap)
→ 픽셀 단위로 나누고 픽셀을 색을 칠한다 
→ 확대하면 계단 현상 이미지가 깨진다 
→ 장점은 화면에 빠르게 나타난다, 단순한 그림이나 복잡한 그림이나 파일 크기가 같다 → 각 점을 3byte로 표현하기 때문
vector(truetype) 
→ 수학적인 공식으로 점과 점을 연결해서 선을 표현한다 면은 색상 값을 가진다 
→ 확대해도 이미지가 깨지지 않는다 
→ 정교한 작업 요구, 그릴 때 마다 명령어를 실행해야 하기 때문에 출력 속도가 느리다, 파일의 크기가 커진다
-------------------------------------------------------------------------------------
이스케이프 문자(escape character) = 문자 제어 코드
→ 화면에 출력하는 문자가 아니라 문자 출력을 제어하는 문자이다.
제어 문자
\n - Line Feed(LF), 0x0a → 줄 바꿈
\r - Carrage Return(CR), 0x0d 
→ 커서를 처음으로 돌리고 문자를 덮어쓴다
→ jshell> System.out.println("abcd\r123"); → 123d 출력
\f - Form Feed, 0x0c → 줄 바꿈해서 열을 유지한다(행+1열@)
→ abc\f
        def
\t - Tab, 0x09 → tab을 해준다 탭 크기만큼
\b - Backspace, 0x08 → 커서를 뒤로 움직인다
\' - Single Quote, 0x27 → ' 출력
\" - Double Quote, 0x22 → " 출력
\\ - Backslash, 0x5c → \ 출력
-------------------------------------------------------------------------------------
ASCII 1byte(7bit) → ISO-8859-1 1byte → ECU-KR 2byte → 조합형 2byte → MS949 2byte → unicode(UTF-16BE) 2~4byte → UTF-8 3byte
-------------------------------------------------------------------------------------



2023.11.24(금)
-------------------------------------------------------------------------------------
과제
콘솔에서 글씨 색깔, 볼드체 바꾸기
System.out.println("\u001b[30m"~"\u001b[47m" + "print" + "\u001b[0m")
System.out.println("\u001b[31m\u001b[1m[과제관리 시스템]\u001b[0m");
\u001b = \033
\033[0;31m(일반, 레드) \033[1;31m(볼드, 레드)
-------------------------------------------------------------------------------------
★ ANSI escape code
Color Name	Color code	Background Color	Background Color code
BLACK	\u001B[30m	BLACK_BACKGROUND	\u001B[40m
RED	\u001B[31m	RED_BACKGROUND	\u001B[41m
GREEN	\u001B[32m	GREEN_BACKGROUND	\u001B[42m
YELLOW	\u001B[33m	YELLOW_BACKGROUND	\u001B[43m
BLUE	\u001B[34m	BLUE_BACKGROUND	\u001B[44m
PURPLE	\u001B[35m	PURPLE_BACKGROUND	\u001B[45m
CYAN	\u001B[36m	CYAN_BACKGROUND	\u001B[46m
WHITE	\u001B[37m	WHITE_BACKGROUND	\u001B[47m

ANSI CODE 내용 → \u001B[1~7m
 0 Normal Characters
 1 Bold Characters
 4 UnderLined Characters
 5 Blinking Characters
 7 Reverse Video Characters
-------------------------------------------------------------------------------------
변수(variables) → 값을 담을 메모리
변수 선언 → 값을 담을 메모리를 준비시키는 명령문 → JVM이 관리하는 메모리에서 일부 메모리를 데이터를 저장 할 용도로 표시
→ 만들메모리종류(데이터 타입) 메모리이름(베리어블); → int a; → int a=10;
-------------------------------------------------------------------------------------
자바 기본 데이터 타입 → primitive data type
정수 → byte(1)128, short(2)32768, int(4)약21억, long(8)약922경
실수(부동소수점) → float(4)7자리, double(8)15자리
논리 → boolean(int를 가리킴, 배열이면 byte) 1/0
문자 → char(2) 0~65535유니코드(UTF-16, UCS2)
-------------------------------------------------------------------------------------
JVM과 메모리
모든 메모리는 OS가 관리 → 메모리를 사용하려면 OS에게 요청해야 한다
JVM(프로그램) 실행 → OS가 JVM이 사용할 메모리를 제공(자원 제공) → OS가 제공한 메모리 사용 → JVM 종료하면 JVM이 사용하던 메모리를 모두 회수(자원 회수)
프로그램 실행 → 프로세스process(실행중인 프로그램)
-------------------------------------------------------------------------------------
변수선언과 메모리 관계
int a; → 4byte 정수
char c; → 2byte unicode
int a, b, c;
JVM이 할당 받은 메모리에서 각 크기에 해당하는 메모리를 할당
-------------------------------------------------------------------------------------
변수에 값 저장하기
★ 변수 선언에서 '='은 assignment, 배정, 할당연산자
byte a;
a = -72;
-72 변환 후 저장 → 0100 1000 → 1011 1000 → ■□■■ ■□□□ 
char c;
c = '가'; 
0xAC00 변환 후 저장 → 1010 1100 0000 0000 → ■□■□ ■■□□ □□□□ □□□□
변수 초기화 문장(variables initializer)
int a = 100;  
     a = 100; → 초기화 문장
int x=20, y, z=10; → 가능
-------------------------------------------------------------------------------------
문자열 → 크기는 JVM에 따라 다르다, 메모리의 시작주소를 저장 → 레퍼런스(reference)
String s;
s="ABC"; → 6byte
unicode 변환 
→ 0041 0042 0043 → 00 41 00 42 00 43(6byte) 3글자(4byte) .....(문자열에 대한 부가정보)등 저장 
→ 전체 크기 알 수 없다(신경 안 써도됨)
문자열을 저장하고 있는 메모리 → String instance(인스턴스)
-------------------------------------------------------------------------------------
변수명
일반 변수 → camel(낙타) 표기법 → firstName → 첫번째 알파벳은 소문자, 각 단어의 시작은 대문자
상수(constants) → 변수에 값을 한번만 저장 할 수 있다(보통 대문자) → final int PI = 3.14f; → final int FIRST_NAME; → 단어와 단어 사이는 밑줄(underline)삽입
→ 변수명 자체가 뭘 의미 하는지 알 수 있다
-------------------------------------------------------------------------------------
변수 사용
String ANSI_RED = "\033[0;31";
String appTitle = "[과제관리 시스템]";
String munu1 = "1. 과제";
int a = 100;
System.out.println(100); → 직접 리터럴을 전달 할 수 있다
System.out.println(a); → 변수 a가 전달되는 것이 아니라 변수 a에 들어있는 값이 절단된다 
메소드 → 특정한 기능을 수행하는 도구
-------------------------------------------------------------------------------------
배열 → 같은 유형 메모리를 여러개 만드는 문법
자바 방식 → 데이터타입[] 레퍼런스 = new 데이터타입[변수개수];
classic 방식(c 방식) → 데이터타입 레퍼런스[] = new 데이터타입[변수개수];
→ int[] arr = new int[3]; → int 메모리를 연속해서 준비시킨다(자동 초기화)
 → 배열 메모리의 시작 바이트 주소를 저장하는 변수 → int 배열 reference
배열 메모리 → int 배열 instance
-------------------------------------------------------------------------------------
배열에 값 저장하기
int arr[] = new int[3];
arr1[1] = 271;
arr1[-1] = 100; → 인덱스 범위를 벗어나면 실행할 때 오류 발생 → out of index(RuntimeException) → 컴파일은 되지만 실행할 때 오류 발생
-------------------------------------------------------------------------------------
인스턴스와 가비지(garbage), 가비지 콜렉터(garbage collector)
int[] a = new int[3];  300번지 → 주소를 잃어버려 사용하지 못하는 인스턴스 → garbage →garbage collector가 해제하기 전까지는계속 garbage 상태로 존재한다 → 메모리 낭비
int[] a = new int[2];  400번지
a[1] = 100;  404번지에 저장
garbage collector 실행 
→ 메모리가 부족해지면 JVM OS에 메모리를 추가로 요청하기 전에 garbage collector를 통해 garbage를 메모리에서 제거하여 사용할 메모리를 확보한다
-------------------------------------------------------------------------------------



2023.11.27(월)
-------------------------------------------------------------------------------------
static type binding vs dynamic type binding
static type binding(정적 바인딩)
→ 변수의 타입이 고정된다
java
int a;
a = 100; → o
a = '가'; → 0xac00 → o
a = 3.14f; → x
a = 3.14; → x
a = true; → x
dynamn type binding(동적 바인딩)
→ 값을 할당할 때 변수의 타입이 결정된다 → 변수의 타입이 변동
javascript
var a;
a = 100; → number 타입 
a = 'aaa'; → string 타입
a = true → blooean 타입

명시적 형변환(explicit type conversion = explicit type casting)
→ 컴파일러에게 강제로 값을 넣을 것을 명령하는 것
-------------------------------------------------------------------------------------
만약 메모리의 크기를 벗어나는 큰 수의 값을 넣으려 한다면
→ 뒤의 바이트를 저장한다
short temp = 200; 
200(int) → 00000000 00000000 00000000 11001000
b2 = (byte)temp; → temp → 11001000(-56)
System.out.println(b2); → -56출력
-------------------------------------------------------------------------------------
★ 로컬 변수와 클래스 변수 사용
int a;
static int b;
-------------------------------------------------------------------------------------
MyClass obj1 = new MyClass();
System.out.println(obj1.a);
System.out.println(MyClass.b);
-------------------------------------------------------------------------------------
산술 연산자 주의사항
byte x=10. y=20. z;
z = x+y; → x
z = 10+20; → o
→ 리터럴 값인 경우 메모리에 넣을 수 있다면 허용한다
→ byte, short 변수의 연산은 무조건 int 단위로 이뤄진다
→ byte, short 변수는 연산을 수행하기 전에 int 메모리에 값을 저장한 후 연산수행!
→ 기본 연산 단위가 int이다
→ byte 연산 byte → int
→ short 연산 short →  int
→ int 연산 int → int
→ long 연산 long → long
→ float 연산 float → float
→ double 연산 double → double
int x=21억;
int y=21억;
int z=x+y; → int 범위 밖(오버플로우)값이 다르게 나온다
long r = x+y; → (x+y)를 연산해도 int형이기 때문에 값은 int z랑 같다
→ 연산 하기 전에 변환해서 연산을 해야한다
→ (long)x x타입을 long으로 바꾸라는 뜻이 아니다
→ x 변수에 들어있는 값을 long 임시 변수를 만들어 저장하라는 뜻이다 
-------------------------------------------------------------------------------------
암시적 형변환 → byte, short, char → int → long → float → double
→ 타입이 다르면 연산 불가 그래서 자동으로 타입을 같게 하는 것
-------------------------------------------------------------------------------------
부동소수점 비교
System.out.println((d1 + d2) == (x + y)); → 이렇게 하지 말 것
-------------------------------------------------------------------------------------
double EPSILON = 0.00001;
★ System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON); → 비교할 두 실수를 빼서 절댓값을 구한 뒤 개발자가 정해둔 범위보다 작으면 무시하자 ★
-------------------------------------------------------------------------------------
관계연산자
boolean a = false;
boolean b = false;
boolean r = a && (b=true); → b=true → a&&b
boolean r = a && (b=true);
첫 번째 피연산자 만으로 결과가 확정되기 때문에 두번째 문장을 실행하지 않는다 따라서 b는 여전히 false이다
boolean r = a & (b=true); → b=true → a&b
boolean r = a & (b=true); 
첫 번째 피연산자로 결과를 알 수 있다하더라도 뒤의 문장 끝까지 실행한다
-------------------------------------------------------------------------------------
LED vs OLED
LED → 빛을 쏘개되면 해당하는 색상을 보여준다(빛의 밝기로 조절) → 빛의 세기가 한번 통과되기 때문에 조금 어둡다
OLED → 화면 자체에서 빛을 발산한다 → 빛의 조금 밝다 → 오래 발산하면 열이 나고, 갈변된다
→ 지금은 기술이 극대화 돼서 비슷비슷하다
RGB = 8bit, 8bit, 8bit = 24bit = 3byte = 1pixel → 빛의 세기를 메모리에 저장
빛 RGB 검정색0~255희색
색 RYB 흰색0~255검정색
해상도 : 1920*1080(pixel 개수) → 가로*세로 → 2073600 → 약 200만 → 200만 화소
2073600 * 3 = 6220800 약 6.2MB
해상도 : 1200만 화소 * 3 = 3600만 byte = 약36MB → BITMAP(.bmp) 압축 → GIF, PNG(무손실 압축, 100% 원본 복구가능) , JPEG(손실 압축, 원본 복구 불가능)
동영상 → 1초당 화면 저장 → 24장 프레임 (영화), 약 30장 프레임 (TV)
HD급(1920*1080) → 6MB*24 = 144MB/초 → 144MB*60 = 8.6GB/1분 → 8.6GB*80 = 691GB/1영화 → MPEG(.mp4 압축)
-------------------------------------------------------------------------------------
   10110001
& 00111000
= 00110000
masking → AND 비트 연산자를 사용하여 특정 값을 차단할 수 있다
        R               G              B
   10110101  00010010   11111100
|  00000000  11001100   00000000
= 10110101  11011110   11111100
초록색 강화 → 원래 비트 값보다 더 큰 수로 변경되었다
-------------------------------------------------------------------------------------
% 연산은 빼기 연산을 여러 번 수행한다 그에 비해 & 비트 연산은 한번만 수행한다
54 % 1 → 54 & 0b1, 54 & 0x1
   00110110
& 00000001
= 00000000 (0) → 비트 연산 1번 수행 → 단 비트 연산을 활용할 경우, 2**n으로 나눌 때만 가능하다 → 2**n으로 나눈 나머지를 구할 때!
54 % 5 → & 연산 불가능
54 % 4 → & 연산 가능 54 & 0b0011
54 % 8 → & 연산 가능 54 & 0b0111
-------------------------------------------------------------------------------------
★ 연산자를 이용하여 짝수/홀수 알아내기 ★
System.out.println(57 % 2 == 0 ? "짝수" : "홀수");
System.out.println((57 & 0x1) == 0 ? "짝수" : "홀수");
(a == b ? c : d); → a와 b를 비교해서 참이면 c, 거짓이면 d를 실행
-------------------------------------------------------------------------------------
특정 위치의 비트 값만 추출학 싶을 때 사용한다
int data = 0b1111_1001_0111_1111;
System.out.println(Integer.toBinaryString(data & 0b0000_1111_1100_0000));
출력 → 100101000000 → 앞에 0은 버리고 출력한다
-------------------------------------------------------------------------------------
비트 이동 연산자
왼쪽 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.(양수일 경우) → 음수를 비트 이동 했다면 부호 비트까지 옮겨서 양수가 될 수도 있다
i = 11; // [00000000000000000000000000001011]
System.out.println(i << 1); //   0[00000000000000000000000000010110] → 22
System.out.println(i << 2); //  00[00000000000000000000000000101100] → 44
System.out.println(i << 3); // 000[00000000000000000000000001011000] → 88
int 타입 비트 이동 → 0~31까지 유효(n%32)
long 타입 비트 이동 → 0~63까지 유효(n%64)
3 << 33, 65, 97 → 3 << 1 같다
3 << 35
→ 31보다 큰 비트를 이동해야 한다면 32로 나눠서 나머지 값만큼 이동한다(n%32)
→ 3 << (35 % 32) → 3 << 3 → 3 * 2**3 → 24
→ 3 << (35 & 데이터타입비트-1) → 3 << (35 & 31) → 100011 & 011111 = 000011 → 3 << 3 → 3 * 2**3 → 24
→ 그냥 곱하기 보다 빠르다(value * 2**n 할 때)
-------------------------------------------------------------------------------------
오른쪽 비트 이동
105 >> 1
105 → 0000000000000001101001 → [ 000000000000000000110100]1
→ 왼쪽에 부호 비트를 붙인다 양수면 0, 음수면 1
→ value >> n → value / 2**n
→ value >> 1 → valsue / 2**1
→ value >> 2 → valsue / 2**2
→ value >> 3 → valsue / 2**3
→ 나눗셈 연산을 수행하는 것보다 실행속도가 빠르다 단 2**n으로 나눌 때만! → 소수점이 있을 경우 그 수보다 바로 밑 정수 값이 결과이다

>>> 이동
오른쪽으로 비트를 이동시킨 후 음수, 양수 상관없이 0을 채운다
int i = -87; // [11111111111111111111111110101001]
System.out.println(i >>> 1);
[ 1111111111111111111111111010100]1
[01111111111111111111111111010100]1     →      2147483604
-------------------------------------------------------------------------------------
비트 이동 연산으로 값 추출
int i = 0x27a130ff;
[00100111_10100001_00110000_11111111] → 27a130ff
담을 변수 = i >> 24 or 16, 8&0xff;
00000000_00100111_10100001_00110000  → 0x0027a130
& 00000000_00000000_00000000_11111111  → 0x00000	
--------------------------------------
00000000_00000000_00000000_00110000
-------------------------------------------------------------------------------------
메모리 절약
lang2 = lang2 | 0x80 → 비트 연산자를 이용해서 적은 메모리를 더 많은 true/false를 저장 할 수 있다
touch Hello.txt
chmod 755 Hello.txt
final int CSS           = 0x01; // 0000 0001
final int HTML          = 0x02; // 0000 0010
final int PHP           = 0x04; // 0000 0100
final int PYTHON        = 0x08; // 0000 1000
final int JAVASCRIPT    = 0x10; // 0001 0000
final int JAVA          = 0x20; // 0010 0000
final int CPP           = 0x40; // 0100 0000
final int C             = 0x80; // 1000 0000
-------------------------------------------------------------------------------------
★ 문자열을 숫자로 변환
String s = '12345';
int a = Integer.valueOf(s);
int b = Integer.parselnt(s);
-------------------------------------------------------------------------------------



2023.11.28(화)
-------------------------------------------------------------------------------------
조건 연산자
변수 = 조건 ? 표현식1 : 표현식2
조건이 참이면 표현식1, 거짓이면 표현식2 리턴
→ 표현식은 반드시 값을 리턴해야 한다
statement → expression(값을 리턴하는 statement) → 표현식
statement는 expression을 포함하고 있다
statement
200 → expression(o)
"Hello" → expression(o)
true → expression(o)
System.out.println("Hi"); → expression(x)
Math.abs(-200); → expression(o)
3*2 → expression(o)
if(){} → expression(x)
-------------------------------------------------------------------------------------
test()라는 명령블록(함수, 메소드)에 전달하는 값을 아규먼트(argument)
전달받은 값을 담는 변수 파라미터(parameter)
-------------------------------------------------------------------------------------
증감 연산자 → ++, --
전위 연산자(prefix operator) → ++변수, --변수
후위 연산자(postfix poerator) → 변수++, 변수--
int a = 100;
++a; → a = a + 1 → 101
++a; → a = a + 1 → 102
--a; → a = a - 1 → 101
--a; → a = a - 1 → 100
-------------------------------------------------------------------------------------
후위 연산자
int a = 100;
→ int temp(임시 변수) = a; → a = a + 1 → b = temp → b = 100, a = 101
b = a; → a = a + 1
→ 항상 r-value를 먼저 실행한 후에 할당(=) 연산을 수행한다
int a = 100;
a++;
★ 추측 1 → 항상 r-value를 먼저 실행한다
→ int temp = a; → a = a + 1 → a = temp → 100
추측 2
a = a → a = a + 1 → 101
++a++ → a = a + 1 → 101++ → 값에 대해 ++ 연산을 사용할 수 없다
-------------------------------------------------------------------------------------
흐름 제어문
조건문(if, if~else, if~else if~else, switch~case~default), 반복문(while, do~while, for), 흐름제어문(continue, break)
조건문
if~else → if문은 if와 else만 있다 
→ if~else if~else 이렇게 보이기만 할 뿐이다
switch~case~default 
→ switch(byte, short, int, char, 문자열, Enum만 가능) 
→ case(리터럴 값만 가능하다, 변수 불가능, fianl a 상수는 가능) 
→ break를 안 해주면 밑에 있는 case문까지 실행 되기 때문에 적절히 사용해야 한다
enum Level {
    GUEST, MEMBER, ADMIN
}
Level level = Level.MEMBER;           → enum 변수에는 그 타입에 정의된 값만 저장할 수 있다 → 안전한 코드 작성 가능
-------------------------------------------------------------------------------------
반복문
while(조건, true) {} → 조건이 참이면 계속 반복한다, 무한반복 하고 싶으면 true를 넣으면 된다
break → 자신이 소속된 가장 가까운 반복문을 나간다
continue → 다음 문장을 실행하지 않고 즉시 조건 검사로 이동한다
-------------------------------------------------------------------------------------
myloop: 반복문
myloop: 반복문1{반복문2{}}
break myloop; → myloop 라벨에 소속된 문장을 나간다
-------------------------------------------------------------------------------------
do~while → 최소 한 번은 실행하고 다음에 조건을 확인하여 반복을 계속할지 결정하는 반복문이다
do{ 
  문장;
}while(조건, true);

for(초기화; 조건; 증감){
  반복 실행 코드
}
for(int i = 0 ; ; ){
}
→ for 문 안에 선언된 변수는 for 문을 나가는 순간 제거된다
-------------------------------------------------------------------------------------
리스트
ArrayList<String> list = new ArrayList<>();
-------------------------------------------------------------------------------------
키보드 입력 다루기 
① read() 사용 → data를 읽을 때 사용하는 도구(메소드 = 수단, 방법)
레퍼런스.read()
레퍼런스 → 정보를 담고 있는 메모리의 주소
정보 → data를 어디에서 읽어야 하는지에 대한 정보 → read()가 작업할 때 필요한 정보를 갖고 있는 메모리 → 인스턴스(Instence) → 객체(object)
-------------------------------------------------------------------------------------
입력값 받기
Scanner keyScan = new Scanner(System.in);
System.out.print("나이를 입력하세요? ");
int age = keyScan.nextInt();
char c = keyScan.nextLine();
keyScan.close();
-------------------------------------------------------------------------------------
★ 배열로 5명의 이름을 연속적으로 입력받기
String[] names = new String[5];
Scanner nameScan = new Scanner(System.in);
for (int i = 0; i < 5; i++) {
	System.out.println("5명의 이름을 적어주세요");
	names[i] = nameScan.nextLine();
      	// System.out.println("입력된 이름 : " + names[i]);
    }
for (String s : names) {
      	System.out.println("입력된 이름 : " + s);
    }
nameScan.close();
-------------------------------------------------------------------------------------
★ 메소드와 레퍼런스(= 객체 = 인스턴스)
System.out.println("Hello");
println("Hello") → println = 연산자(method) = message, "Hello" = 피연산자(argument) = parameter → 실제 작업을 수행하는 명령 = 메소드 = 메시지 = 특별한 연산자
System.out → 피연산자(argument) → JVM 기본 출력 장치의 정보가 들어있는 메모리의 주소 → 터미널(terminal)
→ println()이 정보(System.out)를 사용해서 출력할 대상을 결정한다
-------------------------------------------------------------------------------------
★ Hello를 파일에 출력하기
OutputStream output = new FileoutputStream("test.txt");
PrintStream output2 = new PrintStream(output);
output2.pintln("Hello");
---------------------------------------------------------------------
PrintStream output2 = System.out;
output2.println("Hello");
---------------------------------------------------------------------
output2.close();
---------------------------------------------------------------------
밥 a = new 밥(쌀);
밥그릇 b = new 밥그릇(a);
b.먹자("달걀");
-------------------------------------------------------------------------------------
★ 입력 받기
java.io.InputStream keyboard = System.in;
java.util.Scanner keyboardScanner = new java.util.Scanner(keyboard);
→ java.util.Scanner keyboardScanner = new java.util.Scanner(System.in);

System.out.print("이름? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("전화? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("이메일? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("나이? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("재직여부? ");
System.out.println(keyboardScanner.nextLine());
keyboardScanner.close();
-------------------------------------------------------------------------------------
nextLine(), nextInt(), nextBoolean()
String name = keyboardScanner.next(); → 한 개의 토큰을 읽을 때 유용하다.
-------------------------------------------------------------------------------------



2023.11.29(수)
-------------------------------------------------------------------------------------
스트림(stream) → 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름
System.in → 표준 입력 장치의 정보가 저장된 메모리의 주소를 보관하고 있는 레퍼런스
주소 → 메모리(표준입력장치 정보(스트림 입구), keyboard 등) → 프로그램 외부에서 데이터가 들어올 수 있는 기본 입구
표준입력, 출력스트림(흐름)
$ wc(enter) → aaa bbb ccc(사용자가 키보드로 입력한다) → 전달 → wc프로그램 → 표준입력장치에 출력
다른 프로그램의 출력
$ cat Hello.c |(pipeline) wc(enter) → cat프로스램이 Hello.c파일 읽어서 전달(표준출력장치) → wc프로그램 → 표준입력장치에 출력
모든 프로그램                        ┌→ 표준오류스트림(System.err) → 오류가 발생했을 때 오류 정보를 내보낼 때 사용하는 특별한 출구
★ 다른 프로그램의 출력스트림과 연결, 키보드로 입력 
→ 표준입력스트림(system.in)(프로그램 외부에서 데이터가 들어올 수 있는 기본 입구) 
→ 프로그램 
→ 표준출력스트림(System.out)(프로그램 실행결과를 외부로 내보낼 수 있는 기본 출구)
→ 터미널 연결, 다른 프로그램의 표준입력스트림과 연결, 파일과 연결
데이터 입력 → 표준입력스트림 → 프로그램 → 표준출력스트림
                          ┌→ 오류스트림
표준입력스트림 → 프로그램 → 표준출력스트림
	             ↑   ↕ 
	    	↓  ★ networt 외부 네트워크로 데이터를 주고 받기 위해 입/출구를 뚫는 것 = 소켓(socket)
	★ 외부파일로 데이터를 읽고/쓰기 위해 입/출구를 뚫는 것 = File I/O스트림
System.in → 수행할 수 있는 명령 read(), read(byte[]) → 한 줄 단위로 입력된 문자열을 읽는 작업을 수행시킬 명령은 없다
→ new Scanner(System.in) → 표준입력스트림을 좀 더 정교하게 제어하려면 추가 데이터와 도구(메소드)가 필요하다
Scanner
Scanner + 추가도구 → System.in → nextLine(), nextInt(), next() → 한 줄을 읽는다
★ 메소드 실행(호출)
Scanner keyIn = new Scanner(System.in);
keyIn.nextLine();
keyIn → 레퍼런스 = 정보가 들어있는 메모리의 주소 → Scanner 정보 = Scanner 객체 
→ keyIn 변수에 Scanner 정보가 들어있는 것은 아니지만 정보가 들어있는 변수로 간주하여 표현
→ 의사소통을 단순하게, 이해를 쉽게
nextLine() → 레퍼런스에 적혀있는 주소로 찾아가서 그 메모리의 저장된 정보를 이용하여 작업을 수행한다
틀린 표현 → "keyIn(scanner reference) 객체에 대해 nextLine()을 호출"
맞는 표현 → nextLine() 메소드를 실행하려면 scanner 정보(객체)(scanner instance)를 이용하여 실행
★ scanner 객체에 nextInt() 메소드 호출
-------------------------------------------------------------------------------------
nextInt(), nextLine(), ....
나이? 30(enter)
nextInt() → 30까지 읽고 30(int)를 리턴 → nextLine() → 30 다음에 (enter)를 읽어서 빈문자열""을 출력
-------------------------------------------------------------------------------------
★ 키보드로 입력받는 메소드 연습
java.io.InputStream in = System.in;
java.util.Scanner numScan = new Scanner(in);
int num = numScan.nextInt();
문자열=="abc"  ===>  if (num.equals("abc"));
-------------------------------------------------------------------------------------
★ 메소드(method) = 함수(function)
리턴값의타입 기능이름(값을 받을 변수 선언){
    명령문
}
int plus(int a, int b){
    int result;
    result = a + b;
    return result;
}
static void printMenu(){
}
-------------------------------------------------------------------------------------
★ 메소드 활용
main() → main()과 printMenu() 기능을 분리 → main()에서 printMenu()를 호출 → printMenu()에서 출력
printMenu() → 메뉴 목록 배열, ansi 명령, app 제목 → 공통 변수로 분리 
prompte(Scanner numS
-------------------------------------------------------------------------------------
로컬 변수와 클래스 변수(static 변수)
class App{
	static int a; → 클래스 변수(필드) = static field
	void main(){
		int b; → 로컬 변수(local variable) 메소드 안에 선언된 변수, 메소드 실행될 때 생성되고 메소드의 실행이 끝나면 제거된다
	}
}

★ $ wc (enter) → abc def (enter) → 줄, 공백, 공백+단어개수 출력 
$ cat test.ok | wc → 파일에 대한 개수를 wc를 연결해서 출력
-------------------------------------------------------------------------------------



2023.11.30(목)
-------------------------------------------------------------------------------------
메소드 구조
int plus (int a, int b)  → method signature → a, b = parameter → 맨 앞 int = return type
{                 
	int r = a + b  → method body
	return r;
}

method argument와 parameter
void hello(String name, int age){ → nema, age → 아규먼트를 받는 로컬 변수 파라미터(parameter)
	System.out.printf("이름은 %s이고, 나이는 %d입니다.", name, age);	
}
hello("홍길동", 20); → "홍길동", 20 → 메소드에 넘겨주는 값 아규먼트(argument)
-------------------------------------------------------------------------------------
가변 파라미터와 배열 파라미터
가변 파라미터
여러 개의 가변 파라미터로 메소드를 호출할 때는 아규먼트를 배열로 만들어서 전달하고 사용한다
m2("김성모", "김성모", "김성모");
★ static void m2(itn a, String... names){} → 가변 파라미터는 무조건 맨 뒤에 와야한다 → 복잡한 사용을 막기 위해 맨 뒤에 둔다
배열 파라미터
가변 파라미터와 달리 낱개의 값을 여러 개 줄 수 없다, 오직 배열에 담아서 전달해야 한다
String[] m2 = ("김성모", "김성모", "김성모");
static void m2(itn a, String[] names){}
static void m2(String[] names, int a){}
-------------------------------------------------------------------------------------
call by value
→ 메소드를 호출할 때 값을 넘긴다
-------------------------------------------------------------------------------------
call by reference Ⅰ
→ 메소드를 호출할 때 객체 주소를 넘긴다
stack → 메소드의 로컬 변수를 만드는 메모리
main() {
	int[] arr = new int{100, 200};
	swap(arr);
}
swap(int[] arr) {
	int temp = arr[0];
	arr[0] = arr[1];
	arr[1] = temp;
}
stack → main() > arr[] 
        → swap() > arr[] (3721번지가 들어간다), temp
heap → new 명령으로 만드는 메모리 → new int{100, 200}; (3721번지로 가정) → 배열 인스턴스의 주소가 main() arr[]에 들어간다
-------------------------------------------------------------------------------------
call by reference Ⅱ
class MyObject{
	int a;
	int b;
}
swap(MyObject ref){  → ref 변수에 있는 MyObject의 인스턴스(= object라고도 부른다) 주소를 받는다
	int temp = ref.a;
	ref.a = ref.b;
	ref.b = temp;
}
main(String[] args){
	MyObject ref = new MyObject();  → 힙에 있는 a에 주소가 리턴
	ref.a = 100;  → 레퍼런스.변수 → ref 레퍼런스에 주소로 가서 a에 100을 넣는다
	ref.b = 200;
	swap(ref);  → ref 레퍼런스에 주소를 넘겨준다
}
stack → main() > args, ref
        → swap() > ref, temp → 로컬 변수 생성 → return하면 사라진다
heap → MyObject() > a, b(배열처럼 연속적으로 만들어짐, 클래스 메모리 설계도에 정의된 변수를 만든다 "MyObject의 인스턴스")
Method Area → 코드는 여기 있다
garbage collector는 heap을 관리한다
-------------------------------------------------------------------------------------
★ JVM 메모리
Method Area → class byte code를 두는 곳 → static 변수(클래스 필드) 두는 곳
Stack → (쓰레드당 하나=per Thread) → 호출된 메소드의 로컬 변수 두는 곳 → Thread가 생성되면서 같이 생성된다
Heap → new 명령으로 만든 변수 두는 곳 → JVM이 실행되면서 만들어지고 모든 Thread가 공유한다, garbage collctor가 자원을 관리한다(reclaimed 해제, 회수)
$ java Exam0410
→ Exam0410 클래스를 Method Area에 보관한다(그대로 보관하는 것이 아니라 실행할 수 있는 구조로 바꿔서 바이트코드를 배치한다)
→ Method Area에 로딩된(보관된) 바이트코드에서 main() 메소드를 찾아 호출(실행)한다 
	→ main() 메소드의 로컬변수를 Stack 메모리에 만든다
	→ new 명령문이 있다면 해당 변수를 Heap에 만든다
-------------------------------------------------------------------------------------
★ JVM Stack과 Method 호출
JVM Stack 
main() 호출 > Stack에 Frame을 만들고 그 안에 [ args, r ] 로컬 변수를 연속적으로 만든다 
m1(5) 호출 > Stack에 Frame을 만들고 그 안에 [ value=5, r1, r2 ] 로컬 변수를 연속적으로 만든다
m2(value) 호출 > Stack에 Frame을 만들고 그 안에 [ value=5 ] 로컬 변수를 연속적으로 만든다
→ 5 + 100 연산 → r1 = 105 리턴 → Stack에서 m2메소드 Frame 삭제
m3(value) 호출 > Stack에 Frame을 만들고 그 안에 [ value=5 ] 로컬 변수를 연속적으로 만든다
→ 5 + 200 연산 → r2 = 205 리턴 → Stack에서 m3 메소드 Frame 삭제
→ m1메소드에서 r1+r2=310을 main메소드 r에 리턴 후 Stack에서 m1메소드 Frame 삭제
→ r(301)출력 → main 메소드 종료되면 JVM이 모든 메모리 해제
-------------------------------------------------------------------------------------
★ 재귀호출
sum(n) = n+sum(n-1), n>0
static int sum(int value){
	if (value == 1)
		return1;
	return value + sum(value - 1);
}
main() => sum(5) → 15를 출력
              => 5 + sum(4) = 4 + sum(3) 리턴 = 5 + 10
                  => 4 + sum(3) = 3 + sum(2) 리턴 = 4 + 6
                      => 3 + sum(2) = 2 + sum(1) 리턴 = 3 + 3
                          => 2 + sum(1) = 1 리턴 = 2 + 1 
                              => 1
→ 호출을 계속하므로 Stack에 sum Frame에 value라는 변수를 계속 만든다(메모리를 계속 만든다, 다른 메소드를 호출한 것과 같다)
→ value가 1이 되면 1 + sum(1-1)이므로 1만 리턴하게 한다
→ 호출 되었던 Stack 메모리는 밑에서 하나씩 삭제된다
→ 15를 출력, main 메소드가 종료되면 JVM도 종료되면서 모든 메모리가 삭제된다
-------------------------------------------------------------------------------------
★ 스택 오버플로우(stack overflow)?
→ JVM 스택 메모리가 꽉 차서 더이상 메서드 실행에 필요한 로컬 변수를 만들 수 없는 상태이다.(리턴을 안 했기 때문)
→ 큰 수는 반복문을 사용하자!
-------------------------------------------------------------------------------------



2023.12.01(금)
-------------------------------------------------------------------------------------
프로그램 아규먼트
main()
$ java -classpath bin/main com.eomcs.lang.ex07.Exam.0520 aaa bbb ccc → aaa bbb ccc 가 프로그램 아규먼트
[aaa]
[bbb]
[ccc]
종료!
→ JVM이 공백을 제거해서 "aaa", "bbb", "ccc" 문자열을 만들어 String[] 배열 생성
→ JVM이 main()을 호출하면 String[] 배열을 전달한다
-------------------------------------------------------------------------------------
JVM 아규먼트
$ java -classpath bin/main -Da=aaa -Db=bbb -Dc=ccc com.eomcs.lang.ex07.Exam0610
aaa
bbb
ccc
→ -D이름=값 -D이름=값 -D이름=값 
→ 이름=값을 Properties 객체에 저장
→ System.getProperty(이름)메소드가 Properties 객체에서 값을 가져온다(리턴)
-------------------------------------------------------------------------------------
Context Menu(Popup Menu)
→ 상황 메뉴
-------------------------------------------------------------------------------------
★ 클래스 ★
① 메소드 분류 → 메소드의 기능에 따라 서로 관련된 메소드를 별도로 분류해두면 유지보수하기 좋다
② 데이터 타입 정의 → 변수(field), 연산자(method)

★ 쌍방 참조 해소
→ 클래스가 상호 참조할 경우 강하게 연결되기 때문에 재사용하기가 불편하다
bidirectional(쌍방향) → unidirectional(단방향)
App <=>BoardMenu 쌍방향 참조
App → BoardMenu.execute() → Prompt.prompt() 단방향 참조
→ prompt() 메소드는 다른 프로젝트에서도 쓰일 수 있는 일반적인 기능이기 때문에 별도의 클래스로 분리하는 것이 재사용성을 높이는 방법이다

★ GRASP Patterns 
Patterns → 특정 문제를 해결하기 위해 실무에서 널리 사용하는(검증된) 설계 기법
GRASP (General Responsible Assignment Software Patterns) 
→ 일반적인 책임할당 설계기법
→ 클래스를 작성할 때 메소드와 필드(변수)를 두는 원칙
Information Expert, Crerator, Controller, Low Coupling, High Cohesim, 등...
Information Expert → 정보를 갖고 있는 클래스에서 그 정보를 다룬다 → Scanner를 사용하는 쪽에서 Scanner를 관리한다
High Cohesim → 한 클래스가 하나의 역할 수행
Low Coupling → 객체(클래스)간의 연결을 느슨하게 한다 → Prompt.input()
-------------------------------------------------------------------------------------



2023.12.04(월)
-------------------------------------------------------------------------------------
클래스 용도
① 메소드 분류
1단계 → App 클래스 밑에 main(), plus(), minus(), multiple(), divide() 메소드들을 생성
2단계 → main() 메소드 빼고 Calculator 클래스에 나머지를 옮기고, abs() 메소드 생성
3단계 → main() 메소드에서 쓰는 result 변수를 Calculator 클래스에 옮겨서 스태틱 필드(클래스 필드, 변수) 생성
→ static 변수 클래스를 사용하기 위해 메모리(method area)에 올릴 때 생성한다
→ HDD(.class 파일)에서 읽어와 RAM(Method Area)에 배치 → 클래스 로딩
→ ★ HDD에서 RAM 적재 후 CPU는 RAM에 있는 명령문 또는 data를 읽는다
4단계 → 클래스 변수의 한계 확인
5단계 → 인스턴스 변수 → 동시에 여러 개의 계산결과를 저장하기 위해 인스턴스 변수로 바꾼다
→ Calculator c1 = new Calculator();
→ Calculator c2 = new Calculator();
→ 클래스에 정의된 인스턴스 변수를 Heap 영역에 생성
→ Heap에 Calculator의 non static 변수를 선언된만큼 만든다, 각 c1, c2(Calculator의 레퍼런스)에 인스턴스를 넣는다
→ Calculator.plus(c1, 2);
→ Calculator.plus(c2, 3);
→ 인스턴스 변수를 다루는 메소드는 작업을 수행할 때 인스턴스 주소를 받아야 한다
→ result는 더이상 클래스 변수가 아니기 때문에 직접 접근할 수 없다
→ 인스턴스 주소를 통해서만 접근 할 수 있다
6단계 → 인스턴스 메소드
이전 방식 → Calculator.plus(c1, 2); → 인스턴스 주소를 파라미터로 전달
간결한 방식 → c1.plus(2); → 인스턴스 주소를 메소드 앞에서 전달, 레퍼런스의 타입을 보면 어떤 클래스의 메소드인지 알 수 있다
클래스 메소드(static method) vs 인스턴스 메소드(non-static method)
          클래스.메소드();                     레퍼런스.메소드();
          Calculator.plus();		c1.plus();
클래스 메소드
작업 결과를 개별로 관리하지 않을 때 사용한다
파라미터 값만으로 작업을 수행할 때
인스턴스 메소드
작업 결과를 개별적으로 관리하는 경우
파라미터를 사용해서 작업을 수행한 후 그 결과를 내부적으로 보관할 때
→ Calculator 클래스에 있는 메소드 앞에 static을 지워서 인스턴스 메소드로 변경
→ 메소드를 호출할 때 앞에서 전달한 인스턴스를 주소를 받을 수 있도록 this.라는 이름의 내장 변수를 갖고 있다
→ 전달받은 인스턴스는 this라는 이름의 내장 변수에 자동 저장된다
7단계 → 패키지 : 클래스를 분류하는 문법
com.eomcs.oop.ex02.step07 → com.eomcs.oop.ex02.step07.util에 Calculator를 이동
→ 유지보수 하기 쉽도록 클래스를 역할에 따라 분류하기
★ 패키지에 직접 소속된 클래스 → 패키지 멤버 클래스 → 패키지명.클래스명 → import 패키지명.클래스명(패키지명만 해도 됨)

클래스 문법 적용 전 
→ 클래스로 메소드 분류 
→ 스태틱 변수 
→ 인스턴스 변수(new, 레퍼런스 등장, 한번 할 때마다 파라미터로 레퍼런스 값을 받아야 함) 
→ 인스턴스 메소드(레퍼런스 값을 this라는 이름의 내장 변수에 자동 저장해서 쓴다)

OOP(Object Oriented Programming)
SOLID 원친 → GRASP 설계 기법 → GOF의 Design Patterns 실용 설계 기법
SRP(Single Responsibilty Principle), OCP(Open Closed Principle), LSP(Liskov Substitution Principle), ISP(Interface  Segregation), DIP(Dependency Inversion Principle)

② 데이터 타입 정의
1단계 → 낱개 변수 사용
→ Stirng name;
int kor;
int eng;
int math;
int sum;
float aver;
2단계 → 새 데이터 타입 정의
→ class Score{
	Stirng name;
	int kor;
	int eng;
	int math;
	int sum;
	float aver;
}
Score s = new Score → Score 클래스에 정의된대로 Heap 영역에 변수를 생성
s → 레퍼런스 → 인스턴스 주소가 저장
name kor eng mat sum aver → name에 시작 주소를 s에 저장 → Score에 인스턴스
변수 사용 → 레퍼런스.변수명 → s.name = "홍길동";
-------------------------------------------------------------------------------------



2023.12.05(화)
-------------------------------------------------------------------------------------
클래스 문법 적용 전 
→ 클래스로 메소드 분류 (static 메소드)
→ 스태틱 변수 (클래스 변수)
→ 인스턴스 변수 (new → 레퍼런스 변수)
→ 인스턴스 메소드 (this → 내장 변수)
-------------------------------------------------------------------------------------
클래스 문법 적용 전(낱개 변수) 
→ 인스턴스 필드(사용자 정의 데이터 타입) class Score{}
→ 리팩토링(합계, 평균 계산, 출력 기능을 메소드로 분리) printScore()
→ 리팩토링(합계, 평균 계산을 메소드로 분리) printScore(), compute()
→ GRASP (Information Export) class Score{ compute() 이동}
	→ Score 데이터 값을 다루는 메소드는 Score 데이터를 선언한 클래스에 가까이 두는 것이 유지보수에 좋다
	→ compute() 메소드는 Score 데이터를 다루느 메소드이다
	→ 사용자 정의 데이터 타입 입장에서는 그 데이터를 다루는 메소드가 연산자인 것이다 (사용자 정의 타입에 메소드 정의 = 연산자)
→ Score.compute(s1) → Score.compute()(연산자), s1(피연산자) 
	→ 계산을 수행할 때마다 인스턴스의 주소를 파라미터로 받아야 한다
→ s1.compute() → s1(피연산자), compute()(연산자)
	→ 메소드를 호출할 때 메소드 앞에 인스턴스 주소를 적어서 메소드에 내장된 this에 저장해서 사용한다
	→ 마치 변수 뒤에 연산자를 놓는 i++의 예와 비슷하다
→ 인스턴스 메소드 → 인스턴스의 연산자(this라는 내장 변수)
→ ★ 클래스를 역할에 따라 패키지로 분류 → domain, vo(value object), dto(data transfer object)로 분류할 수 있다 → 데이터를 표현하는 클래스
→ public : 모두 공개, protected : 서브 클래스와 같은 패키지의 멤버에게만 공개, private : 접근 불가! 내부에서만 접근 가능, (default) : 같은 패키지에 소속된 패키지만 접근 가능
→ 생성자(default constructor) Score 설계도(클래스 정의)에 따라 인스턴스 변수를 Heap 영역에 만든다
	→ ★ 생성자를 호출한다, 생성자에 넘겨주는 아규먼트의 타입과 개수, 순서에 따라 호출할 생성자를 결정한다
	→ ★ 생성자 초기화 메소드를 만들고 클래스 이름하고 같게 하고 리턴 타입(void, int, String 등....)을 지운다
	→ 클래스에 생성자가 없으면 컴파일러는 파라미터가 없는 기본 생성자를 만든다 → public Score(){} 
	→ 만약 해당 아규먼트를 받을 수 있는 생성자가 없다면 컴파일 오류 발생
	→ Score s1 = new Score("홍길동", 100, 90, 85);
	→ public Score(String name, int kor, int eng, int math) {
    		this.name = name;
    		this.kor = kor;
    		this.eng = eng;
    		this.math = math;
	    }

과제 10. 과제의 CRUD(Create, Retrieve/Read, Update, Delete) 구현
→ 과제 데이터를 입력, 조회, 변경, 삭제하는 기능 구현하기
-------------------------------------------------------------------------------------



2023.12.06(수)
-------------------------------------------------------------------------------------
★ 클래스로 분리 하는 이유 
→ 클래스 변수는 클래스 호출될 때 생성되고 JVM이 종료될 때 클래스 변수는 삭제된다
→ 클래스 변수를 원하는 구간에서 생성하면 메모리 낭비가 조금이나마 감소
→ 클래스는 명령어를 쪼갠 것, 클래스 로딩은 명령어를 로딩
→ 클래스 호출되면 클래스 변수와 클래스 메소드는 RAM에 로딩(적재, loading)된다
→ garbage collector에 관리 대상이 아니다 → garbage collector는 오로지 Heap 영역만 관리

생성자
→ 인스턴스를 생성될 때 호출
-------------------------------------------------------------------------------------
★ C++ vs JAVA
C++ → oop → 하나의 소스 코드를 클래스 단위로 잘게 쪼개서 관리 → 컴파일할 때는 하나의 실행파일로 묶여서 RAM에 로딩 후 cpu가 실행
JAVA → oop → 클래스 단위로 쪼개서 관리, 컴파일할 때 클래스 별로 바이트코드로 변환 → 필요한 클래스에 바이트코드를 RAM에 로딩 후 cpu가 실행
→ HDD에서 읽기는 너무 느려서 바이트코드를 JVM이 적절히 정리해서 Method Area에 로딩한다
-------------------------------------------------------------------------------------
C++ + DDL(Dynamic Linking Library)
→ 소스 코드를 클래스 단위로 쪼개서 관리
→ 컴파일 할 때 클래스를 묶어서 파일((실행될 때).exe, (사용할 때).dll .so)을 만든다 
→ 필요한 시점에 필요한 파일 ((사용할 때).dll .so)을 RAM에 로딩
-------------------------------------------------------------------------------------
Assignment 인스턴스 부르는 방법
→ obj 레퍼런스가 가리키는 인스턴스
→ obj가 가리키는 인스턴스
→ obj 인스턴스
→ obj 객체
-------------------------------------------------------------------------------------
레퍼런스 배열
Assignment assignment = new Assignment; → 오직 한 개의 인스턴스 주소만 저장
Assignment[] assignments = new Assignment[3]; 
→ 3개의 인스턴스 주소 저장 
→ 각각 인스턴스의 주소를 저장하는 레퍼런스
→ Assignment의 주소를 담을 레퍼런스를 3개 만들라는 명령

과제 12. 배열을 이용하여 여러 개의 레퍼런스 변수 만들기
Assignment[] assignments = new Assignment[3];
→ Assignment의 인스턴스주소에 assignments라는 레퍼런스 배열을 만든다
add(){
	Assignment assignment = new Assignment(); → 레퍼런스 변수를 만들어서
	assignment[i] = assignment; → 레퍼런스 배열의 인스턴스 주소를 저장한다
	i++;
}
-------------------------------------------------------------------------------------
★ 배열 크기 늘리기
→ 한번 배열을 만들면 크기를 변경하는 방법은 없다 그래서 새로 생성해서 garbage로 만들고, 새 배열을 사용한다
Assignment[] arr = new Assignment[3]; → garbage가 된다
→ arr = new Assignment[5]; → garbage가 된다
→ arr = new Assignment[7];
-------------------------------------------------------------------------------------



2023.12.07(목)
-------------------------------------------------------------------------------------
★ 스태틱 필드의 한계 확인
기존 클래스를 복제해서 기능을 추가
→ 새 게시판이 필요할 때마다 기존 클래스를 복제해서 만든다
장점 : 기능추가가 쉽다, 빠르게 구현
단점 : 코드가 중복 → 버그 수정 또는 기능 추가/변경/삭제 시 비용(개발비 : 개발 시간이 증가) 증가
→ 원본 코드에 버그나 기능이 추가되면 복제한 코드에도 버그나 기능을 추가해야한다(수작업)
	→ 코드가 중복되면 유지보수에 좋지 않다는 걸 알면서 왜 복제했는가?
	→ 게시글 목록을 저장하고 배열 레퍼런스가 static 필드(클래스 필드)이기 때문에 클래스 당 오직 한번만 생성할 수 있다
	→ 새 게시판에 목록을 따로 저장할 수 없다 → 그래서 복제해서 만든 것이다
→ 해결책 : 게시글 목록을 개별적으로 유지할 수 있도록 인스턴스 필드로 선언하면 된다
-------------------------------------------------------------------------------------
과제 15. 인스턴스 필드와 인스턴스 메소드 활용
→ BoardMenu 클래스에 인스턴스 필드 및 메소드 적용
장점 
→ BoardMenu 클래스를 복제하지 않고도 내부적으로 복제하는 효과 발생
→ 인스턴스 필드를 활용해서 복제품 개별로 관리가능
의존 객체 주입의 개념과 구현
→ 생성자를 통해 Prompt 객체를 Handler에 주입
-------------------------------------------------------------------------------------



2023.12.08(금)
-------------------------------------------------------------------------------------
class A {
	static int v1;
	int v2;
	static void m(){
		int v3;
	}
}
→ 클래스 로딩 → 스태틱 변수 생성 → 자동으로 초기화
→ 메소드 호출 → 로컬 변수 생성 → 자동으로 초기화 안됨
→ new로 인스턴스 변수 생성 → 자동으로 초기화
-------------------------------------------------------------------------------------
★ 모든 비트가 '전기없음'으로 설정된다
→ 정수 메모리에 전기없음을 표현할 때 0으로 나타냄
→ 0.0f 0.0 false 로 전기없을을 표현
→ 주소변수(레퍼런스)를 초기화 시킨 상태는 null로 표현
-------------------------------------------------------------------------------------
스태틱 초기화 블록
class A {
	static {
		변수 초기화 → 스태틱 필드를 유효한 값으로 초기화시키는 코드를 둔다
	}
	{
		인스턴스 변수 초기화 블록 → 생성자에 넣을 코드 → 각 생성자에 복사
	}
	A() {
		생성자
	}
	A(int ) {
		생성자
	}
	A(int, int ) {
		생성자
	}
}
→ 클래스 로딩 → 스태틱 필드 생성 → 스태틱 초기화 블록 실행 → 한번만 로딩(실행)된다
→ 컴파일할 때 인스턴스 블록의 코드를 생성자로 옮긴다 → 생성자가 여러 개일때, 각각의 생성자에 모두 옮긴다
-------------------------------------------------------------------------------------
인스턴스 블록 → 여러 생성자에 공통으로 들어갈 코드가 있다면 인스턴스 블록에 작성하면 코드 중복을 줄일 수 있다
-------------------------------------------------------------------------------------



2023.12.11(월)
-------------------------------------------------------------------------------------
★ 객체(클래스, 사용자정의 타입) 사용규칙을 정의하는 문법 → 인터페이스 → 인터페이스를 통해 클래스를 정의한다(구현체)(caller → callee)
과제16. 인터페이스
Menu 인터페이스 생성 → execute()가 포함되어야 한다 → Menu 인터페이스를 이용하여 AssignmentMenu, BoardMenu, HelpMenu, MemberMenu를 만든다
implements : 이행하다, 시행하다, 도구
① 인터페이스는 규칙을 정의한 것이기에 인스턴스 생성 불가

② Menu m = new BoardMenu(); 
→  인터페이스 규칙에 따라 정의된 클래스의 인스턴스 주소를 담을 수 있다
→ 인터페이스를 구현한 클래스 = 인터페이스 규칙에 따라 정의한 클래스
Menu m = new String(); → 이건 안됨, 인터페이스 규칙에 따라 만든 클래스가 아니다
③ 인터페이스 객체 사용 

Menu m = new Assignmentmenu();
m.execute(); → 인터페이스 규칙에 선언된 메소드이다
m.add(); m.view(); → Menu 인터페이스에 선언된 메소드가 아니다, 레퍼런스의 타입에 선언된 메소드만 호출가능(사용할 수 있다)
-------------------------------------------------------------------------------------
과제17. GoF Composite 패턴을 이용하여 메뉴를 구성하기
→ MainMenu와 나머지 Menu 객체들 사이에 coupling이 강결합되어 있다 
	→ 메뉴 클래스가 추가되면 MainMenu 클래스를 또 변경해야 한다
	→ 메뉴 클래스가 추가되더라도 MainMenu 클래스를 변경하지 않을 방법이 필요하다
→ 적용 설계 원칙
	→ SOLID 원칙 중에 'OCP(Open/Closed Priciple)' 적용
	→ GRASP 패턴의 'Low Coupling' 책임 할당 원칙 준수
→ 설게 원칙을 따르는 구현 방법
	→ GoF의 'Composite'패턴 적용
MainMenu가 직접적인 연결한다 → AssignmentMenu, boardMenu, MemberMenu, HelpMenu
"High Coupling" 
→ 기존 클래스의 변경에 직접적인 영향 
→ 새 기능 추가 시 MainMenu 변경
→ 해결 "Low Coupling", "Open/Closed Priciple" 적용

정의가 완료 되지 않은 메소드 → 추상 메소드 
-------------------------------------------------------------------------------------
★ 객체간 관계(UML)
① Association(연관) → 지속적인 사용
MenuGroup → Prompt
class menuGroup{
	Prompt prompt; → 인스턴스 변수에 보관한다
	MenuGroup(Prompt prompt);{
		this.prompt = prompt
	}
}

② Dependency(의존관계) → 특정 메소드를 실행할 때 일시적으로 사용
MenuGroup ················→ Prompt 
class MenuGroup{
	void execute(Prompt prompt){ → 의존 객체를 파라미터로 받는다
		.....
		.....
	}
}

메뉴 다루기 → 메뉴를 선택했을 때 작업 실행하기	  ┏→ 메뉴를 실행하라는 명령이 들어왔을 때 작업을 수행한다 (이벤트 발생) → 옵저버(Observer)(관찰자 패턴)
execute() → MenuItem → action() → <<Interface>>MenuHandler
					  ┗→ 구현 클래스
-------------------------------------------------------------------------------------
★ 게시글 메뉴
<<게시글>>MenuGroup 
		◇------→ <<등록>>MenuItem ◇------→ <<MenuHandler>>BoardAddHandler		|
		◇------→ <<조회>>MenuItem ◇------→ <<MenuHandler>>BoardViewHandler	|
		◇------→ <<변경>>MenuItem ◇------→ <<MenuHandler>>BoardModifyHandler         ◇------→ BoardRepository → Board[] boards;
		◇------→ <<삭제>>MenuItem ◇------→ <<MenuHandler>>BoardDeleteHandler	|	int length;
		◇------→ <<목록>>MenuItem ◇------→ <<MenuHandler>>BoardListHandler		|
→ MenuItem에는 프로젝트 관련 코드가 있어서는 안된다 → 왜? 다른 프로젝트에서 재사용할 수 있도록 하기 위함
→ 대신 메뉴를 선택했을 때 수행할 작업은 별도의 클래스로 분리한다
→ 모두 공유를 하면 완성!!!!!!!!!!!!!!!
-------------------------------------------------------------------------------------



2023.12.12(화)
-------------------------------------------------------------------------------------
메뉴를 다루는 일, 메뉴에 대한 작업을 수행하는 일
→ 섞여 있다 → 다른 프로젝트에서 재사용하기 어렵다
→ 작업을 수행하는 코드(예: 회원관리, 과제관리) = "Business Logic"을 분리

메뉴를 다루는 코드를 분리 "재사용성 강화"
→ GoF의 Composite 패턴 적용 → 계층적인 구조로 이루어진 객체를 다룰 수 있다

인터페이스
<<interface>>MenuHandler ←---- <<conrete>>BoardModifyHandler(callee) ← action() ← MenuItem(caller, client)
-------------------------------------------------------------------------------------
과제17. 인터페이스와 GoF의 Composite 패턴을 이용하여 메뉴를 구현하기
-------------------------------------------------------------------------------------
★ 과제18. GRASP 패턴의 Infomation Expert 적용 
→ 배열을 다루는 코드를 그 배열을 갖고 있는 클래스로 이관 
→ 클래스의 역할을 전문화(하나의 클래스가 이것 저것 여러 일을 하지 않고 한 가지 일에 집중(High cohesion 해당)
→ 이점은 재사용하기 쉽다
→ GRASP의 High cohesion 지침에 따르는 방식이기도 하다
→ 핸들러 객체에서 수행하는 배열 다루는 일을 실제 배열을 가지고 Repository 객체로 이관하기
	→ 객체의 역할을 전문화함으로써 관리하기가 쉬워진다
	→ 배열을 다루는 코드를 별도의 객체로 분리하면 코드 재사용이 쉬워진다
BoardAddHandler(배열 크기 증가) → 사용 → BoardRepository(Board[] boards;, length;)
BoardDeleteHnadler(배열 항목 삭제) → 사용 → → BoardRepository
→ 배열 크기 증가, 배열 항목 삭제 기능을 BoardRepository로 코드 이관
-------------------------------------------------------------------------------------
★ 캡슐화(Encapsulation)
→ 구체적인 동작과정(mechanism)을 감춘다
→ 이점 : 내부 구조를 변경하더라도 사용하는 측에는 영향을 주지 않는다
BoardAddHandler		BoardRepository
└→직접 접근------------→	Board[] boards;
		 └--→	length;
→ 이름을 변경한다거나 배열 대신 다른 방식으로 목록을 저장한다면 변경에 맞춰 접근방식을 바꿔야 한다
→ 해결책 : BoardRepository의 목록을 다루는 방식을 감춘다 
-------------------------------------------------------------------------------------
★ 캡슐화 적용
→ BoardRepository에서 제공해주는 도구(메소드)를 사용하여 목록에 접근한다
→ add(), remov(), get()으로 배열 접근, public으로 공개하고
→ 배열은 private로 감춘다
→ 직접접근 불가능
OOP의 Encapsulation(캡슐화)
→ 목록을 다루는 방식을 감추고 대신 외부에 공개된 도구(메소드)를 통해 목록을 사용하도록 유도한다
→ 목록을 다루는 방식을 변경하더라도 외부에 영향을 주지 않는다
→ 기능을 변경하더라도 다른 클래스에 옇야을 최소화시킬 수 있다
-------------------------------------------------------------------------------------
★ 다형성 활용
동물 → 포유류
       → 고양이과
       → 호랑이
포유류 → 동물(X)
          → 고양이과
          → 사자
고양이과 → 호랑이
             → 사자
             → 너구리(X)
→ 부모는 자식을 포함할 수 있지만 자식은 부모를 포함할 수 없다
다형성 활용(상속과 다형적 변수)
Car(parent=super class) → Sedan → Tico(child=sub class)
	     → Sonata
      → Truck → Poter
	     → Pavise
예)
Car c(다형적 변수, polymorphic variables) = new Car();
Car c1 = new Sedan();
Car c2 = new Tico();
Sedan c1 = new Sedan();
Sedan c2 = new Tico();
잘못된 예)
Sedan c = new Car();
Sedan c1 = new Poter();
Sedan c2 = new Truck();
-------------------------------------------------------------------------------------
★ java.lang.Object 클래스 → 최상위 클래스 = 자바의 모든 클래스는 Object의 sub 클래스이다
Object obj;
obj = new App();
     = new BoardAddHandler();
     = new BoardRepository();
     = new Member();
     = new Board();
Object
obj  -→ App();
     └→ BoardAddHandler
     └→ BoardRepository
     └→ Member
     └→ Board
다형적 변수를 이요하여 범용 Repository 만들기
BoardAddHandler → BoardRepository → Board[]
BoardListHandler  ┘
	........
MemAddHandler → MemberReposiroty → Member[]
MemlistHandler  ┘
	.........
AssignmentAddHandler → AssignmentRepository → Assignment[]
AssignmentListHandler  ┘
	..........
-------------------------------------------------------------------------------------
★과제19. ObjectRepository 범용 기능으로 변경 → 클래스 개수를 줄일 수 있고 중복 코드 제거
BoardAddHandler → ObjectRepository → Object[]
BoardListHandler  ┘
	........
MemAddHandler → ObjectRepository → Object[]
MemlistHandler  ┘
	.........
AssignmentAddHandler → ObjectRepository → Object[]
AssignmentListHandler  ┘
	..........
-------------------------------------------------------------------------------------



2023.12.13(수)
-------------------------------------------------------------------------------------
과제20. 제네릭을 사용하여 타입을 파라미터로 다루기
ObjectRepository에 제네릭 적용하기
→ 범용 클래스를 특정 타입을 다루는 클래스로 제한할 수 있다
→ 파라미터 값에 대해 특정 타입으로 한정할 수 있다
→ 반환값의 타입을 형변환 할 필요가 없다
T[] toArray(T[]) 메소드 추가하기
★ 레퍼런스를 선언하는 시점에 지정된 타입이 아닌 값을 넣으려고 하면 컴파일 오류가 발생한다 즉 특정 타입만 사용하도록 제한할 수 있는 문법이 제네릭(Generic)이다
-------------------------------------------------------------------------------------
제네릭(Generic)
Member, Assignment, Board → ObjectRepository → Member, Assignment, Board
Member, Assignemt, Board(O) → ObjectRepository<Board> → Board
-------------------------------------------------------------------------------------
★ Repository에 보관된 목록을 배열로 리턴 받기
방법1 
Board[] boards = new Board[this.objectRepository.size()];
this.objectRepository.toArray(boards);
방법2
Board[] boards = this.objectRepository.toArray(new Board[0]);
-------------------------------------------------------------------------------------
과제21. 자바Collection API 사용하기 (ArraList)
ArrayList() 클래스
-------------------------------------------------------------------------------------



2023.12.14(목)
-------------------------------------------------------------------------------------
제네릭 → 특정 타입에 클래스를 일반화 시킨다, 타입을 제한

객체지향 문법
ISO-8859-1 → 변화(Encoding) → UTF-16BE 
Charset.defaultCharset();
→ JVM에서 외부로 데이터를 내보내거나 외부에서 데이터를 읽을 때 사용하는 문자 규칙
JVM(UTF-16BE) ↔ OS(UTF-8)
-------------------------------------------------------------------------------------
★ immutable(불변)
String s1 = new String("Hello");
String s2 = s1.concat(", world!");
→ Hello + , world! → 결합해서 새로운 문자열을 만든다(새 String 객체) → 기존 객체를 변경하지 않는다
-------------------------------------------------------------------------------------
★ 바이트 배열로 꺼낼 때
byte[] bytes = s3.getBytes();
→ 기본 인코딩 방식(UTF-8)으로 코드 값 저장
byte[] bytes = s3.getBytes("인코딩 방식")
→ 호환성을 높이자
-------------------------------------------------------------------------------------
★ 형식을 갖춘 문자열을 만들기
String s4 = String.format("%s님 반갑습니다", "홍길동");
→ 스트링 객체를 만들어서 객체 주소 반환
-------------------------------------------------------------------------------------
★ 구분자와 문자열들을 파라미터로 받아서 새 문자열을 만든다.
String s5 = String.join(":", "홍길동", "임꺽정", "유관순");
-------------------------------------------------------------------------------------
★ primitive 값을 문자열로 만든다.
String s6 = String.valueOf(true); // "true"
String s7 = String.valueOf(3.14f); // "3.14"
String s8 = String.valueOf(100); // "100"
Integer x2 = Integer.valueOf("44", 16); // 16진수라고 지정한다.
-------------------------------------------------------------------------------------
★ Integer 객체에서 int 값을 뽑아 낼 때 
int v1 = i2.intValue(); 
-------------------------------------------------------------------------------------
★int 변환
int v2 = Integer.parseInt("1280"); // String
-------------------------------------------------------------------------------------
★ 2진수, 8진수, 16진수로 변환
String s1 = Integer.toBinaryString(77);
String s2 = Integer.toOctalString(77);
String s3 = Integer.toHexString(77);
-------------------------------------------------------------------------------------
★ ValueOf()로 만들면 한 객체만 생성해서 사용(-128~127
Integer i1 = Integer.valueOf(127);
Integer i2 = Integer.valueOf(127);
Integer i3 = Integer.valueOf(127);
→ 인테저 객체를 만든다(-128~127)
-------------------------------------------------------------------------------------
★ Math 클래스
// => 절대값 계산
System.out.println(Math.abs(-200));
// => ceil() : 파라미터로 주어진 부동소수점이 바로 위 큰 정수 값을 리턴
// => floor() : 파라미터로 주어니 부동소수점의 바로 밑 작은 정수 값을 리턴
System.out.println(Math.ceil(3.28)); // 4
System.out.println(Math.floor(3.28)); // 3
System.out.println(Math.ceil(-3.28)); // -3
System.out.println(Math.floor(-3.28)); // -4
// => 2의 7승 값을 알고 싶을 때
System.out.println(Math.pow(2, 7));
// => 반올림하여 정수 값 리턴
System.out.println(Math.round(3.14));
System.out.println(Math.round(3.54));
-------------------------------------------------------------------------------------
★ 오늘 데이트 객체 만들어서 출력
Date d1 = new Date();
String str0 = d1.toString();
// 인스턴스 메서드 활용
System.out.println(d1.getYear() + 1900);
System.out.println(d1.getMonth() + 1);
System.out.println(d1.getDate());
// 스태틱 메서드 활용
long currMillis = System.currentTimeMillis();
-------------------------------------------------------------------------------------
// ★ 생성자 활용
java.sql.Date today = new java.sql.Date(currMillis);
String str = today.toString();
System.out.println(str);
→ YYYY-MM-DD로 출력
-------------------------------------------------------------------------------------
// ★ 스태틱 메서드 활용
java.sql.Date d = java.sql.Date.valueOf("2019-12-30");
System.out.println(d);
// println()에 문자열을 주지 않고 그냥 객체(의 주소)를 넘기면
// println() 내부에서 해당 객체의 toString()을 호출한 후에 
// 그 리턴 값을 출력한다.
-------------------------------------------------------------------------------------
★ 캘린더 클래스 ★
Calendar c = Calendar.getInstance();
System.out.println(c.get(5));
// 인스턴스 메서드 활용
System.out.println(c.get(1)); // 년도
System.out.println(c.get(2) + 1); // 월(0 ~ 11)
System.out.println(c.get(5)); // 일
System.out.println(c.get(7)); // 요일(1 ~ 7)
System.out.println(c.get(4)); // 그 달의 몇 번째 주
System.out.println(c.get(10)); // 시(0 ~ 11)
System.out.println(c.get(11)); // 시(24시)
System.out.println(c.get(12)); // 분
System.out.println(c.get(13)); // 초
System.out.println("-----------------------");
// 상수의 활용
System.out.println(c.get(Calendar.YEAR)); // 년도
System.out.println(c.get(Calendar.MONTH) + 1); // 월(0 ~ 11)
System.out.println(c.get(Calendar.DATE)); // 일
System.out.println(c.get(Calendar.DAY_OF_WEEK)); // 요일(1 ~ 7)
System.out.println(c.get(Calendar.WEEK_OF_MONTH)); // 그 달의 몇 번째 주
System.out.println(c.get(Calendar.HOUR)); // 시(0 ~ 11)
System.out.println(c.get(Calendar.HOUR_OF_DAY)); // 시(24시)
System.out.println(c.get(Calendar.MINUTE)); // 분
System.out.println(c.get(Calendar.SECOND)); // 초
-------------------------------------------------------------------------------------
★ 상속하지 않고 기능 추가
Car() { model, maker, capacity }
1. Car() { model, maker, capacity } + { sunroof, auto } → 기존 코드를 복제 후 코드 추가
→ 새로운 생성자를 생성해서 기존 생성자를 호출한다
기존 코드의 코드(기능) 추가
→ 기능을 덧붙이면 점점 더 누더기 코드가 된다
기능(코드) 추가 → 기존 코드 변경 → 쓰지도 않는 코드가 남게되어 누더기 코드가 된다
2. Car() 클래스를 각 고객사에 복제 후 기능 추가
문제점
① 원본 코드에 오류 발생 → 복사해서 만든 모든 코드를 변경해야 한다
② 원본 코드에 기능 추가 → 복사해서 만든 모든 코드에도 기능 추가, 변경해야 한다
③ 중복 코드 발생!
3. ★ 기존 코드를 손대지 않고 추가/변경 → 상속(Inheritance)
Car() { model, maker, capacity } → 상속 → Car2() { sunroof, auto }
장점
→ 기존 코드가 소스파일이 필요 없다(클래스 파일만 필요)
→ 간단한 선언으로 상속 받겠다고 표시한 후 새 기능만 추가하면 된다
→ 기존 코드를 변경하면 상속 받는 모든 서브 클래스에 바로 적용된다
→ 중복 코드가 생성되지 않는다
단점
→ 무조건 기존 코드의 모든 기능을 상속 받아야 한다
→ 일부 기능만 상속 받기는 불가능
예)
class Sedan extends Car{
	boolean sunroof;
	boolean auto;
}
→ Car() : parent class = super class
→ Sedan() : child class = sub class 
특징 
→ 기존 코드의 소스 파일이
Sedan c = new Sedan("tico", "bit car", 5, true, true);
① 인스턴스 생성 → super 클래스의 인스턴스 변수부터 생성
Car()(super, parent) ◁---- extends---- Sedan()(sub, child)
→ 코드 재사용성을 높인다

class Calculator2 extends Calculator() {}
인스턴스 변수는 super class에서 sub class 순으로 선언(Calculator2의 인스턴스)
c.plus(5);
→ Calculator2에서 plus() 찾는다 → 없으면 상속 계층을 따라가면서 찾는다
c.multiple(2);
→ Calculator2의 multiple() 호출
→ 서브 클래스를 실행하려면 반드시 수퍼 클래스가 있어야한다
→ 수퍼 클래스로 지정한 코드를 내것처럼 쓰겠다는 의미

class Score2 extends Score() {}
s1.compute();
→ 수퍼 클래스의 메소드와 동일한 signeture(메소드명, 파라미터, 리턴타입)로 재정의 하는 것이 낫다
→ super class의 메소드를 sub class의 역할에 맞게끔 재정의
→ 오버라이딩 (재정의, Overriding)
-------------------------------------------------------------------------------------



2023.12.15(금)
-------------------------------------------------------------------------------------
클래스
→ 데이터(변수) + 연산자(메소드)
→ 클래스는 데이터에 대한 정보와 그 데이터를 다루는 연산자를 정의한 설계도
singleton
하나의 객체만 다루고자 할 때 private로 캡슐화 하고 메소드로 인스턴스 생성
Factory Method
인스턴스를 생성하는게 복잡할 때 인스턴스 생성 기능을 메소드로 구분하자
-------------------------------------------------------------------------------------
B b = new D();
→ 다형적 변수 : 서브 클래스의 인스턴스 주소도 저장할 수 있다
→ 형식상 b는 B 클래스의 레퍼런스
→ B를 통해서 m3(), m4()를 찾아갈 수 없다
-------------------------------------------------------------------------------------
★ 생성자는 수퍼 클래스로부터 해당 클래스까지 내려온다
→ 인스턴스 생성 → C 클래스 생성자 호출 → B 클래스 생성자 호출 → A 클래스 생성자 호출 → 수퍼 클래스로부터 해당 클래스까지 리턴
→ 각 생성자 앞에 super();를 컴파일이 자동으로 붙인다 → A 클래스는 Object 클래스 생성자를 호출
-------------------------------------------------------------------------------------
★ 메소드 호출은 해당 클래스로부터 수퍼 클래스로 따라 올라간다
-------------------------------------------------------------------------------------
★ 다중 상속
→ 수퍼클래스의 코드가 겹칠수 있기 때문에 자바는 다중상속을 허락하지 않는다
-------------------------------------------------------------------------------------
★ 상속 : Specialization(전문화) , Generalization(일반화)
Specialization(전문화)
① Car() { model, maker, capacity, run() }
② Sedan extends Car() { doSunroof(), run()(overriding) } → Specialization
③ Truck extends Car() { dump(), run()(overriding) } → Specialization
→ 수퍼 클래스를 상속 받아 서브 클래스를 만드는 것
-------------------------------------------------------------------------------------
Generalization(일반화)
① Sedan() { model, maker, capacity, run(), doSunroof() }
② Truck() { model, maker, capacity, run(), dump() }
→ 서브 클래스들의 공통 필드, 메소드 발견 → "코드 중복"
③ Car() { model, maker, capacity, run() } 
→ 중복 코드를 분리해서 super 클래스로 정의
→ 서브 클래스들의 공통 기능을 뽑아 수퍼 클래스를 만드는 것
-------------------------------------------------------------------------------------
★ 상속과 추상 클래스, 추상 메소드
추상 클래스
Sedan() { start(), shutdown(), run(), dosunroof() }
Truck() { launch(), stop(), go(), dump() }
→ 유사 기능 발견 → Generalization → Car 수퍼 클래스 정의
Car() { start(), shutdown(), run() } → Sedan()과 Truck()에 상속
→ 직접 Car 클래스를 사용하지 않도록 막을 필요가 있다
→ 왜? Car 클래스의 목적은 Sedan()과 Truck()의 공통 코드 유지이기 때문이다
→ 추상 클래스로 만든다
★ abstract class Car() {} → Car c = new Car(); 인스턴스 생성 불가능
abstract class  <=>  concrete class
★ 추상 메소드
run() 서브 클래스의 역할에 맞게 재정의 해야한다
→ 어차피 서브 클래스에서 정의할 메소드라면 굳이 수퍼 클래스에 정의할 필요가 있는가?
→ 있다. 메소드 시그너처(method signature)를 통일하기 위해서!
→ 대신 서브 클래스에서 반드시 재정의 할 메소드라면 수퍼 클래스에서 구체적으로 구현하지 말라!
→ 이것이 추상 메소드 → public abstract void run(); → {} 메소드 몸체를 가지지 않는다 → 메소드 시그너처(method signature)만 선언한다
응용
① 서브 클래스에서 재정의 할 메소드
② 서브 클래스에서 반드시 재정의 하도록 강요하고 싶을 때
★ 일반 클래스(concrete class)는 추상 메소드를 선언할 수 없다 → 추상 클래스와 인터페이스에서만 선언 가능
-------------------------------------------------------------------------------------
★ 다형성(Polymophism)
Vehiclea(){} 
    → Bike
    → Car
        → Sedan
        → Truck
-------------------------------------------------------------------------------------
★ instanceof 연산자?
=> 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사한다.
=> 또는 그 상위/하위 클래스의 인스턴스인지 검사한다.
Vehicle v = new Sedan();
System.out.println(v instanceof Sedan);
System.out.println(v instanceof Car);
System.out.println(v instanceof Vehicle);
System.out.println(v instanceof Object);
System.out.println(v instanceof Truck);
System.out.println(v instanceof Bike);
-------------------------------------------------------------------------------------
★ getClass() 연산자?
=> 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 리턴한다.
=> == 연산자를 사용하여 특정 클래스의 인스턴스인지 좁혀서 검사할 수 있다.
클래스명.class
=> 클래스 정보를 갖고 있는 스태틱 변수이다.
Vehicle v = new Sedan();
System.out.println(v.getClass() == Sedan.class);
System.out.println(v.getClass() == Car.class);
System.out.println(v.getClass() == Vehicle.class);
System.out.println(v.getClass() == Truck.class);
System.out.println(v.getClass() == Bike.class);
-------------------------------------------------------------------------------------
★ 다형성-오버로딩, 오버라이딩
오버로딩
plusi(int, int) : int
plusf(float, float) : float
→ 같은 이름의 메소드를 중복해서 만들수 없다면 위와 같이 유사한 이름으로 만들어야 한다
→ 개발자는 더하기 계산을 수행할 때 타입에 따라 해당 메소드를 호출해야 한다 → 일관성이 없고 유지보수가 불편하다
→ 파라미터의 형식(타입과 개수)은 다르지만 같은 기능을 수행하는 메소드에 대해 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위한 문법이다
오버라이딩
→ 상속 받은 메소드를 서브 클래스의 역할에 맞게 재정의하는 문법
→ 메소드 이름과 매개변수 개수나 타입이 같아야한다 → 시그너처(메소드 이름, 파라미터 타입, 개수, 순서)가 같아야한다
→ 원래의 메소드보다 접근 범위가 같거나 같아야한다
→ 메소드 정의 앞에 @Override를 붙여서 컴파일러에게 실수 했는지 검사받는다
-------------------------------------------------------------------------------------
상속과 super, this 레퍼런스
class A() { m() }
class A2() { m(), test(){ this.m(), super.m() } }
A2 obj = new A2();
obj.test();
출력 →
A2의 m()
A의 m()
this 레퍼런스
→ 인스턴스의 클래스(this의 실제 클래스, 예 : A3)에서부터 메소드를 찾아 호출한다
→ 메소드를 찾을 때까지 최상위 클래스까지 따라 올라간다
super 레퍼런스
→ 메소드가 소속된 클래스의 수퍼 클래스, 예 : A 에서 메소드를 찾아 호출한다
→ 수퍼 클래스에 없으면 그 상위 클래스로 따라 올라간다
-------------------------------------------------------------------------------------



2023.12.18(월)
-------------------------------------------------------------------------------------
다형적 변수(인스턴스 필드) 찾을 때
this → 메소드가 소속된 클래스의 필드부터 찾아 올라간다
super → 메소드가 소속된 클래스의 수퍼 클래스부터 찾아 올라간다
-------------------------------------------------------------------------------------
오버라이딩 메소드의 리턴 타입
static class Car {}
static class Sedan extends Car {}
static class Truck extends Car {}
static class Tico extends Sedan {}

static class CarFactory {
	Car create() {
		return new Car();
	}
}

static class SedanFactory extends CarFactory {
	// 오버라이딩 메서드의 리턴 타입은
	// 서브 클래스도 가능하다.
	@Override
	Sedan create() {
		return new Sedan();
	}
}

static class TicoFactory extends SedanFactory {
	// 오버라이딩 메서드의 리턴 타입은
	// 서브 클래스도 가능하다.
	@Override
	Tico create() {
		return new Tico();
	}
}
-------------------------------------------------------------------------------------
★ 클래스 앞에 final을 붙이면
→ 서브 클래스를 만들 수 없다
→ 서브 클래스의 생성을 방지하여 기존 클래스를 대체하지 못하도록 할 때 사용한다
-------------------------------------------------------------------------------------
★ 메소드 앞에 final을 붙이면
→ 오버라이딩 불가!!!!
→ 서브 클래스에서 변경하면 안되는 메소드인 경우에 사용한다
→ 보안에 관련된 메소드들에 사용된다
-------------------------------------------------------------------------------------
★ 인스턴스, 스태틱 변수(필드) 생성할 때 final 붙이면 
→ 상수 필드가 된다
→ 생성자에서 초기화해야 한다
→ 초기화 문장에서 값을 설정했으면 생성자에서 다시 값을 설정할 수 없다
-------------------------------------------------------------------------------------
★ 로컬 변수 앞에 final 붙이면
→ 값을 변경할 수 없는 상수로 사용
-------------------------------------------------------------------------------------
★ 파라미터 앞에 final 붙이며
→ 파라미터는 메소드가 호출될 때 외부의 값을 받는 용도의 변수다
→ 메소드 안에서 파라미터 값을 임의로 변경하게 되면 처음 받은 파라미터 값을 사용하지 못하는 상황이 발생한다
→ 그래서 이런 상황을 피하고자 보통 실무에서 파라미터 final로 선언한다
→ 메소드 안에서는 값을 바꿀 수 없다 하지만 메소드 호출할 때 아규먼트 값은 변경 가능
-------------------------------------------------------------------------------------
★ 추상 클래스의 목적
→ 추상 메소드가 있든 없든 상관없이 추상 클래스를 만들 수 있다
→ 서브 클래스에게 공통 필드나 메소드를 상속해주는 것이 목적이다
→ 직접 사용하지 않는다
→ 여러 클래스를 같은 타입으로 묶기 위함이다
→ 상속에서 generalization을 통해 수퍼 클래스를 정의하는 경우에 그 수퍼 클래스를 주로 추상 클래스로 만든다.
-------------------------------------------------------------------------------------
★ 추상 클래스
→ 메소드 선언부에 abstract를 붙인다
→ 메소드 몸체가 없다
→ 추상 클래스나 인터페이스에서만 선언할 수 있다
→ 서브 클래스마다 구현이 다를 수 있는 경우에 사용한다
→ 서브 클래스가 반드시 구현해야 하는 메소드가 있다면 추상 메소드로 선언하라(강요하는 것이다)
→ 이것 또한 오버라이딩이다
→ 서브 클래스에서 추상 메소드를 구현하지 않는다면 추상 클래스가 되어야 한다
→ ★ 서브 클래스들이 가져야할 공통 변수나 메서드를 제공하는 것이다.
-------------------------------------------------------------------------------------
★ 추상 메소드, 추상 클래스를 활용한 GoF의 Template Methode 패턴
→ prepareRecipe() 
→ 어차피 서브 클래스에서 재정의해야한다
→ 추상 메소드로 선언하라! 
→ 이 메소드는 서브 클래스를 만들 때 일정의 틀 역할을 한다
→ 이것이 Template Method(= abstract method)이다
-------------------------------------------------------------------------------------
★ Template Method(템플릿 메소드)
→ 실행 흐름(일고리즘)을 수퍼 클래스에서 정의하고 구체적인 동작의 정의는 서브 클래스에 맡긴다
→ 규칙을 발견해서 규칙을 정의해서 상속으로 메소드의 역할에 맞춰 재정의한다
-------------------------------------------------------------------------------------
★ getter/setter 를 다른 말로 "프로퍼티(property)"라 부른다.
   → getter만 있는 경우: read only 프로퍼티
   → setter만 있는 경우: write only 프로퍼티
   → getter/setter 모두 있는 경우: read/write 프로퍼티
-------------------------------------------------------------------------------------
this 메소드 → 실제 객체 기준
super 메소드 → 메소드가 소속된 클래스 기준

this 필드 → 메소드가 소속된 클래스 기준
super 필드 → 메소드가 소속된 클래스 기준
-------------------------------------------------------------------------------------



2023.12.19(화)
-------------------------------------------------------------------------------------
protected 접근제어
→ Y + 같은 패키지 + 서브 클래스 에서 접근 가능
→ 서브 클래스가 만든 변수인 경우 접근 가능
→ Y 클래스가 만든 변수이다 Exam0213 클래스가 만든 변수가 아니다
→ ★ 서브 클래스로 만든 변수인 경우 서브 클래스에서 접근 가능
class Exam0214 extends Y {
	maint() {
		Exam0214 obj = new Exam0214();
		obj.protectedVar = 100;
	}
}
→ Exam0214에서 Y 설게도에 따라 만든 변수
→ Exam0214가 소유한 변수
-------------------------------------------------------------------------------------
생성자를 private으로 선언
→ 외부에서 이 클래스의 인스턴스를 생성하는 것을 막을 수 있다
→ 인스턴스 생성 과정이 복잡할 경우
→ 직접 인스턴스를 생성하기 보다는 인스턴스를 생성해주는 메서드를 사용하여 인스턴스를 만드는 것이 유지보수할 때 편하다.
→ 즉 인스턴스를 생성해 주는 메서드를 통해 인스턴스를 생성하면 인스턴스를 사용하고픈 개발자는 코드가 간결해진다 이런 설계 방식에 대해 이름을 붙였으니 
→ 이런 설계 방식에 대해 이름을 붙였으니 그 이름도 유명한 "factory method" 설계 패턴이다.
-------------------------------------------------------------------------------------
팩토리 메소드(Factory Method) 패턴
class Car {
	private Car() {}  	  → 생성자를 private으로 만들어서 외부에서는 인스턴스 생성 불가
	public static Car create() {
		Car c = new Car();
		return c;
	}	
}
Car c = Car.create(); 
→ Factory Method
→ 호출할 때마다 새 객체를 만들어 리턴
-------------------------------------------------------------------------------------
싱글톤(Singleton) 패턴
class Car {
	public Car(){}
}
class CarFactory{
	private CarFactory(){}
	static CarFactory instance;
	public static CarFactory getInstance(){
		if( instance == null ){
			instance = new CarFactory();
		}
		return instance;
	}
}
→ CarFactory factory = CarFactory.getInstance();
→ Car c1 = factory.create();
→ 같은 객체 리턴
-------------------------------------------------------------------------------------
추상화 => 데이터화 + 연산자
물리적으로 존재하는 객체(학생) → 추상화 → class Student{String name; int age; ......} → 추상적인 데이터
주문 → 추상화 → class Oder{.....} → 추상적인 데이터
-------------------------------------------------------------------------------------
과제22. 접근 제어 modifier 및 셋터, 겟터 도입하기
→ 인스턴스 필드에 직접 접근하는 것을 막는 방법 : private
→ 인스턴스 필드에 값을 저장하고 꺼내는 방벙 : getter/setter
-------------------------------------------------------------------------------------
과제23. 상속(generalization)과 추상 클래스, 접근 제어 활용하기
→ MenuHandler 구현체의 공통 분모를 추출하여 수퍼 클래스 정의하기
→ 수퍼 클래스를 추상 클래스로 정의하여 직접 사용을 막기
→ action(Menu menu){ super.action(menu); }
→ 오버라이딩 하기 전에 하던 일을 하게 하고 그 다음에 하위 클래스 일을 더하는 효과
→ prompt 서브 클래스가 사용하는 의존객체를 수퍼 클래스에서 관리
→ 서브 클래스에서 직접 사용할 수 있도록 접근 범위를 조정한다
→ protected로 접근 범위를 조정
-------------------------------------------------------------------------------------



2023.12.20(수)

객체(사람, 사물) → 메세지 = 메소드 = 연산자 → 객체(사람, 사물)
-------------------------------------------------------------------------------------
새규칙을 추가해야 할 상황에 직면
→ 규칙 추가
→ 새로 규칙을 추가하면 기존 클래스를 변경해야 한다
→ 기존 프로젝트에서는 m3()가 필요없을지라도 추가로 구현해야 한다
해결 → 이전에 작성한(구현한) 클래스에 영향을 끼치지 않으면서 규칙을 추가하는 문법
→ default를 붙여서 구현
→ 구현한 메소드이기 때문에 기존에 만든 클래스에는 영향을 끼치지 않는다
단점
→ 구현을 강제할 수 없다
해결2
→ 인터페이스 상속
→ 기존 규칙에 새 항목 추가
→ Spec 인터페이스를 Spec2의 상속을 받고 m3(); 추상 메소드 추가
→ m3();는 추상 메소드이기 때문에 반드시 구현해야 한다
-------------------------------------------------------------------------------------
인터페이스 다중 상속
→ 슈퍼 인터페이스의 메소드가 중복돼도 상관없다 
→ 구현되지 않은 메소드이기 때문이다
→ 메소드의 리턴타입만 다를 경우 다중상속 불가 → 구분할 수 없기 때문
→ 리턴타입만 다른 메소드를 여러개 오버로딩 할 수 없다

인터페이스 다중 구현
→ 메소드 시그너처(이름, 리턴타입, 매개변수)만 같으면 다중 구현에 문제가 없다
→ 구현 메소드가 인터페이스를 모두 만족시키기 때문이다

default 메소드 다중 구현 불가
→ 메소드가 구현된 경우 어느 메소드를 상속 받아야 하는지 결정할 수 없기 때문에 다중 구현 불가
-------------------------------------------------------------------------------------
★ 인터페이스와 추상 클래스의 콜라보 ★
<<interface>>ProtocolA (){ rule1(), rule2(), rule3(), rule4(), rule5(), rule6(), rule7(), rule8() }
→ MyClass 클래스 구현하려면 인터페이스의 모든 규칙을 구현해야한다
→ 추상 클래스에서 최소상태로 구현해서 상속을 한다
<<abstract>>AbstractProtocolA implement ProtocolA (){ rule1(){}, rule2(){}, rule3(){}, rule4(){}, rule5(){}, rule6(){}, rule7(){}, rule8(){} }
→ 추상 클래스를 상속 받아서 그 중에 필요한 규칙만 오버라이딩 하면 된다

인터페이스 -- 추상클래스 콜라보 예
<<interface>> Servlet() { init(), service(), destory(), gerServletInfo(), getServletConfig() } 

<<concrete>> Myservlet2 implements () { init(){}, service(){}, destory(){}, gerServletInfo(){}, getServletConfig(){} }
→ 인터페이스로 바로 구현하면 모든 추상 메소드를 구현해야한다
<<abstract>> GenericServlet implements Servlet () { init(){}, destory(){}, gerServletInfo(){}, getServletConfig(){} }
<<concrete>> MyServlet extends GenericServlet () { service(){} }
→ 인터페이스로 추상 클래스를 구현하고 상속 받아서 구현하면 추상 클래스에서 구현하지 않은 추상 메소드만 구현하면 된다
-------------------------------------------------------------------------------------
★ Object 클래스와 instanceof ★
모든 클래스는 Object 클래스를 상속 받는다
Object 클래스의 주요 메서드
1) toString()
=> 클래스이름과 해시코드를 리턴한다.(클래스 정보 간단히 출력)
=> 객체의 타입이 String 타입이 아니라면 toString 메소드를 자동으로 호출
2) ★equals()
=> 같은 인스턴스인지 검사한다. 
=> s1.equalsIgnoreCase(s2) → 알파벳에 대소문자 구분하지 않고 비교한다
3) hashCode()
=> 인스턴스를 식별하는 값을 리턴한다.
4) getClass()
=> 인스턴스의 클래스 정보를 리턴한다.
5) clone()
=> 인스턴스를 복제한 후 그 복제 인스턴스를 리턴한다.
6) finalize()
=> 가비지 컬렉터에 의해 메모리에서 해제되기 직전에 호출된다.

인스턴스 값 비교, equals 메소드를 오버라이딩 해서 쓰기도 한다
str.equals(str1);
-------------------------------------------------------------------------------------
해시 값(디지털 지문)
=> 특정 수학 공식(알고리즘)(MD4, MD5, SHA, PGP, CRC 등)에 따라 값을 계산한다.
=> 알고리즘이 좋을수록 같은 값을 가질 확률이 줄어든다
=> 알고리즘이 좋은 이유는 복잡하고, 변환속도가 느리고, 결과값이 커지기 때문이다
Object에서 상속 받은 hashCode()는 인스턴스마다 고유의 4바이트 정수 값을 리턴한다.
=> 이 값은 toString()의 출력 값으로 사용된다.
=> System.out.println(Integer.toHexString(obj1.hashCode())); → 10진수를 16진수로 변환
해시 값 간단 = 정확도 다운 = 생성시간 빠름
해시 값 복잡 = 정확도 업 = 생성시간 느림
-------------------------------------------------------------------------------------
★ 해시 값 활용 예 ★
톰캣 서버 사이트 → tomcat.zip 다운 → 로컬
→ 해커가 개입해서 변조된 파일이 다운로드 될 수 있다
→ 서버에 원본 파일과 같은지 검증이 필요하다
→ 해시 알고리즘에 따라서 (PGP, SHA512) 해시 값 참조
→ 우리 해시 값이랑 비교
→ $ certutil -hashfile "apache-tomcat-9.0.84.zip" SHA512 
→ 명령어로 해시 값 만들어서 비교하기
 -------------------------------------------------------------------------------------
getClass() : 객체타입?+클래스이름 반환
getClass().getName() : obj의 클래스 이름 반환
-------------------------------------------------------------------------------------


2023.12.21(목)
-------------------------------------------------------------------------------------
Hash Algorithm
해시 값 크기가 작으면 
→ 해시 값 충돌 
→ 데이터는 다른데 같은 해시 값이 나온다
→ 데이터 크기보다 작은 크기의 숫자로 바꾸면 필연적으로 발생한다
결론
→ 해시 값 크기가 크면 충돌 가능성은 낮아진다
→ 해시 값 크기가 크며 계산시간 (비교, 생성 시간)이 오래 걸린다
-------------------------------------------------------------------------------------
★ HashSet = Hash + Set ★
→ 값을 저장할 때 해시값을 계산하여 저장 위치를 알아낸다
→ 집합 방식으로 다룬다 → 중복 불가능
→ equals()와 hashCode()를 호출해서 중복 여부 검사
→ equals()와 hashCode()가 같다면 같은 객체로 판단하여 저장하지 않는다
→ 저장할 때 저장 위치는 hashCode()의 리턴 값을 사용하여 계산한다
-------------------------------------------------------------------------------------
★ HashMap() ★ 
→ 값을 저장할 key 객체의 해시코드를 이용하여 저장할 위치(인덱스)를 계산한다.
→ 값을 저장할 때 사용한 key 객체로 값을 찾아 꺼낸다.
→ System.out.println(map.get(k3));
-------------------------------------------------------------------------------------
★ getClass() ★
→ 레퍼런스를 통해서 클래스의 정보를 간단히 알 수 있다
→ System.out.println(classInfo.getName()); // 패키지명 + 바깥 클래스명 + 클래스명
→ System.out.println(new byte[10].getClass().getName()); //[B → 배열의 클래스 정보 출력
=	String obj1 = new String();
	Class classInfo = obj1.getClass();
	System.out.println(classInfo.getName());
★ Primitive 타입의 클래스 정보
	Class classInfo = byte.class;
	System.out.println(classInfo.getName());
	System.out.println(short.class.getName());
★ 배열 항목의 타입 정보를 가져온다.
	System.out.println(new int[10].getClass().getComponentType().getName());
-------------------------------------------------------------------------------------
★ 인스턴스를 복제할 수 있게 하려면 ★
→ Object에서 제공하는 ★clone()을 호출할 수 있어야 한다.
→ 그런데 clone()의 접근 범위가 protected 이라서 같은 패키지의 멤버이거나 서브 클래스가 아니면 호출할 수 없다.
해결
→ Object에서 상속 받은 clone()을 오버라이딩 한다.
→ 다른 패키지의 멤버가 호출하려면 public 으로 접근 제어의 범위를 넓혀야 한다.
→ 오버라이딩 할 클래스 옆에 implements Cloneable를 붙여서 허락을 받는 효과(표시)
public Score clone() throws CloneNotSupportedException {
	return (Score) super.clone();
}
→ Object의 clone() 메서드는 Heap의 존재하는 인스턴스 변수들을 그대로 복제한다.
-------------------------------------------------------------------------------------
★ shallow copy ★
→ JVM은 인스턴스를 새 메모리에 그대로 복제
→ 객체(Car)가 포함하는 의존 객체(Engine)는 복제하지 않는다
-------------------------------------------------------------------------------------
★ deep copy ★
→ 객체(Car)가 포함하는 의존 객체(Engine)도 새 메모리에 복제한다
→ 의존 객체도 clone()을 오버라이딩을 하고 복제 안에서 복제를 하게끔 설계
	Car copy = (Car) super.clone();
	copy.engine = this.engine.clone();
	return copy;
-------------------------------------------------------------------------------------
문자열 결합
"aaa" + obj → 문자열과 레퍼런스 결합
→ "aaa" + "obj.toString() 리턴 값"
→ "aaa리턴값"
-------------------------------------------------------------------------------------
★ String 클래스
Heap
String s1 = new String("Hello");
String s2 = new String("Hello");
→ new 명령으로는 Heap에 새로운 인스턴스를 만들기 때문에 다른 객체가 생성
★ 상수풀(Constant pool)
String s3 = "Hello";
String s4 = "Hello";
→ 레퍼런스한테 바로 값을 넣으면 상수풀(Constant pool)이라는 곳에 생성된다
→ 상수풀에 같은 값이 있다면 새로운 인스턴스를 만들지 않고 같은 값에 인스턴스 주소를 리턴한다
String s2 = s1.intern();
→ String 객체에 들어 있는 문자열과 동일한 문자열을 갖고 있는 String 객체를 상수풀에서 찾는다.
→ 있으면 그 String 객체의 주소를 리턴한다. 없으면 상수풀에 String 객체를 생성한 후 그 주소를 리턴한다.
-------------------------------------------------------------------------------------
String - toLowerCase() 메소드
String s1 = new String("Hello");
String s2 = s1.toLowerCase();
→ 새 String 인스턴스 생성 하고 알파벳을 소문자로 바꾼 뒤 s2에 저장 
→ String은 불변(Immutable) 객체이기 때문에 새로운 객체에 저장하는 것이다
-------------------------------------------------------------------------------------
StringBuffer 객체는 mutable 객체이다.
→ 인스턴스의 데이터를 변경할 수 있다
→ 원래의 문자열을 변경하고 싶을 때 사용하는 클래스이다
-------------------------------------------------------------------------------------
★ StringBuffer와 StringBuilder 차이점
→ 여러 스레드가 작업해야 한다면 StringBuffer를 사용하고 한 스레드만 작업해야 한다면 StringBuilder를 사용한다
StringBuffer
→ 여러 스레드가 작업 할때 하나의 스레드만 작업할 수 있게 (동기화 지원)
→ StringBuilder보다 작업시간이 느리다 하지만 작업이 안정적이다
StringBuilder
→ 여러 스레드가 작업 할때 다른 스레드가 작업 권한을 가지게 된다 (동기화 비지원)
→ StringBuffer보다 작업시간이 빠르다 하지만 작업 권한을 막지 못해서 작업이 안정적이지 않다
→ 여러 스레드가 작업해야 한다면 StringBuffer를 사용하고 한 스레드만 작업해야 한다면 StringBuilder를 사용한다
-------------------------------------------------------------------------------------
★ StringBuffer와 MultiTread(스트링 버퍼)( HashTable : 동기화 )
append(String str){
	① 입력할 위치를 알아낸다
	② 문자열을 붙인다
	③ 저장된 문자열의 수를 변경한다
}
→ Tread → w1("AAAA"), w2("----"), w3("XXXX"), w4("****")
→ w1이 진입 → ①②③(length=4) → return
→ w3이 진입 → ①②③(length=8) → return
	→ w3이 자원 권한을 뺏겨도 다른 스레드를 밀어내다가 w3가 자원 권한을 획득하고 작업을 마친 후 다른 스레드 작업
	→ 먼저 진입해서 작업하던 w3가 나올 때까지 진입할 수 없다
	→ Synchronized = 동기화 처리 = lock(잠금) → 동시에 여러 스레드 진입 불가
→ w4이 진입 → ①②③(length=12) → return
특징
→ StringBuffer는 한 번에 한 스레드만이 버퍼를 다루도록 제한한다
→ 대신 lock/nulock 하는데 시간소요 
→ StringBuilder보다 느리다
→ ★ "Thread-safe" 보장, 여러 스레드가 와도 안전하다
-------------------------------------------------------------------------------------
★ StringBuilder와 MultiThread(스트링 빌더)( HashMap : 비동기화 )
append(String str){
	① 입력할 위치를 알아낸다
	② 문자열을 붙인다
	③ 저장된 문자열의 수를 변경한다
}
→ Tread → w1("AAAA"), w2("----"), w3("XXXX"), w4("****")
→ w1이 진입 → ①②③(length=4) → return
→ w3이 진입 → ①② interrupt → OS가 자원을 관리 하기 때문에 통제
→ w4이 진입 → ①②③(length=8) → return
→ w4이 진입 → ①②③(length=12) → return → OS가 통제하지 않으면 작업한다
→ w3이 ③(length=8) → return → 전에 하던 작업을 이어서 한다
→ 글자 손실 발생
특징
→ StringBuilder는 여러 스레드가 동시에 버퍼를 사용하는 것을 막지 않는다 
→ 다른 스레드가 한 작업을 덮어 쓸 수 있다 
→ Single Thread만이 작업하는 경우에 적합하다
→ StringBuffer에 비해 빠르다
→ ★ "Thread-safe" 하지 않는다
-------------------------------------------------------------------------------------
Thread-Safe
→ 여러 스레드가 동시에 작업하더라도 문제가 발생하지 않도록 조치를 했다
	→ 여러 스레드가 같은 변수의 값을 동시에 변경하려 할 때 한번에 한 스레드만이 작업하도록 제한하는 것
→ 여러 스레드가 동시에 진입해서 명령을 실행하더라도 문제가 발생하지 않는 코드다
	→ 변수의 값을 조회만 하는 코드
-------------------------------------------------------------------------------------
임계 영역(Critical Section)
→ 동기화
→ 다른 스레드가 작업을 하지 못하게 영역을 정해주는 것
→ 하나의 변수를 동시에 변경할려고 하는 코드에 적용
-------------------------------------------------------------------------------------



2023.12.22(금)
-------------------------------------------------------------------------------------
★ String 기타 메소드
String.valueOf(); 메소드
String s2 = String.valueOf(true);
String s4 = String.valueOf(100L); // 100L => "100"
String s7 = String.valueOf('가');
→ 리터럴 값을 문자열로 만들어준다
-------------------------------------------------------------------------------------
String.format(); 메소드
String s1 = String.format("%s,%s,%s,%s,%s", arr[0], arr[1], arr[2], arr[3], arr[4]);
System.out.println(s1);
String s2 = String.format("%s,%s,%s,%s,%s", arr);
System.out.println(s2);
→ 문자열 결합
-------------------------------------------------------------------------------------
String.join(); 메소드
String s3 = String.join(",", arr[0], arr[1], arr[2], arr[3], arr[4]);
System.out.println(s3);
String s4 = String.join(",", arr);
System.out.println(s4);
→ 문자열 사이에 끼워넣기
-------------------------------------------------------------------------------------
Arrays.copyOfRange(); 메소드
String[] arr2 = Arrays.copyOfRange(arr, 2, 4);
for (String s : arr2) {
      System.out.println(s);
}
→ 배열에 특정 범위의 항목을 복사하기
-------------------------------------------------------------------------------------
인스턴스의 부가정보
class A {}
A obj = new A();
→ new 명령어를 쓰면 인스턴스가 최소한 각각의 인스턴스는 클래스 정보를 갖고있다
→ 인스턴스에는 클래스 정보의 링크가 있다 → 크기가 0인 인스턴스는 없다
-------------------------------------------------------------------------------------
다양한 생성자 활용
→ 바이트 배열의 들어있는 코드는 무슨 문자표로 작성했는지 정확하게 알려줘야 한다
→ 그래야 자바의 문자 코드로 제대로 변경할 수 있을 것이다
byte[] bytes3 = {(byte) 0xea, (byte) 0xb0, (byte) 0x80, (byte) 0xea, (byte) 0xb0, (byte) 0x81, 0x61, 0x62, 0x63};
String s7 = new String(bytes3, "utf-8");
System.out.printf("s7=%s\n", s7);
-------------------------------------------------------------------------------------
★ wrapper 클래스
primitive type	---→	wrapper class(java.lang)
byte		---→	Byte
short 		---→	Short
char 		---→ 	Character
int		---→	Integer
long		---→ 	Long
float		---→	Float
double		---→	Double
boolean		---→	Boolean
-------------------------------------------------------------------------------------
class Byte{
	byte value;
	+ 여러 메소드
}
→ primitive type의 값을 캡슐화(감싼다)시켜 메소드를 통해 객체처럼 다룬다 = object 레퍼런스에 저장할 수 있다
→ 랩을 감싼다 = wrapper class
-------------------------------------------------------------------------------------
wrapper class 인스턴스 생성
Byte b = new Byte((byte)100);               // ==> byte
Short s = new Short((short)20000);          // ==> short
Integer i = new Integer(3000000);           // ==> int
Long l = new Long(60000000000L);            // ==> long
Float f = new Float(3.14f);                      // ==> float
Double d = new Double(3.14159);             // ==> double
Boolean bool = new Boolean(true);           // ==> boolean
Character c = new Character((char)0x41);    // ==> char
→ primitive data type의 값을 객체로 주고 받을 때 사용한다.
→ primitive data type의 값을 객체에 담아 전달하고 싶다면
→ deprecated(비난받는, 유지보수가 중단되어, 사용이 권장되지 않는)?
-------------------------------------------------------------------------------------
Wrapper 클래스의 인스턴스를 생성할 때는 생성자 대신 클래스 메서드를 사용하라.
Byte b2 = Byte.valueOf((byte)100);
Short s2 = Short.valueOf((short)20000);
Integer i2 = Integer.valueOf(3000000);
Long l2 = Long.valueOf(60000000000L);
Float f2 = Float.valueOf(3.14f);
Double d2 = Double.valueOf(3.14159);
Boolean bool2 = Boolean.valueOf(true);
Character c2 = Character.valueOf((char)0x41);
→ factory method 패턴과 유사하다
-------------------------------------------------------------------------------------
wapper 클래스는 primitive type의 값을 객체로 다룰 수 있게 해준다.
primitive type에 상관없이 Object 타입의 파라미터로 값을 받을 수 있다.
static void m(Object value) { // 모든 객체를 받을 수 있다.
    System.out.printf("wrapper value=%s\n", value);
}
→ object 인스턴스에 담아서 호출하면 하나의 메소드만 정의하면 된다
-------------------------------------------------------------------------------------
문자열로 꺼내기
Wrapper 클래스도 String 클래스처럼 Object의 toString()을 오버라이딩 했다.
String s1 = obj1.toString(); // Object의 toString()이 아니다. Long에서 오버라이딩한 toString()이다.
String s2 = obj2.toString(); // Object의 toString()이 아니다. Double에서 오버라이딩한 toString()이다.
String s3 = obj3.toString(); // Object의 toString()이 아니다. Boolean에서 오버라이딩한 toString()이다.

다른 진수로 변환하여 문자열로 꺼내기
System.out.println(Long.toHexString(l));
System.out.println(Long.toOctalString(l));
System.out.println(Long.toBinaryString(l));
-------------------------------------------------------------------------------------
★ auto-boxing / auto-unboxing
→ 박싱 / 언박싱은 불편하다 → 오토박싱 / 오토언박싱 → 컴파일러가 코드를 변환한다(자동으로)

박싱 → primitive type의 값을 인스턴스에 담는 것을 박싱이라 부른다
//int ==> Integer
int i1 = 100;
Integer obj1 = Integer.valueOf(i1);
언박싱 → 인스턴스의 담긴 primitive 값을 다시 꺼내는 것을 언박싱이라 부른다
//Integer ==> int
int i2 = obj1.intValue();

오토박싱
// ==> Integer.valueOf(100)
Integer obj = 100; 
→ 컴파일할 때 컴파일러가 코드를 변경한다 
→ 이것이 오토박싱이다
오토언박싱
// int i = obj.intValue();
int i = obj;
→ 컴파일할 때 변환한다
→ 이것이 오토언박싱이다
-------------------------------------------------------------------------------------
java.util.Date 클래스 - 생성자 활용
// Date() 기본 생성자
Date d1 = new Date(); // 현재 시간을 저장한다.
System.out.println(d1);
// Date(long) : 1970-01-01 00:00:00 부터 지금까지 경과된 밀리초
Date d2 = new Date(1000);
System.out.println(d2);
Date d3 = new Date(System.currentTimeMillis());
System.out.println(d3);
Date d4 = new Date(123, 0, 19); → 년은 더할 때는 1900년에 더한다
System.out.println(d4);
// java.sql.Date
java.sql.Date d5 = new java.sql.Date(System.currentTimeMillis());
System.out.println(d5);
// 간접적으로 객체를 생성하기
java.sql.Date d6 = java.sql.Date.valueOf("2023-1-19");
System.out.println(d6);
-------------------------------------------------------------------------------------
Calendar c1;
// 생성자가 있다하더라도 접근 권한이 없으면 호출할 수 없다.
//    c1 = new Calendar(); // 컴파일 오류!

// Calendar는 인스턴스 생성을 도와주는 별도의 클래스 메서드(스태틱 메서드)를 제공한다.
c1 = Calendar.getInstance();
System.out.println(c1.get(1)); // year
System.out.println(c1.get(2) + 1); // month
System.out.println(c1.get(5)); // date
System.out.println(c1.get(10)); // hour
System.out.println(c1.get(9)); // am/pm
System.out.println(c1.get(12)); // minute
System.out.println(c1.get(13)); //seconds

System.out.println(c1.get(Calendar.YEAR));
System.out.println(c1.get(Calendar.MONTH) + 1);
System.out.println(c1.get(Calendar.DATE));
System.out.println(c1.get(Calendar.HOUR));
System.out.println(c1.get(Calendar.AM_PM));
System.out.println(c1.get(Calendar.MINUTE));
System.out.println(c1.get(Calendar.SECOND));
-------------------------------------------------------------------------------------
과제24. Date 클래스를 사용하여 날짜 데이터를 다루기
- java.sql.Date 클래스를 활용하기
-------------------------------------------------------------------------------------
과제25. 예외처리 적용
예외처리 문법
try{
	작업
} catch(Exception e){
		사용자에게 보내는 메시지
}
→ 프로그램이 멈추지 않고 메시지만 뜨고 다음 작업 실행
→ 예외를 보고 받았을 때 처리하지 않으면 상위 호출자에게 예외를 보고한다
-------------------------------------------------------------------------------------
예외 클래스 계층도

Object
	└→Throwable
		└→Error
			└→XxxErroe
		└→Exception
			└→XxxException
-------------------------------------------------------------------------------------



2023.12.26(화)
-------------------------------------------------------------------------------------
예외 상황을 호출자에게 알리는 방법
■■null■null■■null■■
→ get(11) → null
→ 2 인덱스에 저장된 값인지 아니면 유효하지 않은 인덱스라서 실행 오류인지 구분할 수 없다
→ 그래서 리턴 값이 아닌 예외정보를 던진다
① 리턴 값 (indexOf(객체))
→ 객체를 찾았으면 0이상 리턴
→ 객체를 못 찾았으면 -1 리턴
→ 정상적으로 실행된 경우와 오류인 경우를 리턴 값을 구분할 수 있을 때
② 예외 정보 던지기 (get(인덱스))
→ 인덱스가 유효한 경우 → null 또는 객체주소
→ 인덱스가 유효하지 않은 경우 → 예외 정보 throw 던진다
→ 정상적으로 실행된 경우와 오류인 경우를 리턴 값으로 구분할 수 없을 때
③ throw new Throwable("예외 상황 정보"); 
→ throw 예외정보를 담은 객체;
→ java.lang.Throwable 타입
④ 예외 정보 받기 - 예외 처리
try{
	예외정보를 던질 수 있는 코드 실행
} catch (Throwable e){ → 예외 객체를 받을 파라미터
	예외 정보를 받았을 때 실행할 코드
} finally{
	정상적으로 실행되든 예외가 발생하든 간에 무조건 실행되어야 할 코드
}
-------------------------------------------------------------------------------------
예외 객체 타입
Throwable 
	Error → System 예외, JVM 오류
	       → 처리 후 종료해야 한다(unrecover)
	       → Application 외부에서 발생(예 : stackoverflow)
	Exceptrion → Applicatoin 예외(checked 예외)
		  → 처리 후 계속 실행 가능(recover)
		  → Application 내부에서 발생
		  → ★RuntimeException은 메소드 선언부에서 예외타입을 쓰지 않아도 된다 → 컴파일러가 check 하지 않는다 → 과정은 다른 예외와 같다
예외 처리 메소드 선언부 문법
→ Exception 계열은 선언 해줘야하고 Error계열은 선택사항이다
static void m1() throws Exception {
    throw new Exception();
    // OK! 보통 개발자가 사용하는 예외 클래스이다.
}
Exception 계열의 예외를 던지는 메소드를 호출할 때
→ try~catch~ 로 예외를 처리
→ 상위 호출자에서 처리할 것이라고 선언
→ 컴파일러가 검사(check)하기 때문에 둘 중 하나는 반드시 해야한다
-------------------------------------------------------------------------------------
try-with-resources 문법
try{
} finally{
    xxx.close();
}
→ close()를 호출하여 사용한 자원을 해제시키기

→ 
try(close()가 있는 객체 선언){
} finally{ → 생략
}
→ 작성할 필요가 없다
→ 컴파일러가 자동으로 추가
→ java.lang.AutoCloseable 구현체인 경우 
→ 변수 선언만 넣을 수 있다
-------------------------------------------------------------------------------------
예외 클래스의 상속
Exception
	RuntimeException
		IlleagalArgumentException
			NumberFormatException
→ 예외 클래스 계층도에서 서브 클래스의 목적은 기능 확장이 아니다
→ 예외 식별을 용이하게 만들기 위함이다
-------------------------------------------------------------------------------------
과제26. LinkedList 자료구조 구현하기
→ 목록 관리 범용 클래스 LinkedList 정의
  → LinkedList 구동원리 이해 및 구현
  → 중첩 클래스 활용
→ MemberHandler와 BoardHandler에 적용
-------------------------------------------------------------------------------------



2023.12.27(수)
-------------------------------------------------------------------------------------
과제26. LinkedList 자료구조 구현하기
→ 목록 관리 범용 클래스 LinkedList 정의
  → LinkedList 구동원리 이해 및 구현
  → 중첩 클래스 활용
  → 제네릭 적용
→ MenuGroup에 적용
-------------------------------------------------------------------------------------
중첩 클래스(nested class)
LinkedList.java
public class LinkedList{
	void add(){}
	Object toArray(){}
	Object get(){}
	Object set(){}
	void add(int, Object){}
	Object remove(int){}
	boolean remove(E value){}
	private static class Node{}
}
→ 컴파일 하게되면 LinkedList$Node.class    LinkedList.class 로 나뉘어서 컴파일
→ 클래스당 클래스파일 생성
→ 컴파일이 끝난 LinkedList.class에는 Node.class가 없다 개별적으로 파일이 생성된다
→ 클래스 사용 범위를 제약하는 것이다 → 유지보수 쉽게(높은 가독성, 높은 이해도)
-------------------------------------------------------------------------------------



2023.12.28(목)
-------------------------------------------------------------------------------------
삭제할 수 없는 가비지의 문제
→ ? = 늦게 삭제되는

200 300 400 500
aaa, bbb, ccc, ddd,
→ remove(0); → aaa,는 가비지
→ bbb, ccc, ddd,
→ remove(0); → bbb,는 완전한 가비지가 아니다, 200 노드 객체에 300 노드 객체 주소가 있다
→ ccc, ddd,
→ 가비지 컬렉터가 실핼할 때 200 노드가 제거되면 비로소 완전한 가비지가 된다
-------------------------------------------------------------------------------------
인터페이스 활용
예 ①
→ MenuGroup에서 Menu 목록 관리를 LinkedList를 ArrayList로 교체 하려면 사용법이 동일해야 한다
→ 물론 현재 ArrayList나 LinkedList의 메소드를 동일하게 만들었다
→ 동일하게 만들었단 것이지 문법적으로 동일하다는 것은 아니다
결론
→ 문법적으로 객체 사용규칙을 통일시키는 것이 유지보수에 좋다
예 ②
→ BoadAddhandler 에서 ArrayList 대신 LinkedList로 교체 하려면 
→ Handler 클래스를 변겨해야 한다
→ 만약 두 클래스가 동일한 규칙에 따라 작성되었다면 Handler 코드를 변경할 필요가 없다
결론 
→ 두 클래스의 사용법을 통일할 필요가 있다
-------------------------------------------------------------------------------------
List 인터페이스 정의 + 추상 클래스 활용 → 공통 필드 및 메소드 상속
XxxHandler → <<interfave>>List --→ <<abstract>>AbstractList{int size, size(){}}
→ extends → <<concrete>>ArrayList, <<concrete>>LinkedList
-------------------------------------------------------------------------------------
과제26. LinkedList 자료구조 구현하기
→ 목록 관리 범용 클래스 LinkedList 정의
  → LinkedList 구동원리 이해 및 구현
  → 중첩 클래스 활용 : static 중첩 클래스 Node 정의
  → 제네릭 적용
→ MenuGroup에 적용
→ Handler에 적용
  → List 구현체를 생성자를 통해 주입 : DI(Dependency Injection) 적용
→ List 객체 사용 규칙 정의
  → ArrayList, LinkedList에 List 인터페이스 적용
→ AbstractList 추상 클래스 적용
  → ArrayList, LinkedList에 AbstractList 추상 클래스 적용
-------------------------------------------------------------------------------------
Stack (last in first out)
→ BreadCrumb 기능 구현할 때
  → 웹 브라우저에서 방문한 웹페이지 목록
  → 파일 탐색기에서 디렉토리 방문 목록
→ 프로그램에서 호출한 메소드 목록
push → 값 추가
pop → 맨 마지막 값 꺼내기
peek → 맨 마지막 값 조회
empty → 목록의 크기가 0인지 여부 확인
-------------------------------------------------------------------------------------
queue (first in first out)
→ 예약 기능 구현
offer → 값 추가
poll → 맨 처음 값 꺼내기
peek → 맨 처음 값 조회
-------------------------------------------------------------------------------------
과제27. stack, queue 자료구조 구현하기
→ Stack과 Queue의 구동원리 이해 및 구현
→ Stack 적용
  → MenuGroup에 Stack을 이용하여 Breadcrumb구현
→ GoF의 Factory Method 디자인 패턴 적용
  → MenuGroup에 적용
-------------------------------------------------------------------------------------
★ 목록에서 데이터를 꺼내는 방식 캡슐화 하기 (감추기 = 객체로 분리 = ★객체화)
① 기존 방식
→ get(index)
→ HashSet → toArray() → 배열에서 값 꺼냄
→ HashMap, Hashtable → get(key)
→ 자료구조에 따라 데이터를 꺼내는 방식이 다르다
→ 일관성 있는 코딩이 불가하다!!!

② GoF의 Iterator 디자인 패턴
→ 목록에서 직접 꺼내지 않고 값을 꺼내주는 객체를 사용해서 꺼내기 
→ 값을 꺼내주는 객체 사용
→ <<interface>>Iterator{ hasNext(), next() }
→ 값을 꺼내주는 알고리즘을 객체화 하기 = "Iterator" 디자인 패턴
→ 자료구조에 상관없이 일관된 방법으로 
-------------------------------------------------------------------------------------



2023.12.29(금)
-------------------------------------------------------------------------------------
Iterator 구현
① 패키지 멤버 클래스
ArrayList → 사용 → ArrayListIterator ---→ <<interface>>Iterator

② static nested class
ArrayList(){
	<<static>>IteratorImpl ---→ <<interface>>Iterator
}
→ ArrayList 클래스 안에서만 쓰일 클래스라면 ArrayList 클래스 안에 두는 것이 더 직관적이고 유지보수에 더 낫다
→ 이것이 중첩 클래스 문법을 사용하는 이유다!!!

③ non-static nested class
ArrayList(){
	<<non-static>>IteratorImpl ---→ <<interface>>Iterator
}
→ 바깥 클래스의 인스턴스 주소를 받는 코드가 자동으로 추가된다

④ local class
ArrayList(){
	iterator(){
		IteratorImpl ---→ <<interface>>Iterator
	}
}
→ 특정 메소드 안에서만 사용되는 클래스라면 그 메소드 안에 두는 것이 더 직관적이다

⑤ 익명 클래스를 사용한 경우
→ 익명 클래스는 이름이 없기 때문에 정의하는 즉시 바로 인스턴스를 생성해야 한다

⑥ 익명 클래스를 사용한 경우 - 더 간결하게 표현하기
→ return 할 때 생성하면서 리턴
-------------------------------------------------------------------------------------
과제28. Iterator 디자인 패턴을 활용하여 목록 조회 기능을 캡슐화하기
→ GoF의 디자인 패턴 중 Iterator 패턴의 동작원리 이해 및 구현
→ ArrayList, LinkedList, Stack, Queue에 적용
→ 중접 클래스 문법을 이용하여 Iterator 구현하기
  → static/non-static nested 클래스 문법을 활용하는 방법
  → local/anonymous 클래스 문법을 활용하는 방법
-------------------------------------------------------------------------------------
top level class 접근 범위
→ 패키지에 소속된 	클래스
-------------------------------------------------------------------------------------
중첩 클래스 (static nested class)
  → 특정 클래스 안에서만 사용되는 클래스가 있다면 중첩 클래스로 선언하라
  → 즉 노출 범위를 좁히는 것이 유지보수에 좋다
→ non-static class = inner class
  → 바깥 클래스의 인스턴스에 종속되는 클래스 
  → 바깥 클래스의 인스턴스를 사용할 수 있다
  → 바깥 클래스의 인스턴스 없이 생성할 수 없다
→ local class 
  → 특정 메소드 안에서 사용되는 클래스
→ 익명 클래스 (anonymous class)
  → 문법 = 클래스를 정의 하는 문법 + 인스턴스를 만드는 문법
-------------------------------------------------------------------------------------



2024.01.02(화)
-------------------------------------------------------------------------------------
중첩 클래스 문법
// non-static nested class는 바깥 클래스의 인스턴스 주소를 저장할 변수를 갖고 있다
// 예)
// B3 this$0;
// non-static nested class는 바깔 클래스의 인스턴스 주소를 받는 생성자를 갖고있다
// 예)
// X(B3 obj){
// this$0 = obj;}

X obj = this.new X();
→ 아래 코드로 변경될 수 있다
→ ① X obj = new X(this);
→ ② X obj = new X();
  → obj.this$0 = this;

→ 스태틱 멤버는 인스턴스 멤버를 사용할 수 없다 (레퍼런스 변수 선언은 가능)
-------------------------------------------------------------------------------------
import 사용
→ 중첩 클래스를 직접 import 할 수 있다
→ import가 하는 일은 클래스를 로딩하는 것이 아니다
→ 컴파일러에게 클래스의 위치를 알려주는 것이다
-------------------------------------------------------------------------------------
inner class 바깥 클래스의 인스턴스를 보관할 this 변수와 생성자
→ 컴파일러는 모든 생성자에 바깥 클래스의 객체 주소를 받는 파라미터를 추가한다
X() {}
→ X(F arg0) {}
X(int a) {}
→ X(F arg0, int a) {}
X(String s, int a) {}
→ X(F arg0, String s, int a) {}
-------------------------------------------------------------------------------------
local class 
→ 메소드 안에 정의하는 클래스
→ 특정 메소드 안에서만 사용되는 경우 로컬 클래스로 정의한다
→ 메소드를 호출할 때 클래스가 정의된다는 뜻이다
-------------------------------------------------------------------------------------
인스턴스 메소드와 로컬 클래스
→ 인스턴스 메소드는 C 인스턴스 주소를 this 변수에 저장한다
→ 그래서 인스턴스 메소드 안에 정의된 로컬 클래스는 바깥 클래스의 인스턴스를 사용할 수 이싿
스태틱 메소드와 로컬 클래스
→ 스태틱 메소드는 C2 인스턴스 주소를 저장할 this라는 변수가 없다
→ 그래서 인스턴스 바깥 클래스의 인스턴스를 사용할 수 없다
-------------------------------------------------------------------------------------
local class에서 바깥 메소드의 로컬 변수 접근

① 로컬 클래스에서 메소드의 파라미터 값을 사용한다면
// 컴파일러는 로컬 클래스를 컴파일할 때
// 파라미터 값을 저장할 수 있도록 관련 코드를 자동으로 추가한다
// 따라서 create1()의 경우처럼 개발자가 직접 코드를 추가할 필요가 없다
// 예)
// float interest;
//
// CalculatorImpl(float interest){
// this.interest = interest;
// }

② interest는 create2() 함수의 로컬 변수이다
// CalculatorImpl 객체를 생성하여 리턴한 후에는 interest 로컬 변수는 스택에서 사라진 상태일 것이다
// 나중에 compute()를 호출할 때 intersest 변수는 없을텐데, 어떻게 된 것인가?
// => 로컬 클래스에서 바깥 메소드(enclosing method)의 로컬 변수를 사용한다면
//      컴파일러는 로컬 클래스에 바깥 메소드의 로컬 변수 값을 저장할 필드를 추가한다
//      또한 로컬 클래스의 객체를 생성할 때 생성자에 로컬 변수의 값을 넘겨 줄 것이다

this 를 생략하면 다음 순서로 변수를 찾는다.
1) 로컬 변수
2) 인스턴스 변수
3) 메서드에 선언된 로컬 변수
4) 바깥 클래스의 인스턴스 변수 또는 스태틱 변수

로컬 클래스에서 메소드에 선언된 로컬 변수 접근하기
- 상수 값이거나 상수에 준하는 경우(값을 한 번만 할당한 경우)
   로컬 클래스에서 메서드의 로컬 변수를 사용할 수 있다.
- 즉 로컬 클래스에서 바깥 메서드의 로컬 변수를 사용하는 상황?
   값을 조회하는 용도할 때.
- 왜?
   로컬 객체가 사용하는 로컬 변수는
   메서드 호출이 끝났을 때 제거되기 때문이다.
-------------------------------------------------------------------------------------
★ HelloWorld bytecode로 작성하기
cafebabe 0000 0034 0000 0021 0000 0000 0000 0000 0000 0000
ClassFile {
    4 bytes        Java Magic Number
    2 bytes        Minor Version
    2 bytes        Major Version
    2 bytes        Size of the constant pool
    * bytes        Numerous bytes making up the constant pool
    2 bytes        This class' access modifiers (Ie. public)
    2 bytes        Index of this class in constant pool
    2 bytes        Index of this class' super class in constant pool
    2 bytes        Number of interfaces
    * bytes        Numerous bytes making up interface definitions
    2 bytes        Number of fields in this class
    * bytes        Numerous bytes making up field definitions
    2 bytes        Number of methods in this class
    * bytes        Numerous bytes making up method definitions
    2 bytes        Attributes count ( meta data for class file )
    * bytes        Numerous bytes making up attribute definitions
}

Java File: CAFE BABE
Version 8: 0000 0034
Constant Pool Size of ZERO: 0000
Super Public: 0021
Unknown index of class in constant pool: 0000
Unknown index of super class in constant pool: 0000
zero interfaces: 0000
zero fields: 0000
zero methods: 0000
zero attributes: 0000

참고자료
https://medium.com/@davethomas_9528/writing-hello-world-in-java-byte-code-34f75428e0ad
-------------------------------------------------------------------------------------
anonymous class

인터페이스의 경우 static으로 선언하지 않아도 스태틱 멤버에서 사용할 수 있다.
→ 인터페이스는 규칙을 정의한 것이기 때문에 인스턴스 멤버라는 개념이 존재하지 않는다.

1) 로컬 클래스로 인터페이스 구현하기
    class My implements A {
      String name = "홍길동";

      @Override
      public void print() {
        System.out.printf("Hello, %s!\n", this.name);
      }
    }

2) non-static 중첩 클래스 사용? 불가능
    class X obj = new X();

3) static 중첩 클래스 사용 가능
    Y obj = new Y(); 
-------------------------------------------------------------------------------------
anonymous class 생성자
1) 익명 클래스는 생성자를 직접 정의할 수 없다.
- 그러나 컴파일러가 컴파일할 때 익명 클래스의 생성자(수퍼 클래스, 인터페이스)를 만든다.

2) 대신 인스턴스 블록으로 생성자를 대신한다.
- 인스턴스 블록에 작성한 코드는
  결국 컴파일러가 자동 생성한 생성자에 들어간다.
- 그래서 인스턴스 블록에 작성한 코드가 실행될 것이다.

3) 물론 그전에 먼저 수퍼 클래스의 생성자가 실행될 것이다

4) 주로 인터페이스나 추상 클래스의 인스턴스를 생성 할 때 사용한다
-------------------------------------------------------------------------------------



2024.01.03(수)
-------------------------------------------------------------------------------------
과제29. 기존의 컬렉션 클래스 및 인터페이스를 자바 컬렉션 API로 교체하기
→ java.util 패키지에서 제공하는 컬렉션 API로 교체
-------------------------------------------------------------------------------------
과제30. 리팩토링 : App 클래스
→ main() 메소드에 들어있는 코드를 기능에 따라 묶어 여러 메소드로 분리
→ 공유하는 변수는 인스턴스 필드로 전환
-------------------------------------------------------------------------------------
과제31. File I/O API를 이용하여 데이터를 바이너리 형식으로 입출력하기
→ FileInputStream/FileOutputStream 사용법
→ 바이너리 형식으로 데이터를 입출력하는 방법
→ 파일 저장/로딩 메소드 추가
-------------------------------------------------------------------------------------
데이터를 파일에 저장하기

① 기존 방식
사용자 → 입력 → APP → add → List(memory)
→ 프로그램을 종료하면 메모리에 저장된 데이터를 해제한다
→ 다시 APP 실행하더라도 기존 데이터를 가져올 수 없다

② 개선 방식
사용자 → 입력 → APP → add → List(memory) ↔ 저장 로딩 ↔ 파일
→ APP을 종료할 때 List에 보관된 데이터를 파일에 저장 
→ APP을 실행할 때 파일에 저장된 data를 List에 읽어들인다
→ List구현체 → get → <<java.io>>FileOutputStream → write → 파일 → read → <<java.io>>FileIntputStream →  
-------------------------------------------------------------------------------------
과제 32. primitive Type/String byte 출력
- FileInputStream/FileOutputStream 사용법
- 바이너리 형식으로 데이터를 입출력하는 방법
-------------------------------------------------------------------------------------



2024.01.03(목)
-------------------------------------------------------------------------------------
과제 33. 입출력 성능을 높이기 위해 버퍼 기능 추가하기
- 기존의 클래스에 버퍼 기능을 추가한다.
  - BufferedDataInputStream = DataInputStream + 버퍼 기능
  - BufferedDataOutputStream = DataOutputStream + 버퍼 기능
-------------------------------------------------------------------------------------
버퍼 사용하기
① 기존 방식
write() → HDD → read()
→ read/write = data seek time + read/write time
→ 데이터를 읽고 쓸 위치를 찾는데 걸리는 시간이 많이 소요
② 개선 방식
write() → 버퍼 → 버퍼가 꽉 차면 출력 → HDD → 버퍼 → 버퍼가 비었으면 읽기 → read()
→ read/write 횟수(시간) 감소 = data seek time 감소
-------------------------------------------------------------------------------------
버퍼 기능 추가
FileOutputStream{write(int), wrtie(byte[]), ....} 
→ extends → Dataoutput{writeShort(), writeInt(), writeLong(), writeBoolean(), writeUTF(), ....}
→ extends → BufferedDataOutputStream{buf : byte[], write(int), write(byte[]), }
-------------------------------------------------------------------------------------
과제 34. Decorator 패턴
① 상속을 이용한 기능 확장 방식의 문제점
FileInputStream{} → extends → DataInputStream{byte 데이터 → primitive data type, String으로 변환} → extends → BufferedDataInputStream{버퍼 기능}
→ BufferedFileInpuStream에 있는 버퍼 기능이랑 중복
→ 상속을 이용해 다양한 기능을 추가시키다보면 다양한 조합의 서브 클래스들이 대량으로 생성되는 문제
→ 서브 클래스 끼리 기능이 중복되는 문제가 발생할 수 있다
② 위임과 포함을 이용한 기능 확장
InputStream → extends → FileInputStream(말단 component)
		      → ByteArrayInputStream(말단 component)
		      → PipedInputStream(말단 component)
                 → extends → FilterInputStream(중간 부품=Decorator) →InputStream을 사용
				→ extends → BufferedInputStream(중간 부품=Decorator)
					  → DataInputStream(중간 부품=Decorator)
 					  → CipherInputStream(중간 부품=Decorator)
-------------------------------------------------------------------------------------
예1 )파일 읽기 기본 기능
FileInputStream 사용
FileInputstream in = new FileInputStream(" ");
in.read();
예2 )파일 읽기 + 버퍼
FileInputStream과 BufferedInputStream을 연결해서 사용
FileInputstream in = new FileInputStream(" ");
BufferedInputStream in2 = new Bufferedinput(in);
in2.read();
예3 )
파일 읽기 + 버퍼 + 데이터 가공
FileInputStream과 BufferedInputStream, DataInputStream 과 연결해서 사용
FileInputstream in = new FileInputStream(" ");
BufferedInputStream in2 = new Bufferedinput(in);
DataInputStream in3 = new DataInputStream(in2);
in3.read();
-------------------------------------------------------------------------------------



2024.01.05(금)
-------------------------------------------------------------------------------------
★ 과제 35. 인스턴스를 통째로 입출력하기 = 객체 직렬화(serialize)
- ObjectInputStream/ObjectOutputStream 사용법
  - java.io.Serializable 인터페이스 사용법
  - transient modifier 사용법
-------------------------------------------------------------------------------------
★ 객체 직렬화(serialize)
인스턴스 → serialize → bytes[]
bytes[] → (deserialize=unmarshaling) → 인스턴스
class → new 인스턴스 → ObjectOuputStream → ★ bytes[](인스턴스 변수, 클래스 정보) 배열로 내보낼 수 있다
bytes[] → ObjectInputStream → 인스턴스
-------------------------------------------------------------------------------------
★ character Stream
utf8 → utf16-BE로 변환
→ utf8로 변환된 16진수를 1byte씩 읽는다
→ 1byte씩 읽다가 한글을 읽게되면 3byte를 읽는다
→ 1byte씩 읽다가 영어를 읽게되면 2byte로 변환한다
AB가각
→ 41 42 ea b0 80 ea b0 81 
→ 0041 0042 ac00 ac01 
→ file.encoding = utf-8(JVM 환경변수)
→ FileReader는 file.encoding에 설정된 문자 집합으로 간주하고 읽는다
→ file.encoding에 따라서 utf-16BE로 변환하는데 다른 인코딩 방식으로 된 문자열을 읽으면 변환 되었을 때 문자열이 다르게 나올 수도 있다
→ file.encoding에 설정된 문자집합으로 변환해서 출력, 입력
-------------------------------------------------------------------------------------
과제 36. 리팩토링
- 데이터 읽고 쓰는 코드가 중복된 것을 정리
  - loadAssignment(){}, loadMember ...., savaassignment(){}, saveMember(){} ..... 
    → <e> list<E> loadData(String filepath){}
      → 메소드를 호출할 때 타입 E가 무엇인지 결정된다 → 리턴 값을 받을 변수의 정보를 보고 결정한다
    → void savaData(String filepath, List<?> datalist){}
      → List에 어떤 타입의 값이 저장됐는지 상관 없다는 뜻
- SerialVersionUID → 용도? 출력된 데이터의 유효성 검사
    → 클래스 → 인스턴스 생성 → ObjectOutputStream → write(serialize) → 파일(클래스 정보, 인스턴스 값, 버전)
        → java.io.Sereializable 구현 클래스에 자동 추가되는 스태틱 필드
        → 클래스 만들 때 serialVersionUID 개발자가 추가하지 않으면, 컴파일러가 자동으로 추가한다
        → 개발자가 값을 지정하지 않으면 컴파일러가 필드와 메소드 정보를 바탕으로 자동생성 한다
    → 파일(클래스 정보, 인스턴스 값, 버전) → read(deserialize) → ObjectInputStream → 클래스 정보를 가지고 인스턴스 생성
    → 인스턴스를 만들 때 버전과 클래스 정보가 일치해야 한다
-------------------------------------------------------------------------------------
serialVersionUID의 활용
(정상)
new Member 인스턴스 생성(100번) → ObjectOutputStream → 파일(Member, 100번, data) → ObjectInputStream → new Member 인스턴스 생성(100번)
→ OK 
→ 저장할 때 사용한 Member 클래스의 버전이 100번이고 읽을 때 사용한 Member 클래스의 버전이 100번으로 동일하다
(오류)
new Member 인스턴스 생성(100번) → ObjectOutputStream → 파일(Member, 100번, data) → ObjectInputStream → new Member 인스턴스 생성(101번)
→ 오류!
→ Member에 필드나 메소드를 추가, 변경한 수 컴파일 하면 버전 번호가 바뀐다
→ 저장할 때 사용한 Member의 버전과 읽을 때 사용한 Member의 버전이 다르다!!!!!!!!!!!!!!!!
(해결책)
→ 개발자가 직접 버전을 지정한다(100번)
→ 필드나 메소드가 변경되더라도 개발자가 판단하기에 기존 방식으로 읽어도 상관없다면 번호를 그대로 유지한다
→ 개발자가 클래스의 SerialVersion을 직접 지정하는 방법은? → SerialVersionUID 스태틱 변수를 명시적으로 추가하라!!!
-------------------------------------------------------------------------------------
과제 37. character I/O Stream API를 사용하여 CSV 텍스트 형식으로 입출력하기
- CSV 형식으로 데이터를 읽고 쓰는 법
- FileReader/FileWriter 사용법
-------------------------------------------------------------------------------------
CSV(★ Comma Separated value ★) 형식으로 I/O
List<Board> : Board Board Board Board ....
→ toCsvString() → Board 객체 읽어오기 → return → 제목, 내용, 작성자, 작성날짜 → write → 파일에 저장
-------------------------------------------------------------------------------------
toCsvString() 규칙 정의
<<interface>>CsvString{ toCsvString() }
→ Board, Member, Assignment 클래스 구현
→ 데이터의 구조를 잘 알고 있는 도메인 객체(vo, DTO)가 CSV 문자열을 만들게 한다
→ GRASP 패턴의 Information Expert
-------------------------------------------------------------------------------------
deserialize와 serialVersionUID
파일(클래스 정보, 인스턴스 변수 값, serialVersionUID)
→ read(=deserialize) → ObjectInputStream → 클래스 정보와 serialVersionUID를 이용해서 new 인스턴스 생성
→ deserialize할 때 버전 일치 여부를 검사한다 다르면 예외 발생 !!!
-------------------------------------------------------------------------------------



2024.01.08(월)
-------------------------------------------------------------------------------------
과제 38. JSON 형식으로 읽고/쓰기
→ Gson(google gson) 라이브러리 사용법
JSON → javascript 객체 리터럴 표기형식 모방 → JavaScript Object Notation
javascript 형식
{
  title : "제목",
  'content' : "내용",
  "deadline" : "2023-01-01"
}
JSON 형식(예: property 명은 무조건 "문자열" = "문자열)
{
  "title" : "제목",
  "content" : "내용",
  "deadline" : "2023-01-01"
}
→ XML 처럼 구조적인 데이터를 표현하기 쉽다
→ XML tag처럼 데이터를 구분하는 메타데이터가 있다
→ text 형식으로 프로그램 언어간에 주고 받기 쉽다
→ 그래서 Open API에서 많이 사용한다
-------------------------------------------------------------------------------------
gson 사용방법
1) 객체 준비
    Member m = new Member();
    m.setNo(100);
    m.setName("홍길동");
    m.setEmail("hong@test.com");
    m.setPassword("1111");
    m.setPhoto("hong.gif");
    m.setTel("010-2222-1111");
    m.setRegisteredDate(new Date(System.currentTimeMillis()));

2) JSON 처리 객체 준비
    Gson gson = new Gson();

3) 객체의 값을 JSON 문자열로 얻기
    String jsonStr = gson.toJson(m);

    System.out.println(jsonStr);
-------------------------------------------------------------------------------------
★ gson vs jackson
→ gson은 필드명으로 객체화(serialize, deserialize)하고
→ jackson은 getter, setter 프로퍼티명으로 객체화 한다
→ java.sql.Date 날짜 값도 다르게 저장된다
→ 각 쓰고 읽는 법이 정해져 있다
→ Gson 과 달리 JSON 프로퍼티에 해당하는 객체 프로퍼티가 없다면 예외가 발생한다.
→ @JsonIgnoreProperties 애노테이션을 사용하여 JSON 프로퍼티 중에서 무시할 항목을 지정해야 한다.
→ @JsonIgnoreProperties(value = {"name", "email", "password", "photo", "tel"})
-------------------------------------------------------------------------------------
GoF의 Builder 패턴
→ 복합 객체의 생성 과정을 캡슐화한다
① 일반적
Gson gson = new Gson();

② Builder 패턴
GsonBuilder builder = new GsonBuilder();
builder.setDateFormat("yyyy-MM-dd");
Gson gson = builder.create();
→ Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();
→ 객체 생성에 필요한 옵션 설정 후 객체 생성
→ 여러 객체를 조립해서 만들어야 하는 경우 복잡한 객체 생성 과정을 감추기 위해 외부 객체(Builder)에 의뢰해서 객체를 얻는 기법
-------------------------------------------------------------------------------------
Gson과 Jsonserializer 어댑터
Gson ◇→ JsonSerializer<Date>
        ◇→ JsonSerializer<school>
registertypeAdapter(타입, 어댑터) 호출 
→ GsonBuilder → Gson 생성
	        → Gson 객체에 어댑터 장착
-------------------------------------------------------------------------------------
Gson 동작 방식
인스턴스를 toJson()으로 전달
Gson ◇→ GsonDateFormatAdapter
        ◇→ GsonSchollformatAdapter
        ◇→ primitiveType/String Adapter(기본 타입 어댑터)

toJson() 동작 방식
필드 값 → toJson() → Gson → serialize() → GsonDateFormatAdapter
                                     → serialize() → GsonSchoolFormatAdapter
→ 각 타입에 맞는 포멧 어댑터를 호출 후 Json 문자열 생성
-------------------------------------------------------------------------------------




2024.01.09(화)
-------------------------------------------------------------------------------------
Lambda 문법 - 익명 클래스 vs 람다
<<interface>>
interface Player{
  void play();
}
// 익명 클래스로 인터페이스 구현하기
Player p1 = new Player() {
  @Override
  public void play() {
    System.out.println("익명 클래스");
  }
};
p1.play();

// 람다 문법으로 인터페이스 구현하기
// => 메서드 한 개짜리 인터페이스를 좀 더 간결하게 구현하기 위해 만든 문법이다.
// => 뻔한 코드 생략!
Player p2 = () -> System.out.println("익명 클래스");
p2.play();
-------------------------------------------------------------------------------------
람다 문법 연습
// 1) 한 문장일 때는 중괄호를 생략할 수 있다.
Player p1 = () -> System.out.println("테스트1");
p1.play();

// 2) 물론 중괄호를 명확히 적어도 된다.
Player p2 = () -> {
  System.out.println("테스트2");
};
p2.play();
// => 파라미터가 없다고 괄호를 생략할 수는 없다.
// Player p3 = -> System.out.println("테스트3"); // 컴파일 오류!
-------------------------------------------------------------------------------------
파라미터가 있는 람다 문법 연습
1) 파라미터는 괄호() 안에 선언한다.
Player p1 = (String name) -> System.out.println(name + " 님 환영합니다.");
p1.play("홍길동");

// 2) 파라미터 타입을 생략할 수 있다.
Player p2 = (name) -> System.out.println(name + " 님 환영합니다.");
p2.play("홍길동");

// 3) 파라미터가 한 개일 때는 괄호도 생략할 수 있다.
Player p3 = name -> System.out.println(name + " 님 환영합니다.");
p3.play("홍길동");
-------------------------------------------------------------------------------------
파라미터가 2개 이상 있는 람다 문법 연습
// 1) 파라미터는 괄호() 안에 선언한다.
Player p1 = (String name, int age) -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
p1.play("홍길동", 20);

// 2) 파라미터 타입을 생략할 수 있다.
Player p2 = (name, age) -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
p2.play("임꺽정", 30);

// 3) 파라미터가 여러 개일 때는 괄호를 생략할 수 없다.
//    Player p3 = name, age -> System.out.printf("%s(%d)님 환영합니다.\n", name, age);
//    p3.play("임꺽정", 30);
-------------------------------------------------------------------------------------
리턴 타입이 있는 람다 문법 연습
// 1) 리턴 값은 return 명령을 사용하여 처리한다.
Calculator c1 = (a, b) -> {
  return a + b;
};
System.out.println(c1.compute(10, 20));

// 2) 한 문장으로 된 표현식(=값을 리턴하는 한 문장의 코드)인 경우 괄호 생략할 수 있다.
// => 문장은 문장인데 값을 리턴하는 문장을 '표현식(expression)' 이라 부른다.
// => 단 괄호를 생략할 때 return 키워드도 생략해야 한다. 있으면 컴파일 오류!
Calculator c2 = (a, b) -> a + b;
System.out.println(c2.compute(10, 20));

// Math.max()는 int 값을 리턴한다. 그래서 이 메서드를 호출하는 문장은 표현식이다.
Calculator c3 = (a, b) -> Math.max(a, b);
System.out.println(c3.compute(10, 20));

// 값을 리턴해야 하는데 람다 문장에서 값을 리턴하지 않으면 컴파일 오류!
// Calculator c4 = (a, b) -> System.out.println(a + ",", b); // 컴파일 오류!
// System.out.println(c4.compute(10, 20));
-------------------------------------------------------------------------------------
★ 람다 문법 주의사항 ★ 
// 추상 메서드가 한 개짜리 인터페이스여야 한다.
// 추상 메서드가 두 개 이상이면 람다 문법으로 구현할 수 없다.
// 여러 개의 메서드가 있다 하더라도 추상 메서드가 한 개이면 된다.
// static 메서드나 default 메서드가 몇개이든 그 개수는 중요하지 않다.
// 추상 메서드가 한 개이면 람다 문법을 사용할 수 있다.
Player p = () -> System.out.println("Player...");
p.play();
// 인터페이스가 아닌 추상 클래스는 람다 구현의 대상이 아니다!
-------------------------------------------------------------------------------------
스태틱 메소드 레퍼런스(참조)
메소드 한 개짜리 인터페이스의 구현체를 만들 때
// MyCalculator의 스태틱 메서드인 plus()를 가지고 구현체를 자동 생성!
Calculator c1 = MyCalculator::plus; 
→ 컴파일러는 위 코드를 다음의 람다 코드로 변환한다
→ Calculator c1 = (x, y) -> MyCalculator.plus(x, y);
→ 즉 다음의 익명 클래스와 같다
//    Calculator c = new Calculator() {
//      @Override
//      public int compute(int x, int y) {
//        return MyCalculator.plus(x, y);
//      }
//    };
-------------------------------------------------------------------------------------
★ 메서드 레퍼런스를 지정할 때 리턴 타입의 규칙 ★
// 1) 같은 리턴 타입
// 2) 암시적 형변환 가능한 타입
// 3) auto-boxing 가능한 타입
// 4) void
결론,
// 메서드 레퍼런스가 가리키는 실제 메서드를 호출한 후
// 그 메서드가 리턴한 값이
// 인터페이스에 정의된 메서드의 리턴 값으로 사용할 수 있다면
// 문제가 없다.
-------------------------------------------------------------------------------------
인스턴스 메소드 레퍼런스 활용
// interface Predicate<T>{
// boolean test (T value);
// ...
// }
Predicate<My> p3 = My::m; // OK!
// 타입 파라미터의 클래스가 인스턴스 메소드의 클래스랑 같다면,
// 다음과 같이 람다 문법으로 변경된다
// => Predicate<My> p3 = (My value) -> {return value.m();};
p3.test(new My());
-------------------------------------------------------------------------------------
생성자 레퍼런스
Calculator c1 = Player::new;
-------------------------------------------------------------------------------------



2024.01.10(수)
-------------------------------------------------------------------------------------
I18N(Internationalization) 과 L10N(Localization)
기존 방식(한국어 버전)
System.out.printf("제목 : %s\n", title)
→ 나라별 언어마다 프로그램을 짜야한다
다국어 지원
System.out.printf("%s:%s\n", prop.get("title"), title);
→ 사용자가 선호하는 언어로 라벨을 출력
→ xxx.properties, xxx.xml 등 파일에서 특정 언어로 작성된 라벨을 읽어온다
→ %s를 통해서 값만 주고 받으면 유연해진다

→ 다른 언어로 라벨을 교체할 수 있도록 프로그래밍 하는 것 = "I18N 지원"
→ 특정 국가의 특정 언어로 라벨을 작성하는 것 = "L10N 지원"
→ 지역화는 프로그래밍이 아니다
-------------------------------------------------------------------------------------
★ 운영체제에서 환경변수 값 갖고 오기
userCountry = System.getProperty("user.country");
userLanguage = System.getProperty("user.language");
Properties props = System.getProperties();
→ 기본 값은 US, en으로 되어있다
→ 사용자에 맞는 값은 보통 xml 파일로 만든다
-------------------------------------------------------------------------------------
메소드 제네릭 
→ 즉 What이 무슨 타입인지는 메서드가 호출될 때 넘겨주는 파라미터로 결정된다.
→ 제네릭을 사용하면 특정 타입을 다루는 메서드 여러 개를 한 개의 메서드로 줄일 수 있다.
→ 이때 "What"을 가리키는 용어로 "타입(이름을 받는) 파라미터"라고 부른다.
<다루는_타입_별명> 다루는_타입_별명 메서드명(다루는_타입_별명 파라미터, ...) {...}
예) <What> What test(What obj) {...}
→ What = 타입 파라미터(type parameter)
→ 대문자로 시작하지만 클래스와 헷갈릴 수 있다 그래서 한 글자로 많이 표현한다
→ 보통 긴 이름을 사용하지 않고 다음과 같이 한 개의 대문자로 된 이름을 많이 사용한다
// T - Type이라는 의미를 표현할 수 있어 많이 사용하는 이름이다.
// E - Element라는 의미로 목록의 항목을 가리킬 때 사용한다.
// K - Key 객체를 가리킬 때 사용한다.
// N - Number의 의미로 숫자 타입을 가리킬 때 주로 사용한다.
// V - Value의 의미로 값의 타입을 가리킬 때 사용한다.
// S,U,V 등 - 한 번에 여러 타입을 가리킬 때 두 번째, 세 번째, 네 번째 이름으로 주로 사용한다.
-------------------------------------------------------------------------------------
클래스 제네릭
→ 범용적인 클래스를 만드는 문법
static class Box<T> {
    T value; 
    public T get() {return this.value;}
    public void set(T value) {this.value = value;}
}
Box<Member> b1 = new Box<>();
Box<String> b2 = new Box<>();
Box<Integer> b3 = new Box<>();

b1.set(new Member("홍길동", 20));
b2.set("Hello");
b3.set(100);

Member v1 = b1.get();
→ 제네릭은 컴파일할 때 적합한지 검사하는 용도이다, 컴파일이 끝나면 제네릭은 사라진다
→ 제네릭을 설정해도 Object 클래스로 주고 받는다
→ 제네릭을 설정하지 않으면 Object로 설정한다
-------------------------------------------------------------------------------------
여러 개 제네릭 설정
 A<String,Integer,Member> obj = new A<>();
class A2<T,S,U> {
  T v1;
  S v2;
  U v3;
}
→ 제네릭도 변수라서 이름을 마음대로 지어도 되지만 통상적으로 이렇게 T, S, U 이렇게 설정한다
-------------------------------------------------------------------------------------
제네릭 배열 생성하기
// 예1) new 명령어는 컴파일 오류

★ 예2) 견본 배열을 받아서 복제하는 방법을 사용한다.
static <T> T[] create2(T[] arr) {
    // copyOf(original, newLength)
    // => 원래 배열(original)과 같은 타입의 배열을 배열크기(newLength)에 맞춰 새로 생성한다.
    return Arrays.copyOf(arr, 10);
}
// 예3) 배열의 타입 정보를 받아 생성하기
  @SuppressWarnings("unchecked")
  static <T> T[] create3(Class<?> type) {
    return (T[]) Array.newInstance(type, 10);
}

// 예4) 견본 배열에서 타입 정보를 추출하여 배열을 생성하기
  @SuppressWarnings("unchecked")
  static <T> T[] create4(T[] arr) {
    Class<?> arrayTypeInfo = arr.getClass(); // 예) String[]
    System.out.println(arrayTypeInfo);

    Class<?> arrayItemTypeInfo = arrayTypeInfo.getComponentType(); // 예) String
    System.out.println(arrayItemTypeInfo);

    return (T[]) Array.newInstance(arrayItemTypeInfo, 10);
}
-------------------------------------------------------------------------------------
파라미터 타입 레퍼런스와 인스턴스 - extends
static class A {}
static class B1 extends A {}
static class B2 extends A {}
static class C extends B1 {}
  /*
   *   Object
   *     |
   *     A
   *    / \
   *   B1 B2
   *   |
   *   C
   */

ArrayList<A> list1;
//    list1 = new ArrayList(); // 이렇게 사용하지 말고, 명확히 제네릭의 타입을 지정하라.
//    list1 = new ArrayList<Object>(); // 컴파일 오류!
list1 = new ArrayList<A>();
list1 = new ArrayList<>(); // 생략하면 레퍼런스와 같은 제네릭 타입이 된다.
//    list1 = new ArrayList<B1>(); // 컴파일 오류!
//    list1 = new ArrayList<B2>(); // 컴파일 오류!
//    list1 = new ArrayList<C>(); // 컴파일 오류!

list1.add(new B2()); // OK! → 컴파일러는 레퍼런스의 형식을 따져서 문법의 옳고 그름을 판단한다

→ 제네릭은 서브 클래스든 수퍼 클래스든 제네릭으로 설정한 객체 타입만 가능하다
→ 서브 클래스를 가르키고 싶다면 <? extends B1> 이런식으로 제네릭을 설정해야한다
→ 수퍼 클래스를 가르키고 싶다면 <? super B1> 이렇게 한다면 B1 타입과 B1의 수퍼 클래스 타입도 가르킬 수 있다
package com.eomcs.generic.ex02 참조
-------------------------------------------------------------------------------------
애노테이션 사용
//=> 클래스, 필드, 메서드, 로컬 변수 선언에 붙이는 특별한 주석이다.
//=> 다른 주석과 달리 컴파일이나 실행할 때 추출할 수 있다.
//=> 애노테이션 문법이 도입되기 전에 
//   일반 주석에 특별한 문법을 포함시켜 사용했던 doclet 이라는 기술이 있었다.
//=> 일반 주석과 달리 '프로퍼티명=값' 형태로 값을 다룰 수 있다.
//=> 사용법
//   - 애노테이션 정의 또는 기존에 정의된 애노테이션 사용
//   - 클래스나 인터페이스에 적용
//=> .class 파일에 포함된 애노테이션을 확인하라!
-------------------------------------------------------------------------------------
애노테인션 활용
→ 소스파일에서 애노테이션 정보를 읽어서 새 소스파일이나 설정 파일을 생성한다
→ 컴파일러가 컴파일할 때 애노테이션에 설정된 정보를 참고하여 컴파일을 수행한다
예) lombok 라이브러리 @Data @Getter @Setter
→ JVM이 .class 파일에 들어있는 애노테이션 정보를 참고하여 Application을 실행한다
예) @JsonFormat
→ public @interface MyAnnotation2{String value();}
→ 명사(명사구)로 이름을 짓는다
→ 값을 꺼낼 때 메소드 호출로 꺼낸다
-------------------------------------------------------------------------------------
애노테이션 유지 정책
@소스, @클래스, @런타임 → 컴파일 → .class → 실행 → JVM(Method Area) → 로딩
→ @소스는 날라가고 @클래스, @런타임 만 .class에 남는다
→ 실행하면 JVM에 Method Area 메모리 영역에 @클래스는 차단 당하고 @런타임만 남는다
→ ★ @Retention 사용 

@Retention(value=RetentionPolicy.CLASS)
public @interface MyAnnotation {
  String value();
}

@Retention(value=RetentionPolicy.CLASS)
@Retention(value=RetentionPolicy.SOURCE)
@Retention(value=RetentionPolicy.RUNTIME)
//애노테이션 유지 범위
//1) SOURCE :  소스 파일에만 남긴다. *.class 파일에 포함 안됨. 즉 컴파일할 때 제거된다.
//2) CLASS (기본) : .class 파일에 포함. 실행할 때 로딩 안됨.
//3) RUNTIME : .class 파일에 포함. 실행할 때도 메모리에 로딩됨. 실행 시에 추출할 수 있다.

// 클래스 정보 객체로부터 애노테이션 정보 추출
Class<?> clazz = MyClass.class; 
→ 클래스 정보를 다루는 객체

// => 유지정책 : RUNTIME
MyAnnotation3 obj3 = clazz.getAnnotation(MyAnnotation3.class);
if (obj3 == null) {
  System.out.println("MyAnnotation3를 추출할 수 없습니다!");
  } else {
  System.out.println("MyAnnotation3.value=" + obj3.value());
}
→ 애노테이션 정보를 가져와서 value 값을 꺼낸다
→ 애노테이션 정보는 RUNTIME만 꺼낼 수 있다

public @interface MyAnnotation2 {
  String value() default "홍길동";
  // default 값이 있으면,
  // 애노테이션을 사용할 때 값을 지정하지 않아도 된다.
}
→ value 값을 지정해도 된다

@MyAnnotation("홍길동") // OK! 'value' 라는 이름을 가진 프로퍼티는 이름 생략 가능!

// 배열 프로퍼티의 기본 값을 지정할 때 중괄호를 사용한다.
String[] v1() default {"가나다","라마바"};
int[] v2() default {100, 200, 300};
float[] v3() default {3.14f, 4.14f, 5.14f, 6.14f};

클래스 위에 선언
@MyAnnotation3(
    // 배열 값을 지정할 때 중괄호를 사용한다.
    v1 = {"홍길동", "임꺽정", "유관순"},
    v2 = {1000, 2000, 3000, 4000, 5000},
    v3 = {1.12f, 2.23f, 3, 34f})
public class MyClass4 {
}
-------------------------------------------------------------------------------------
애노테이션 적용 범위
클래스나 인터페이스
★ @Target을 사용하여 애노테이션을 붙일 수 있는 범위를 제어할 수 있다.
// @Target(value = {ElementType.TYPE})  // 클래스나 인터페이스 선언에만 붙일 수 있다.
// @Target(value = ElementType.TYPE)  // 한 개의 값만 설정할 경우 중괄호 생략 가능!
// @Target(ElementType.TYPE)  // 프로퍼티 이름이 'value'일 경우 이름 생략 가능!

필드
@Target(ElementType.FIELD)

메소드
@Target(ElementType.METHOD)

로컬 변수
@Target(ElementType.LOCAL_VARIABLE)

복합(로컬 변수 + 파라미터 + 필드)
@Target({ElementType.LOCAL_VARIABLE, ElementType.PARAMETER, ElementType.FIELD})
→ "value =" 가 생략 되어있음
-------------------------------------------------------------------------------------
애노테이션 중복 사용

public @interface Employees {
  Employee[] value();
}

// 애노테이션을 중복해서 사용할 수 있게 하려면
// - @Repeatable 로 표시해 줘야 한다.
// - 이때 반복에 대한 정보를 따로 정의한 애노테이션을 지정해야 한다.
→ ★ @Repeatable(value=Employees.class)
-------------------------------------------------------------------------------------
★ 자주 쓰이는 애노테이션
애노테이션 유지 정책
→ @Retention(value=RetentionPolicy.RUNTIME)
애노테이션 적용 범위
→ @Target(value=ElementType.FIELD)
애노테이션 중복 사용
→ @Repeatable(value=Employees.class)
-------------------------------------------------------------------------------------
과제 39. 데이터의 등록, 조회, 수정, 삭제 기능을 캡슐화하기 : DAO(Data Access Object) 객체 도입
- XxxHandler에서 데이터를 조작하는 코드를 캡슐화하여 별도의 클래스로 분리
  - List나 Map처럼 특정 자료구조에 종속적인 코드를 작성할 필요가 없어진다.
- 인터페이스로 DAO 객체 사용법을 정의
-------------------------------------------------------------------------------------
DAO(Data Access Object)
→ 데이터 처리 코드를 캡슐화 
→ 자료구조나 데이터 저장 방식이 변경되더라도 다른 코드에 영향을 끼치지 않게 한다
① 이전 방식
BoardAddHandler
BoardListHandler
BoardModifyHandler
BoardViewHandler
→ 모두 <<Interface>>List 구현체이다
→ 인터페이스를 사용하여 일관되게 데이터 목록을 다룰 수 있게 되었지만
→ 다른 자료구조나 다른 기술로 데이터를 다루도록 변경한다면, 결국 Handler 클래스를 변경해야 한다
→ 기존 코드를 변경해야 하는 문제 발생!

② 개선 방식
→ 캡슐화(데이터 목록을 다루는 세부적인 구현 방식을 감춘다)
→ DAO가 제공하는 메소드 사용
→ List를 Map, Database, Excel 등 으로 바꿔도 문제 없음
→ 데이터 목록을 다루는 방식을 변경하더라도 Handler는 변경할 필요가 없다
-------------------------------------------------------------------------------------



2024.01.11(목)
-------------------------------------------------------------------------------------
과제 39. 데이터의 등록, 조회, 수정, 삭제 기능을 캡슐화하기 : DAO(Data Access Object) 객체 도입
- XxxHandler에서 데이터를 조작하는 코드를 캡슐화하여 별도의 클래스로 분리
  - List나 Map처럼 특정 자료구조에 종속적인 코드를 작성할 필요가 없어진다.
- 데이터 식별 값 추가
  - 기존 방식은 index 사용
    - 데이터를 삭제하면 index가 변경된다
    - 데이터 조회 시 일관성이 없어진다
  - 개선 방식은 각 데이터에 고유의 식별 번호 부여
    - 데이터를 삭제하더라도 기존 데이터의 식별 번호는 그대로 유지된다
    - 데이터 조회 시 일관성이 있다
- 인터페이스로 DAO 객체 사용법을 정의
  - DAO 교체가 용이하다
-------------------------------------------------------------------------------------
Handler와 DAO
Handler(ui제공, 입력화면, 출력화면) → call → DAO(데이터 처리)
→ ui코드와 데이터처리 코드 분리
→ DAO의 재사용성이 높아진다
→ DAO의 데이터 처리 방식이 바뀌더라도 Handler를 변경할 필요가 없다
→ DAO가 데이터 처리 과정을 캡슐화 했기 때문에 Handler는 어떤 자료구조를 쓰는지 모른다
-------------------------------------------------------------------------------------
인터페이스 사용 후
<<interface>>BoardDao
→ JsonBoardDao
→ XmlBoardDao
→ ExcelBoardDao
→ DbBoardDao
→ Dao를 교체하더라도 Handler를 변경할 필요가 없다!
<<concrete>>BoardDaoImpl
→ <<interface>>BoardDao에 구현체이고, AbstractDao에 상속 받는다
-------------------------------------------------------------------------------------
과제40. networking을 이용하여 데이터 공유하기
① 개인용 app
사용자 → app사용 → 데이터를 파일에 저장

② 업무용 app
인사팀1 → 인사관리 시스템(app) → 데이터를 파일에 저장(인사팀1 컴퓨터에 저장)
인사팀2 → 인사관리 시스템(app) → 데이터를 파일에 저장(인사팀2 컴퓨터에 저장)
인사팀3 → 인사관리 시스템(app) → 데이터를 파일에 저장(인사팀3 컴퓨터에 저장)
→ 인사팀 부서원 전체가 파일을 공유해야 한다
-------------------------------------------------------------------------------------
파일 공유(데이터 공유)
① 공유 폴더
→ 여러 App이 공유 폴더에 파일을 읽고 쓴다
→ 공유 디크스/ 공유 폴더 (예: windows → 네트워크 드라이브, linux → NFS ....)
→ 여러 App이 같은 파일을 동시에 변경할 때 다른 App이 변경한 내용을 덮는 경우가 발생한다

② 데이터 공유 관리 시스템 도입
App → 요청 -----------┒
App → 요청 -------→ 파일 관리 App → 데이터를 읽고 쓴다 → 파일
App → 요청 -----------┛
→ App의 요청을 받아서 처리
→ 파일 입출력을 통제
  → App끼리 데이터를 덮어쓰는 문제를 해결!
App <=> 파일관리 App
→ 서비스를 이용하는 App과 서비스를 제공하는 App끼리 통신을 해야한다
→ "Client / Server App" = "C/S 프로그램"
-------------------------------------------------------------------------------------
App Architecture 변경
→ 우리가 만든 Myapp을 뜯어서 Client / Server App으로 만든다
→ Client와 Server는 규칙에 따라서 통신을 해서 요청과 응답을 한다
→ Server App쪽에서 파일에 읽고 쓴다

필요 기술
→ 네트워킹 프로그래밍
→ 멀티 스레딩
-------------------------------------------------------------------------------------



2024.01.12(금)
-------------------------------------------------------------------------------------
ClientApp <=> ServerApp
→ 통신을 해서 요청과 응답을 한다

요청 규칙(protocol)
→ 데이터명
→ 명령
→ 데이터(entity)-Json형식

예) 
1. board → findAll 등 → (빈 문자열)
2. board → add → {"title" : "~", "~", ~~}
3. board → delete → 27(번호)

응답 규칙(protocol)
→ 상태코드
→ 데이터(entity)-Json형식

상태코드
200-성공
400-요청 오류
500-서버 실행 오류
 
예) 
1. 200 ok
2. 200 {"no":207, "title":"~",~~}
3. 400 요청 형식 오류!
4. 500 서버 실행 오류!
-------------------------------------------------------------------------------------
ServerSocket
Serversocket serverSocket = new ServerSocket("8888");
→ 외부에서 랜카드로 수신 받은 데이터를 받을 대상을 구별할 때 사용하는 번호가 포트번호(port)이다
→ 서버 소켓을 만들고 대기열을 만든다

ServerSocket.accept()
→ 여러 client가 server에 연결 요청
→  server는 대기 목록을 관리
→ accept()는 대기 목록에서 연결정보를 꺼내서 socket을 생성 및 리턴한다
→ 대기 목록에 요청이 없으면 요청이 들어올 때까지 리턴하지 않고 계속 기다린다

Socket 
→ 상대편 연결 정보(상대편 IP주소, 상대편 포트번호)
→ 랜카드 정보
-------------------------------------------------------------------------------------
네트워킹 입출력 read()/write()
read() 
→ 상대편에서 보낸 데이터를 랜카드의 메모리(RAM)에 보관한다 
→ 램에 보관된 데이터를 읽으면 리턴한다
→ 데이터가 없으면 상대편이 보낸 데이터가 들어올 때까지 리턴하지 않는다
write() 
→ 랜카드의 메모리(RAM)로 출력됨
→ 상대편이 읽을 때까지 기다리지 않고 즉시 리턴 
-------------------------------------------------------------------------------------
네트워크 DAO 구현
<<interface>>BoardDao → <<network>>BoardDao 구현 → read/write → ServerApp
→ Dao를 교체하더라도 Handler는 영향을 받지 않는다
→ interface를 사용하는 이유
-------------------------------------------------------------------------------------
★ 클래스 정보에서 메소드 추출해서 메소드 호출하기 ★
// command 이름으로 메소드를 찾는다
Method[] methods = dao.getClass().getDeclaredMethods();
Method commandHandler = null;
for (Method m : methods) {
  if (m.getName().equals(command)) {
    commandHandler = m;
    break;
  }
}
// 메소드의 파라미터 정보를 알아낸다
Parameter[] parameters = commandHandler.getParameters();
System.out.printf("파라미터 개수 : %s\n", parameters.length);

// 메소드를 호출할 때 파라미터에 넘겨 줄 데이터를 담을 배열을 준비한다
Object[] args = new Object[parameters.length];

// 아규먼트 값 준비하기
// => 현재 모든 DAO의 메소드는 파라미터가 최대 1개만 있다
// => 1개만 있다는 가정하에서 아규먼트 값을 준비한다
if (parameters.length > 0) {
  // 파라미터 타입을 알아낸다
  Class<?> paramType = parameters[0].getType();

  //클라이언트가 보낸 Json 문자열을 해당 파라미터 타입 객체로 변환한다
  Object paramValue = gson.fromJson(value, paramType);

  // 아큐먼트 배열에 저장한다
  args[0] = paramValue;
}

// 메소드의 리턴 타입을 알아낸다
Class<?> returnType = commandHandler.getReturnType();
System.out.printf("리턴 : %s\n", returnType.getName());

// 메소드를 호출한다
Object returnValue = commandHandler.invoke(dao, args);
-------------------------------------------------------------------------------------



2024.01.15(월)
-------------------------------------------------------------------------------------
현재 프로그램의 문제점

순차처리 방식
서버 <=> 클라이언트1  클라이언트2  클라이언트3
→ 클라이언트와 순차적으로 연결된다
→ 먼저 연결된 클라이언트가 연결이 종료될 때까지 기다려야 한다
-------------------------------------------------------------------------------------
과제 40. 네트워킹을 이용하여 데이터 공유하기 : Client/Server 아키텍처로 전환
- 네트워크 프로그래밍 방법
  - Client와 Server 개념
  - 프로토콜에 따라 애플리케이션 간에 데이터를 주고 받기
- Reflection API를 사용하는 방법
  - 서버의 DAO 메서드 호출을 자동화 하는 방법
-------------------------------------------------------------------------------------
GoF 프록시(proxy) 패턴
→ 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공합니다
→ 중간에서 호출을 대행하는 객체가 실제 작업을 수행하는 객체를 호출한다
→ 직접 사용하려면 복잡한 코드를 작성해야 하는 경우
→ 객체 사용에 대한 복잡한 코드를 캡슐화 = 프록시 객체

ClientApp <요청, 응답> ServerApp → call → BoardDaoImpl → I/O → JSON 파일
① 서버 소켓 연결
② 입출력 연결
③ 요청 데이터 전송 → JSON으로 변환(serialize)
④ 응답 데이터 수신 → 객체로 변환(deserialize)
→ 복잡한 절차에 따라 코드를 작성
→ 서버의 BoardDaoImpl의 메소드를 호출하기 위함
→ 캡슐화가 필요하다 = 코드가 간결해짐

<<interface>>BoardDao 

→ ServerApp구현체 → <<real>>BoardDaoImpl → JSON 파일 입출력
→ proxy 객체는 실제 일을 하는 객체처럼 보여야 하기 때문에 같은 인터페이스를 구현한다

→ ClientApp구현체 → <<proxy>>BoardDaoImpl
→ 서버와의 통신
→ JSON 데이터의 serialize/deserialize
→ 서버 쪽의 DAO를 호출하기 위한 복잡한 코드를 캡슐화
사용하는 쪽 입장에서는 local에 있는 객체가 일을 하는 것처럼 보인다

★ proxy pattern 용어 정리
<<interface>>BoardDao 

→ Handler ← call/return → <<proxy>>BoardDaoImpl(클라이언트 대행자=stub=원격 객체를 대리한다=proxy객체) 
<<통신(요청, 응답)>>
→ ServerApp(서버측 대행자=skeleton) ← call/return → <<real>>BoardDaoImpl(원격객체(remote Object)=service객체) → JSON 파일 입출력

→ stub/skeleton = Object Request Broker(ORB)
→ 실제 일을 하는 객체는 remoteObject이다
-------------------------------------------------------------------------------------
원격에 존재하는 코드(예 : 메소드)를 호출하는 이유
① 1인용 App
→ 순차적 처리
→ 적은 성능 요구
→ 1대의 컴퓨터 충분

② 다인용 App
→ 기업용
→ 동시 처리 필요
→ 많은 성능 요구
→ App의 기능을 여러 컴퓨터에 분할해서 실행할 필요성 대두 = 분산 컴퓨팅 기술

1대 컴퓨터(회계관리, 재고관리, 인사관리, 제조관리, 고객관리) → 여러 대의 컴퓨터로 분산(=distributed computing)
→ 다른 컴퓨터(다른 프로세스)의 메소드를 호출하는 기술이 필요해졌다
→ 하나의 프로그램(회계관리 시스템)이 연봉관리를 해야하는데 인사관리 시스템에서 인사 정보를 갖고 오기 힘들다
→ remote method 필요
-------------------------------------------------------------------------------------
원격 메소드를 호출하는 기술 - 다른 또는 같은 컴퓨터의 다른 프로세스에 있는 코드 실행
다른 프로세스 메모리에 직접 접근 불가!
local(App) → call → remote(App function(){})
→ 다르 프로세스의 메모리를 직접 접근 할 수 없다
→ 변수나 메소드 사용 불가!
→ 특별한 기술이 필요
compute1(local) → 직접 접근 불가 → compute2(remote)
-------------------------------------------------------------------------------------
원격 메소드 호출 기술 발전사
① RPC(Remote Procedure Call)
→ 절차적 프로그래밍 언어 (예 : C, Pascal 등)

② RMI(Remote Method Invocation)
→ 객체지향 프로그래밍 언어(예 : C++, Java 등)

③ CORBA(Connon Object Request Broker Architecture)
→ 이기종 플랫폼 간에 호출 C → Java에 있는 메소드 호출 → Pascal에 있는 메소드 호출

④ Web Service
→ client →  stub(C, Pascal) <=> skel(C, Pascal) → 서비스 객체
→ 언어 상관 없이 호출 가능
→ stub을 local에서 자동 생성
→ 서비스 객체를 만드는 측에서 제공한다
→ skel → 서비스 객체 WSDL(Web Services Description Language)(xml) : 서비스 객체가 제공하는 메소드 
→ 서버에서 WSDL(Web Services Description Language)을 받아와서 local의 IDE가 stub을 자동 생성

⑤ RESTful
client << 요청, 응답(http) >> Web Server << 위임, return >> 서비스 객체
→ 클라이언트 측에 stub 역할을 하는 객체가 필요 없다
→ 언어에 상관없이 HTTP 통신에 맞춰 서비스 객체를 이용
  → 이기종 플랫폼(프로그래밍 언어, OS) 간에 호출 가능
→ 전송 데이터 포맷 : XML, JSON을 주로 사용(뭐든지 가능)
→ 우리는 Web Server를 SpringBoot로 구축할 것이다
-------------------------------------------------------------------------------------
과제41. 공통 코드를 서브 프로젝트로 분리
app-client → app-common(vo class, dao interface) → app-server
build.gradle  build.gradle  build.gradle
id 'application  id 'java-library'  id 'application'
서버와 클라이언트 implementation project(':app-common') 라이브러리에 추가
app-client가 (app-api 만들기) 포함
- app-server에서 제공하는DAO 객체의 stub
- build.gradle
  - id 'java-library'
→ 원격 객체의 stub을 라이브러리로 만들면 재사용이 쉽다
-------------------------------------------------------------------------------------



2024.01.16(화)
-------------------------------------------------------------------------------------
객체(인스턴스) → 특별한 형식의 데이터(JSON, XML, csv, Java시리얼 포멧 등)
→ serialize marshaling encoding
객체(인스턴스) ← 특별한 형식의 데이터(JSON, XML, csv, Java시리얼 포멧 등)
→ deserialize unmarshaling decoding
내부 메모리 <=> 외부 메모리
→ serialize, deserilaize
-------------------------------------------------------------------------------------
★ 프록시 객체를 사용
m1(), m2(), m3() 호출 → 객체→ invoke() 호출 → InvocationHandler(실제 일을 수행)

MyInterface obj = (MyInterface) Proxy.newProxyInstance(
        Exam0110.class.getClassLoader(), // 클래스를 메모리에 로딩하는 일을 할 객체
        new Class[] {MyInterface.class}, // 자동 생성할 클래스가 구현해야 하는 인터페이스 목록
        new MyInvocationHandler());
-------------------------------------------------------------------------------------
★ 통신 방식
stateful
client <=> server
→ 연결 → 요청과 응답을 연결이 끊길 때까지 한다
→ 한번 연결하면 요청/응답을 연속해서 여러번 수행할 수 있다
→ 요청/응답을 수행하지 않는 순간에도 연결정보를 계속 유지 → 대량의 클라이언트 연결을 지원하지 못한다     
→ 먼저 연결된 클라이언트가 연결을 끊을 때까지 다음 클라이언트는 기다려야 한다 

stateless
client <=> server
→ 연결 → 요청 → 응답 → 연결 끊기
→ 연결 → 요청 → 응답 → 연결 끊기
→ 요청할 때마다 매번 연결수행 → 요청 처리 시간이 길어진다
→ stateful 방식보다 더 많은 클라이언트 요청을 처리할 수 있다  
→ 연결하는데 시간이 많이 소요된다
→ 한번 요청/응답이 이루어지면 즉시 연결을 끊는다
→ 다음 클라이언트의 기다리는 시간은 짧아진다
------------------------------------------------------------------------------------- 
서버 만들기
① new ServerSocket(8888) 
→ 랜카드와 연결할 정보 생성 
→ 대기열(queue)을 준비시킨다

② accept() 
→ 대기열에서 연결된 클라이언트 정보를 꺼낸다 
→ Socket 객체 생성 및 리턴 
→ 대기열이 비어 있으면 리턴 하지 않고 기다린다
-------------------------------------------------------------------------------------
★ 1) 다른 컴퓨터의 연결 요청을 기다린다.
// - new ServerSocket(포트번호)
// - 포트번호:
// - 호스트에서 실행 중인 서버 프로그램을 구분하는 번호이다.
// - 1024 ~ 49151 사이의 값 사용한다.
// - 1 ~ 1023 사이의 포트 번호는 특정 서버가 사용하기 위해 미리 예약된 번호다.
// - 가능한 이 범위의 포트 번호는 사용하지 않는 것이 좋다.
// - 유명 프로그램의 포트 번호도 가능한 사용하지 말라.
// - 예) Oracle DBMS(1521), MySQL DBMS(3306), 프록시서버(8080) 등
// - 같은 컴퓨터에서 다른 프로그램이 이미 사용중인 포트 번호는 지정할 수 없다.
// - 포트 번호는 중복으로 사용될 수 없다.
-------------------------------------------------------------------------------------
포트 번호
server
→ 서버 측 포트 번호는 개발자가 정한다
→ 포트 번호로 data를 받을 App을 결정
client
→ 클라이언트 포트 번호는 OS가 자동으로 발급(일회성 포트번호) = 개발자가 정하는게 아니다
→ 49152~65535 중에서 OS가 자동 발급
-------------------------------------------------------------------------------------



2024.01.17(수)
-------------------------------------------------------------------------------------
★ IP주소는 어느 컴퓨터인지 구분하고 port번호는 컴퓨터 안의 여러 있는 통신 프로그램을 구분한다
-------------------------------------------------------------------------------------
IP주소와 호스트명(호스트명+도메인명 : www.naver.com)
www → 호스트명
naver.com → 영역이름(도메인 이름)

Server와 연결
→ PC에서 www.naver.com을 접속하려고 한다
→ PC는 Domain Name System(DNS)에 IP주소 요청한다
→ naver.com DNS 서버 주소 알려준다
→ 네이버 DNS에 호스트의 IP주소 요청
→ 네이버 DNS가 IP 주소를 알려주면 NAVER 서버와 연결된다
-------------------------------------------------------------------------------------
서버 대기열
new ServerSocket(포트번호, 대기열크기);
→ queue(FIFO : First In First Out)
→ 대기열(=backlog) 기본 크기는 50이다.
→ 클라이언트가 접속을 요청하면 대기열에 클라이언트 정보를 저장한다.
→ 대기열을 초과하여 클라이언트 요청을 들어 왔을 때 서버는 응답하지 않는다.
→ 클라이언트는 내부에 설정된 시간(timeout)동안 기다리다 응답을 받지 못하면
→ 예외를 던지고 연결 요청을 취소한다.
→ 대기열 크기 넘어서 접속 요청을 한다면 대기열이 모두차서 응답을 하지 않고 timeout 될 때까지 기다린다 계속 응답이 없으면 예외를 던진다
-------------------------------------------------------------------------------------
타임아웃 시간 설정하기
1) 소켓을 생성한다.
Socket socket = new Socket();
System.out.println("소켓 생성됨.");

2) 연결할 서버의 주소를 준비한다.
SocketAddress socketAddress = new InetSocketAddress("localhost", 8888);

socket.connect(socketAddress, 5000); // timeout : milliseconds
-------------------------------------------------------------------------------------
connection oriented vs connectionless

① connection oriented(TCP)
연결 ← 데이터 송수신 → 연결 끊기
→ 데이터 송수신을 보장한다 = 신뢰성이 있다
→ 연결과정에 시간이 소요
예) 전화통화, 등기

② connectionless(UDP)
데이터 전송 → 응답을 하지 않음
→ 실행 중이지 않을 때
→ 데이터 송수신을 보장하지 않는다 = 신뢰성이 없다
→ 연결 과정이 없기 때문에 TCP보다 빠르다 단, 데이터 송신을 보장하지 않는다
예) 편지

HTTP 발전사
HTTP1 → HTTP2 → HTTP3
HTTP1, HTTP2 → TCP
HTTP3 → UDP → 속도를 높이기 위해 UDP 사용 = 연결에 소요되는 시간을 제거함

통신 → connextion oriented(TCP) → stateful, stateless
       → connectionless(UDP) → Broadcast
-------------------------------------------------------------------------------------
read()/write()
write() → 저장 → NIC(RAM메모리=버퍼) → 전송 → NIC(RAM메모리=버퍼) → 읽기 → read()
-------------------------------------------------------------------------------------
★ TCP/IP 4계층 

write() 동작
Application → write()로 쓰기 → data 
→ TCP → 데이터 전송 최소 단위로 분할(packet 분할) 
→ IP → 패킷에 주소 부여(받는이/보내는이)
→ NIC(LAN카드) → 패킷에 하드웨어 정보 부여(물리주소=LAN카드 주소=NIC주소)
→ (1번패킷, 받는 이, 보내는 이, NIC주소)  (2번패킷, 받는 이, 보내는 이, NIC주소)  (3번패킷, 받는 이, 보내는 이, NIC주소)

read() 동작
→ (1번패킷, 받는 이, 보내는 이, NIC주소)  (2번패킷, 받는 이, 보내는 이, NIC주소)  (3번패킷, 받는 이, 보내는 이, NIC주소)
→ NIC(LAN카드) → NIC 정보 추출(NIC 주소를잘라낸다)
→ IP → 패킷 추출(주소를 잘라낸다)
→ TCP → 패킷을 조립
→ Application → read()로 읽기 → data 

→ 허브-게이트웨이-라우터를 지나서 패킷들을 역순으로 조립
-------------------------------------------------------------------------------------
PrintWriter
PrintWriter out = new PrintWriter(socket.getOutputStream());
out.println(str);
out.flush();
// character stream 클래스의 경우
// 출력 데이터를 내부 버퍼에 보관하고 있다가
// flush()가 호출되면 비로서 출력을 수행한다.
// 따라서 위 출력 문자열은 클라이언트에 보내지 않는다.
// 주의!
// => 단 close()를 호출하면 close() 내부에서 flush()를 실행한다.
-------------------------------------------------------------------------------------
File dir = new File("temp");
getPath() : File에 입력된 경로 리턴
getAbsolutePath() : File에 입력된 절대 경로 리턴
getCanonicalPath() : Resolved된 절대 경로 리턴
-------------------------------------------------------------------------------------



2024.01.18(목)
-------------------------------------------------------------------------------------
네트워크
개인 컴퓨터 → 허브(공유기) → 게이트웨이 → 통신사 → 여러 장치(라우터)를 연결해서 전세계 통신사 연결 → 케이트웨이 → 허브 → 컴퓨터
-------------------------------------------------------------------------------------
FileOutPutStream
→ 1바이트 단위로 파일에 쓴다
→ 1바이트를 UTF-16BE방식으로 16진수로 변환해서 파일에 쓴다
FileInPutStream
→ 1바이트 단위로 파일에서 읽어온다
→ UTF-16BE방식으로 인코딩된 16진수 1바이트를 파일에서 읽어온다

★ FileOutputStream out = new FileOutputStream("temp/test1.txt");
out.write('A'); // 0x0041
out.write('가'); // 0xac00
out.write(bytes); // 바이트 배열 전체를 출력한다.
out.write(bytes, 2, 3); // 2번 데이터부터 3 바이트를 출력한다.
byte[] bytes = str.getBytes(); // 문자집합을 지정하지 않으면 file.encoding에 설정된 문자집합으로 인코딩하여 리턴한다.
byte[] bytes = str.getBytes("MS949");
out.write(bytes);

★ FileInputStream in = new FileInputStream("temp/test1.txt");
System.out.printf("%02x\n", in.read());
System.out.printf("%02x\n", in.read());
int count = in.read(buf);
int count = in.read(buf, 10, 40); // 40바이트를 읽어 10번 방부터 저장한다.
String str = new String(buf, 0, count);
String str = new String(buf, 0, count, "CP949"); // MS949 = CP949 
String str = new String(buf, 0, count, "UTF-16");
-------------------------------------------------------------------------------------
FileWriter
→ 영어는 2바이트(UTF-16BE)를 1바이트(UTF-8)로 인코딩해서 파일에 쓴다
→ 한글은 2바이트(UTF-16BE)를 3바이트(UTF-8)로 인코딩해서 파일에 쓴다
FileReader
→ 영어는 1바이트(UTF-8)를 2바이트(UTF-16BE)로 디코딩해서 파일에서 읽는다
→ 한글은 3바이트(UTF-8)를 2바이트(UTF-16BE)로 디코딩해서 파일에서 읽는다

★ FileWriter out = new FileWriter("temp/test2.txt");
out.write(0x7a5f0041);
Charset charset = Charset.forName("UTF-16BE");
FileWriter out = new FileWriter("temp/test2.txt", charset);
char[] chars = new char[] {'A', 'B', 'C', '0', '1', '2', '가', '각', '간', '똘', '똥'};
out.write(chars); // 문자 배열 전체를 출력한다.
out.write(chars, 2, 3); // 2번 문자부터 3 개의 문자를 출력한다.
String str = new String("AB가각");
out.write(str); 

★ FileReader in = new FileReader("sample/utf8.txt");
int ch1 = in.read(); 
Charset charset = Charset.forName("UTF-8");
FileReader in = new FileReader("sample/utf8.txt", charset);
char[] buf = new char[100];
int count = in.read(buf);
String str = new String(buf, 0, count); // 그래서 String 객체를 만들 때 문자집합을 지정할 필요가 없다.
int count = in.read(buf, 10, 40); // 40개의 문자를 읽어 10번 방부터 저장한다.

// FileReader 객체가 읽을 데이터를 저장할 메모리를 준비한다.
CharBuffer charBuf = CharBuffer.allocate(100);

// 읽은 데이터를 CharBuffer 에 저장한다.
int count = in.read(charBuf);

// 버퍼의 데이터를 꺼내기 전에 읽은 위치를 0으로 초기화시킨다.
// - read() 메서드가 파일에서 데이터를 읽어서 버퍼에 채울 때 마다 커서의 위치는 다음으로 이동한다.
// - 버퍼의 데이터를 읽으려면 커서의 위치를 처음으로 되돌려야 한다.(flip)
// - flip() 메서드를 호출하여 커서를 처음으로 옮긴다. 그런 후에 버퍼의 텍스를 읽어야 한다.
charBuf.flip();
System.out.printf("[%s]\n", charBuf.toString());

// 데코레이터를 붙인다.
// => 버퍼 기능 + 한 줄 읽기 기능
BufferedReader in2 = new BufferedReader(in);
System.out.println(in2.readLine());
-------------------------------------------------------------------------------------
인트
int money = 1_3456_7890; // = 0x080557d2
  out.write(money >> 24); // 00000008|0557d2
    out.write(money >> 16); // 00000805|57d2
    out.write(money >> 8);  // 00080557|d2
    out.write(money);       // 080557d2

int value = in.read() << 24;   // 00000008 =>   08000000
    value += (in.read() << 16);    // 00000005 => + 00050000
    value += (in.read() << 8);     // 00000057 => + 00005700
    value += in.read();            // 000000d2 => + 000000d2
    //==========================================>   080557d2
→ short, int ,long, float, double 타입은 이러한 방식으로 숫자를 읽어와서 변환을 한다
→ 문자열은 byte 배열을 읽거나 써서 변환한다
-------------------------------------------------------------------------------------
상속을 이용한 기능 확장
DataFileInPutStream/DataFileOutPutStream
→ FileInPutStrea/FileOutPutStream을 상속
→ ㅇprimitive type과 String 데이터를 byte로 변환해준다
→ Data Processing
→ data seek time을 줄이려고 byte배열로 버퍼를 준비해서 한번에 읽고 쓴다

BufferedFileInPutStream/BufferedFileOutPutStream
→ FileInPutStrea/FileOutPutStream을 상속
→ 내부적으로 자체 버퍼를 가지고 있다 data seek time이 줄어든다
→ read()/write() 메소드를 오버라이딩 해서 버퍼를 이용해서 읽고 쓴다
→ 버퍼의 데이터를 모두 읽으면 다시 파일에서 왕창 읽어온다
→ 버퍼가 꽉차면 버퍼의 데이터를 왕창 출력한다
→ read()/write()를 제어한다 = Data Processing = 데이터 가공
-------------------------------------------------------------------------------------
상속을 이용한 기능 확장의 한계
→ 상속을 이용해서 기능을 만들었지만 성능을 개선하려고 하면 또 상속을 반복해야한다
→ 기존 클래스의 있던 메소드를 또 작성해야한다
→ 상속을 이용해 기능을 확장하다보면, 경우의 수가 증가함에 따라 중복코드도 증가하게 된가
→ 쉽게 기능을 추가 하거나 삭제할 수 없다
→ 상속을 이용해 기능 확장을 하게되면 기능 개수에 따라 조합해서 만들어야 하는 클래스 개수가 기하급수적으로 늘어나기 때문에 유지보수가 힘들어진다
-------------------------------------------------------------------------------------
GoF의 Decorator 디자인 패턴
→ 여러 개의 기능을 상황에 따라 조합해서 써야하는 경우 기능 확장이 용이하도록 만든 설계기법
→ 부품에 악세서리(기능1, 기능2, ...=부품)를 붙여서 사용한다

예)
실제 제품 → 기능1 연결 → 기능3 연결
실제 제품 → 기능3 연결
실제 제품 → 기능2 연결 → 기능1 연결
→ 상황에 따라(필요에 따라) 다양한 기능을 붙여서 사용할 수 있다
→ 상속보다 기능 확장이 쉽고 유연하다
-------------------------------------------------------------------------------------



2024.01.19(금)
-------------------------------------------------------------------------------------
Data Sink Stream classes(File Memory process) = concrete component
<바이트 스트림(InputStream/OutputStream)>
→ FileInPutStream/FileOutPutStream
→ ByteArrayInputStream/ByteArrayOuputStream
→ PipedInputStream/PipedOuputStream

InputStream → FileInputStream
	    → FilterdInputStream → DataInputStream
			       → BufferedInputStream
→ 다른 객체(I/O Stream)에 붙여서 사용할 수 있다

<캐릭터 스트림(Reader/Writer)>
→ FileReader/FileWriter
→ CharArrayReader/CharArrayWriter
→ StringReader/StringWriter
→ PipedReader/PipedWriter
→ 바이트 스트림과 다르게 각 클래스가 제품이기 때문에 단독적으로 사용할 수 있다
-------------------------------------------------------------------------------------
Data Processing Stream classes(Decorator)
<바이트 스트림(InputStream/OutputStream)>
→ DataInputStream/DataOutputStream
→ BufferedInputStream/BufferedOutputStream
→ ObjectInputStream/ObjectOutputStream(concrete component/Decorator가능)
→ PrintStream(concrete component/Decorator가능)

<캐릭터 스트림(Reader/Writer)>
→ BufferedRead/BufferedWriter
→ LineNumberReader
→ PrintWriter(concrete component/Decorator가능)
-------------------------------------------------------------------------------------
stateful 통신 방식
클라이언트            서버
      |------------------>| 연결
      |------------------>| 데이터 수신
      |<------------------| 데이터 전송
      |------------------>| 데이터 수신
      |<------------------| 데이터 전송
      |------------------>| 데이터 수신
      |<------------------| 데이터 전송
      |--------x--------->| 끊기
→ 연결한 후 연결을 끊을 때까지 요청/응답을 계속 수행한다
→ 클라이언트가 요청하지 않아도 계속 연결된 상태를 유지한다
→ 단점 : 서버에 메모리를 계속 차지 / 접속 클라이언트의 수가 제한된다
→ 장점 : 클라이언트 요청에 대한 작업결과를 서버에 유지할 수 있다

stateless 통신 방식
클라이언트            서버
     |------------------>| 연결
     |------------------>| 데이터 수신
     |<------------------| 데이터 전송
     |--------x--------->| 끊기
     |------------------>| 연결
     |------------------>| 데이터 수신
     |<------------------| 데이터 전송
     |--------x--------->| 끊기
     |------------------>| 연결
     |------------------>| 데이터 수신
     |<------------------| 데이터 전송
     |--------x--------->| 끊기
→ 요청/응답을 수행한 후 즉시 연결 끊기
→ 단점 : 요청할 때마다 매번 연결 필요(소요 시간 증가) / 클라이언트와 작업한 내용을 서버에 유지하지 못한다
→ 장점 : 서버 메모리를 덜 차지 / stateful 방식보다 더 많은 클라이언트 연결을 허용한다
→ 웹은 stateless 방식이다
-------------------------------------------------------------------------------------
stateful / single Thread
서버측 작업자 → new ServerSocket(); → Socket s = ss.accept(); → 입출력 반복 통신
클라이언트1 → new Socket(); → 입출력 반복 통신
클라이언트2 / 클라이언트3 
→ 클라이언트1이 연결을 끊을 때까지 순서대로 기다려야 한다
→ 왜? 서버측의 작업자가 1명이니까!
-------------------------------------------------------------------------------------
접속한 클라이언트의 IP 주소 알아내기
InetAddress inetAddr = socket.getInetAddress();
System.out.printf("접속자: %s\n", inetAddr.getHostAddress());
→ 서버에 누가 접속 했는지 알 수 있다
-------------------------------------------------------------------------------------
고객 포인트 정보 관리 예
고객1 → 주문1 → 가게(포인트 적립) → 주문2 → 가게(포인트 적립)
고객2 → 주문1 → 가게(포인트 적립) → 주문2 → 가게(포인트 적립)
→ 고객n이 주문n을 할 때마다 고객n에 해당하는 id(전화번호)에 포인트가 개별로 적립된다
-------------------------------------------------------------------------------------
stateless 방식에서 클라이언트를 구분하고 클라이언트의 작업 결과를 유지하는 방법!
클라이언트            서버
     |------------------>| 연결
     |------------------>| 데이터 수신(clientId=0, 연산자=+, 값=100)
     |<------------------| 데이터 전송(clientId=2713, 결과값=100)
     |--------x--------->| 끊기
     |------------------>| 연결
     |------------------>| 데이터 수신(clientId=2713, 연산자=-, 값=20)
     |<------------------| 데이터 전송(clientId=2713, 결과값=80)
     |--------x--------->| 끊기
→ clientId로 기존에 저장된 결과를 찾아서 계산을 추가한다

★ 서버
// 각 클라이언트의 작업 결과를 보관할 맵 객체
// => Map<clientId, result>
static Map<Long, Integer> resultMap = new HashMap<>();
// 클라이언트를 위한 기존 값 꺼내기
Integer obj = resultMap.get(clientId);

// 만약 신규 고객이면 clientId를 신규발급한다
clientId = System.currentTimeMillis(); // 이 코드는 시간을 Id로 사용했다

// 계산 결과를 resultMap에 보관한다.
resultMap.put(clientId, result);

★ 클라이언트
// => 서버에서 보낸 클라이언트 아이디를 읽는다.
clientId = in.readLong();

// => 서버에서 보낸 결과를 읽는다.
System.out.println(in.readUTF());
-------------------------------------------------------------------------------------
stateful / stateless 문제점 해결
stateful
먼저 연결된 클라이언트가 연결을 끊을 때까지 기다려야 한다
→ 클라이언트 요청을 처리하는 것을 별도로 실행하라!

sateless
클라이언트가 연결하고 한 작업으로 오랜시간에 한다면 다른 클라이언트는 연결을 할 수 없다
→ 클라이언트 요청을 처리하는 것을 별도로 실행하라!
-------------------------------------------------------------------------------------
'main' Thread - 기본 실행 흐름
JVM(process) → start → main 스레드 call → main() → m1() → m2() → return → return → m3() → m4() → m5() → return → return → return → print() → return → 종료
→ 실행 흐름이 하나의 연결된 선으로 진행한다 ''실(Thread)'처럼
→ 항상 main()으로 돌아와서 종료한다 = 항상 return
-------------------------------------------------------------------------------------
★ 멀티 스레드
					→ new 스레드.start() → 스레드 → run() 콜 → 종료
메인 스레드 → 메인 함수 콜 → new 스레드.start() → 스레드 → run() 콜 → 종료
				→ new 스레드.start() → 스레드 → run() 콜 → 종료
→ main Thread(메인 스레드) = parent Thread(부모 스레드)
→ Other Thread(스레드) = child Thread(자식 스레드)
→ 여러 스레드가 나란히(병행)실행 = 멀티 스레딩(multi threading)
-------------------------------------------------------------------------------------
★ 스레드 만들기
메인 스레드 → main() → ㅁ → 종료
class MyThread extends Thread {
  void run(){
    main 실행흐름과 분리해서 독립적으로 실행하고 싶은 코드
  }
}

★ 스레드 실행
① 방법1
→ Thread 상속을해서 MyThread 클래스를 만든다
MyThread t = new MyThread(); 
t.start();
  → 부모 스레드로부터 실행을 분리하여 run()을 호출한다

② 방법2
→ <<interface>>Runnable → <<concrete>>MyRunnable을 구현한다
MyRunnable r = new MyRunnable();
Thread t = new Thread(r);
t.start();
  → 부모 스레드에 실행을 분리
  → t.run() 호출 → r.run() 호출
-------------------------------------------------------------------------------------
과제 44. 여러 클라이언트 요청을 동시에 처리하기: Thread 적용
- 멀티태스킹의 메커니즘 이해
  - 프로세스 스케쥴링: Round Robin 방식, Priority + Aging 방식
  - 컨텍스트 스위칭 개념
  - 프로세스 복제(fork)방식과 스레드 방식 비교
  - 임계영역(Critical Region, Critical Section): 세마포어(Semaphore)와 뮤텍스(Mutex)
- 스레드의 구동원리와 사용법
  - 스레드의 라이프사이클 이해
  - Thread 클래스와 Runnable 인터페이스 사용법
-------------------------------------------------------------------------------------



2024.01.22(월)
-------------------------------------------------------------------------------------
connection-oriented / connectionless
① connection-oriented = TCP
클라이언트            서버
     |------------------>| 연결
     |-------------------| 서버에서 소켓 생성
     |<---------------->| 데이터 송수신

② connectionless = UDP
클라이언트            서버
DatagramSocket 
→ DatagramPacket(byte[]=데이터, 데이터 길이, IP주소, 포트번호) 
→ send() call 
→ 전송 
→ 실행 중이든 아니든 상관없이 서버에 전송

// 보낼 데이터를 패킷에 담는다.
// => 패킷 = 데이터 + 데이터크기 + 받는이의 주소 + 받는이의 포트번호
DatagramPacket packet = new DatagramPacket(
        bytes, // 데이터가 저장된 바이트 배열
        bytes.length, // 전송할 데이터 개수
        InetAddress.getByName("localhost"), // 데이터를 받을 상대편 주소
        port // 포트번호
        );
InetAddress.getByName("도메인명")
→ DNS 서버에 IP 주소 문의
→ 도메인명을 이용해서 IP주소를 검색한다
→ 주소를 리턴 받아서 InetAddress 객체의 IP주소를 담아서 객체를 리턴한다 = 팩토리 메소드

DatagramPacket → send() → DatagramSocket → Hub → Gateway → 여러 router 통해서 → Gateway → Hub → computer에 전달 or 없으면 버린다
→ 목적지 주소 및 포트에 해당하는 App이 실행중에 있으면 전달 or 실행중이 아니라면 버린다

클라이언트               서버
DatagramSocket <=> DatagramSocket(port)
<client> byte[] = 데이터 ◇→ DatagramPacket → send()
<server> receive() → DatagramPacket ◇→ byte[] = 빈 배열
→ 개발자가 포트 번호 부여 
-------------------------------------------------------------------------------------
★ Server(connectionless)
// 데이터 송수신을 담당할 소켓을 먼저 준비한다.
// => 보내는 쪽이나 받는 쪽이나 같은 소켓 클래스를 사용한다.
//    서버 소켓이 따로 없다.
// => 받는 쪽에서는 소켓을 생성할 때 포트번호를 설정한다.
DatagramSocket socket = new DatagramSocket(8888);

// 받은 데이터를 저장할 버퍼 준비
byte[] buf = new byte[8196];

// 빈 패킷 준비
DatagramPacket emptyPacket = new DatagramPacket(buf, buf.length);

// 빈 패킷을 사용하여 클라이언트가 보낸 데이터를 받는다.
// => 데이터를 받을 때까지 리턴하지 않는다.
socket.receive(emptyPacket);
System.out.println("데이터를 받았음!");

socket.close();
keyScan.close();

// 빈 패킷에 저장된 클라이언트가 보낸 데이터를 꺼낸다.
// 패킷에 저장된 UTF-8로 인코딩된 바이트 배열을 가지고 String 객체(UTF-16)를 만든다.

// 1) 패킷 객체에 보관된 바이트 배열을 꺼낸다.
byte[] bytes = emptyPacket.getData();

// getData()가 리턴한 배열은 DatagramPacket 을 만들 당시 넘겨준 배열이다.
System.out.println(buf == bytes);

// 2) 바이트 배열에 보관된 데이터의 개수를 알아낸다.
int len = emptyPacket.getLength();

// 3) 클라이언트에서 받은 바이트 배열을 가지고 String 객체를 생성한다.
String message = new String(bytes, 0, len, "UTF-8");

// 실무에서는 다음과 같이 로컬 변수를 사용하지 않고 직접 패킷 객체를 사용하는 방식으로 코딩한다.
//    String message = new String(//
//        emptyPacket.getData(), // ==> buf, 패킷에서 바이트 배열을 꺼낸다.
//        0, // 버퍼에서 데이터를 꺼낼 때 0번째부터 꺼낸다.
//        emptyPacket.getLength(), // 패킷에서 받은 바이트의 개수만큼 데이터를 꺼낸다.
//        "UTF-8" // 바이트 배열로 인코딩된 문자표의 이름을 지정한다.
//        );

System.out.println(message);
-------------------------------------------------------------------------------------
★ Client(connectionless)
// connectionless 방식으로 통신을 수행할 소켓 생성
// - 클라이언트 쪽은 포트 번호를 지정하지 않는다.
// - 물론 OS가 자동으로 부여할 것이다.
DatagramSocket socket = new DatagramSocket();

// 보낼 데이터를 바이트 배열로 준비
// String message = new String("Hello"); // Heap에 String 객체 생성
// String message = "Hello"; // constant pool에 String 객체 생성
// byte[] bytes = message.getBytes("UTF-8");
byte[] bytes = "Hello".getBytes("UTF-8");

// 보낼 데이터를 패킷에 담는다.
// => 패킷 = 데이터 + 데이터크기 + 받는이의 주소 + 받는이의 포트번호
DatagramPacket packet = new DatagramPacket(bytes, // 데이터가 저장된 바이트 배열
  bytes.length, // 전송할 데이터 개수
  InetAddress.getByName("localhost"), // 데이터를 받을 상대편 주소
  8888 // 포트번호
);

// 데이터 전송
socket.send(packet);
System.out.println("데이터 전송 완료!");

// 자원해제
socket.close();

// 상대편이 네트웍에 연결되었는지 따지지 않고 무조건 데이터를 보낸다.
// 만약 상대편이 연결되어 있지 않다면, 보낸 데이터는 그 쪽 네트웍에서 버려진다.
// => 데이터 송수신을 보장하지 않는다.
-------------------------------------------------------------------------------------
Connection-Oriented 
예 : HTTP(stateless)
client <=> server
→ HTTP(Hyper text TransFer Protocol) Hyper text = 다른 문서의 연결정보를 포함

client
→ 요청 라인 + 요청 헤더 + 보내는 데이터
예) 
GET / HTTP/1.1
Host : 상대편 주소

server
→ 상대 라인 + 응답 헤더 + 응답 데이터
예)
HTTP/1.1 200 ok
Content-Type : Text/html; charset-8
응답 데이터 

Web
HTTP Client(=Web Browser) <=> HTTP Server(=Web Server)
→ HTTP를 요청 / 응답
→ (GUI)chrome, edge, safari, firefox, opera, whail, (CLI)wget, curl
→ apache http server, iis, nginx
예) FTP client <FTP> FTP server, SMTP client <SMTP> SMTP server
-------------------------------------------------------------------------------------
★ client(connection-oriented)
// HTTP 요청 프로토콜에 따라 서버에 데이터 전송
// => macOS에서 JVM을 실행할 때, println()은 문자열 뒤에 0a(LF) 코드만 붙인다.
// => 이를 해결하려면, 다음과 같이 명확하게 CRLF 코드를 붙여라.
//
out.print("GET / HTTP/1.1\r\n");
out.print("Host: www.rpm9.com\r\n");
out.print("\r\n");
out.flush();

// HTTP 응답 프로토콜에 따라 서버가 보낸 데이터를 수신
while (true) {
  try {
    System.out.println(in.nextLine());
  } catch (Exception e) {
    break;  
  }
}
-------------------------------------------------------------------------------------
★ server(connection-oriented)
ServerSocket ss = new ServerSocket(8888);
System.out.println("서버 실행!");

while (true) {
  Socket socket = ss.accept();
  Scanner in = new Scanner(socket.getInputStream());
  PrintStream out = new PrintStream(socket.getOutputStream());

  // 클라이언트가 보낸 데이터를 HTTP 요청 프로토콜에 맞춰 읽는다.
  while (true) {
    String str = in.nextLine();
    System.out.println(str);
    if (str.equals(""))
    break;
}

// HTTP 응답 프로토콜에 따라 클라이언트에게 데이터를 보낸다.
// => macOS에서 JVM을 실행할 때, println()은 문자열 뒤에 0a(LF) 코드만 붙인다.
// => 이를 해결하려면, 다음과 같이 명확하게 CRLF 코드를 붙여라.
//
out.print("HTTP/1.1 200 OK\r\n");
out.print("Content-Type: text/html; charset=UTF-8\r\n");
out.print("\r\n");
out.print("<html><body><h1>안녕!-강사</h1></body></html>\r\n");
-------------------------------------------------------------------------------------
★ 종단간 암호(공개키 / 개인키)
→ 메시지를 처음부터 끝까지 평문으로 저장하지 않고 암호화하는 안전한 통신 방법

A ----------> B
public key : 자물쇠
private key : 열쇠
A → 인증서버 → B의 공개키 → A
A → B의 공개키(A의 공개키) 잠근다 → B에게 전송 → B의 개인키로 B의 공개키를 해제 → A의 공개키 획득
A → B의 공개키(Data=연산 할 데이터) 잠근다 → B의 개인키로 Data(연산 할 데이터) 해제 후 가공 → Data(결과 데이터) 
B → A의 공개키(Data=결과 데이터) 잠근다 → A에게 전송 → A의 공개키로 해제한다 → Data=결과 데이터 획득
→ 공개키로 잠그고 개인키로 해제한다
-------------------------------------------------------------------------------------
URI (URL / URN)
URI = Uniform Resource Identifier → 인터넷에 있는 자원을 나타내는 유일한 주소이다.
→ URL(= Uniform Resource Locator) → http://naver.com/:80/search?~~~~~~
→ URN(= Uniform Resource Name) → urn:isbn:04517501
-------------------------------------------------------------------------------------
★ URL(Uniform Resource Locator) - URL을 다루는 클래스
// 웹 상에서 자원의 위치를 표현하는 방법
// => [프로토콜]://서버주소:포트번호/자원의경로?파라미터명=값&파라미터명=값
// - 프로토콜: http(80), https(443), ftp(21/20) 등
// - 서버주소: IP 주소(192.168.0.1), 도메인명(www.bitcamp.co.kr)
// - 포트번호: 80 또는 443(생략할 수 있다), 8080(프록시 서버) 등
// - 자원의경로: /index.html, /board/list.jsp 등
// - 서버에 보내는 파라미터(Query String): 파라미터명=값&파라미터명=값
//
// 자원
// - 정적 자원(static)
//   - 요청할 때 마다 결과 콘텐트가 변경되지 않는 자원. 즉 파일을 가리킨다.
//   - 예) HTML, GIF, JPEG, PNG, CSS, JavaScript, TXT 등의 파일
// - 동적 자원(dynamic)
//   - 요청할 때 마다 결과 콘텐트가 변할 수 있는 자원. 
//   - 메일 조회, 게시물 변경, 주문 등의 웹 프로그램을 가리킨다.
//   - 예) index.php, index.jsp, /board/list 등
//
URL url = new URL("https://search.naver.com:443/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=bitcamp");

// URL 분석
System.out.printf("프로토콜: %s\n", url.getProtocol());
System.out.printf("서버주소: %s\n", url.getHost());
System.out.printf("포트번호: %d\n", url.getPort()); // 지정하지 않으면 -1 리턴. 실제 접속할 때는 기본 포트번호 사용.
System.out.printf("자원경로: %s\n", url.getPath());
System.out.printf("서버에 보내는 파라미터: %s\n", url.getQuery());

// 
URL url = new URI("https://tools.ietf.org/html/rfc2616#section-5.1").toURL();
System.out.printf("참조경로(내부위치): %s\n", url.getRef());

// 로컬 자원의 위치를 URL로 표현하는 방법
// file://자원의 경로
// - 자원의 경로
// /드라이브명:/디렉토리 또는 파일 경로 (Windows)
// /루트디렉토리/디렉토리 또는 파일 경로 (Linux/macOS/Unix)
URL url = new URI("file:///c:/Users/user/git/bitcamp-study/Hello.java").toURL();
URL url = new URI("file:///Users/eomjinyoung/git/bitcamp-study/Hello.java").toURL();
-------------------------------------------------------------------------------------
URL
https://naver.com:443/search.naver?where=nexearch&query=bitcamp
https → protocol = schem
naver.com → host address
443 → port
/search.naver → path
? 뒤 나머지 → query string(qs)

http = 80
https = 443
→ 기본 포트번호(생략 가능)
-------------------------------------------------------------------------------------
URL 객체 활용
// URL 클래스를 이용하면 HTTP 프로토콜을 신경쓰지 않고
// HTTP 요청을 수행할 수 있다.
// 특히 HTTPS까지도 처리할 수 있다.

// => URL 주소를 검증하고 준비한다.
URL url = new URI("https://sports.news.naver.com/index").toURL();

// => 서버와 연결하고 HTTP 요청을 수행한다.
// => 그런 후에 웹서버의 응답 데이터를 읽어들일 도구를 준비한다.
InputStream in = url.openStream();

// => 서버가 보낸 데이터를 한 줄씩 읽기 위해 데코레이터를 붙인다.
BufferedReader in2 = new BufferedReader(new InputStreamReader(in));


// => URL 주소를 준비한다.
URL url = new URL("https://sports.news.naver.com/index");

// => URL 정보를 가지고 HTTP 요청을 수행할 객체를 얻는다.
URLConnection con = url.openConnection();

// => 웹서버와 연결한 후 HTTP 요청한다.
con.connect();

// URL.openStream()을 사용하는 것 보다 이점?
- 응답 헤더의 다양한 값을 추출할 수 있다.
System.out.printf("Content-Type: %s\n", con.getContentType());
System.out.printf("Content-Length: %d\n", con.getContentLength());
System.out.printf("Content-Encoding: %s\n", con.getContentEncoding());

// - 직접 헤더 이름을 사용해서 헤더 값을 추출할 수 있다.
System.out.printf("Content-Type: %s\n", con.getHeaderField("Content-Type"));
System.out.printf("Server: %s\n", con.getHeaderField("Server"));
System.out.println();

// => 웹서버의 응답 데이터를 읽어들일 도구를 리턴한다.
InputStream in = con.getInputStream();

// => 서버가 보낸 데이터를 한 줄씩 읽기 위해 데코레이터를 붙인다.
BufferedReader in2 = new BufferedReader(new InputStreamReader(in));

while (true) {
  String str = in2.readLine();
  if (str == null)
  break;

  System.out.println(str);
}
-------------------------------------------------------------------------------------
★ Base64 인코딩 ★
    String str = "AB";

    byte[] bytes = str.getBytes("UTF-8");
    for (byte b : bytes) {
      System.out.printf("%x ", b);
    }
    System.out.println();

    System.out.println("------------------------------");

    // => 바이너리 데이터를 문자화시킨다.
    // => 바이너리 값을 6비트식 잘라서(2의 6승) 
    //    64진수(0 ~ 63)으로 만든 후 Base64 표에 정의된 대로
    //    해당 값을 문자로 변환한다.
    // => 보통 바이너리 데이터를 텍스트로 전송하고 싶을 때 많이 사용한다.
    // => "ABC012가간" 문자열
    //    414243303132EAB080EAB081(UTF-8 코드)
    //    4142 ==> 0100000101000010... (2진수)
    //    010000 010100 0010... (6비트씩 자른 것)
    //    6비트로 자른 것을 다시 10진수로 표현하면 ==> 16 20 ...
    //    16을 Base64 코드표에 따라 문자로 바꾸면 ==> Q
    //    20을 Base64 코드표에 따라 문자로 바꾸면 ==> U
    //    ...
    //    이런 식으로 문자열을 Base64로 바꾸면 결과는 다음과 같다.
    //    QUJDMDEy6rCA6rCB6rCE
    Encoder encoder = Base64.getEncoder();
    byte[] base64Bytes = encoder.encode(bytes);
    System.out.println(new String(base64Bytes));

    System.out.println("------------------------------");

    // Base64 디코딩
    // => Base64 코드를 원래의 바이너리 값으로 변환한다.
    //
    Decoder decoder = Base64.getDecoder();
    byte[] bytes2 = decoder.decode(base64Bytes);
    System.out.println(new String(bytes2, "UTF-8"));

데이터(ABC012가각) → Base64 인코딩 → Base64 디코딩 → 데이터 
→ 원래 데이터 : ABC012가각 
→ UTF-16 : 0041 0042 0043 0030 0031 0032 AC00 AC01
→ UTF-8 : 41 42 43 30 31 32 EAB080 EAB081
→ 2진수 : 01000001 01000010 01000011 .....
→ 2진수를 6비트로 쪼갠다 : 010000/01 0100/0010 01/000011/ .....
→ 10진수 : 16 20 9 3 .....
→ Base64 : Q U J D ..... → 영어 대소문자, 숫자, +, /
→ 어떤 데이터를 Base64로 인코딩
→ 6비트 크기를 갖는 데이터로서 어떤 네트워크 환경에서도 송수신 할 수 있다
→ 강점 : 데이터를 문자화한다(인코딩 방법 = 포맷)
→ 사용처 
  → 바이너리 데이터를 텍스트에 포함해서 전송, 수신, 저장하고 싶을 때!!!!!
-------------------------------------------------------------------------------------
Base64 응용
URL : 프로토콜://호스트주소:포트번호/경로?파라미터=값&파라미터=값 .....
→ URL은 텍스트다! 
→ URL에 바이너리 데이터를 포함할 수 없다
→ http://blog.naver.com/add?title=""&content=""&file=""
→ file=photo.jpeg(바이너리 데이터) → URL에 포함 불가능
→ photo.jpeg(바이너리 데이터) → Base64로 인코딩 → 영어대소문자, 숫자, +, /로 변환 후 포함 → 문자이기 때문에 가능
→ 바이너리 데이터를 문자화한다(인코딩 방법 = 포맷)
→ 사용처 
  → 바이너리 데이터를 텍스트에 포함해서 전송, 수신, 저장하고 싶을 때!!!!!
-------------------------------------------------------------------------------------
병행(concurrency) 처리 = 동시 실행 = 프로세스 복제

① single
main() → 	for (i = 0; i < 100; i++), for (j = 0; j < 100; j++) → 종료

② concurrency
main() → 	for (i = 0; i < 100; i++)
main() → 	for (j= 0; j < 100; j++)
→ fork() = 프로세스 복제
→ 한 개의 작업을 동시에 여러 개 실행하기
→ 순차적으로 여러 번 실행 하는것보다 대기 시간이 적다

사용하는 경우
→ 작업 순서에 상관없는 경우 = 서로 간섭하지 않는 작업
  → 작업 시간을 줄일 수 있다
  A   →	┐
  B    →	→ 동시 실행 가능
  C   →	┘
→ 같은 작업을 여러 번 수행해야 하는 경우
  → 작업 시간을 줄일 수는 없다
       →	┐
    A  →	→ 동시 실행 가능
       →	┘

사용할 수 없는 경우
→ 순서를 지켜 수행해야 하는 경우 동시에 진행 할 수 없다
  A → B → C
-------------------------------------------------------------------------------------
병행 처리가 유용한 경우

① 선형 처리(linear) 유리 = 각 작업이 처리 속도가 같을 때
client     →    server(a.gif, b.gif, c.gif)(1MB/초)
→ a.gif 다운(100MB) = 100초
→ b.gif 다운(20MB) = 20초
→ c.gif 다운(30MB) = 20초
→ 순차적으로 다운로드 = 150초
→ CPU가 하나

② 병행 처리 유리 = 각 작업이 처리 속도가 다를 때 = 병행실행 시간의 총합이 순차실행 시간의 총합보다 적을 때!
client     →    server(a.gif)(1MB/초)
           └     server(b.gif)(10MB/초)
           └     server(c.gif)(15MB/초)
→ a.gif 다운(100MB) = 100초
→ b.gif 다운(20MB) = 2초
→ c.gif 다운(30MB) = 2초
→ 동시에 다운로드 = 100초
→ CPU가 여러 개

→ data seek time이 줄어든다
-------------------------------------------------------------------------------------



2024.01.23(화)
-------------------------------------------------------------------------------------
병행처리(concurrancy)

① 프로세스 복제
process(code segment(=기계어), data segment(=Heap=데이터)) → fork() 복제 → process(code segment, data segment)
→ 프로세스가 사용하는 Heap 메모리도 복제
→ 단점 : 메모리 사용이 과도하게 증가

② 스레드
process(code segment, data segment) 
→ 실행위치정보, stack
→ 실행위치정보, stack
→ 실행위치정보, stack
→ 프로세스의 Heap 메모리 공유
→ 장점 : 메모리 사용이 적다	
→ 코드 실행에 필요한 스택 메모리만 스레드별로 관리		
-------------------------------------------------------------------------------------
★ VPC(Virtual Private Cloud) 만들기
→ 가상의 개인 네트워크 공간

① 네트워크 : 10.1.0.0/16
→ 앞에서부터 16비트 고정 → 10.1
→ 10.1.0.0 ~ 10.1.255.255
→ bitcampncp-vpc

② Network ACL 
→ 접근제어 규칙(집 비밀번호)
→ bitcampncp-vpc-nacl

③ Subnet : 10.1.1.0/24
→ 10.1.1.0 ~ 10.1.1.255
→ bitcampncp-vpc-subnet1

④ Server ACG 
→ 서버 접근 제어 규칙(방화벽)
→ bitcampncp-vpc-acg1

⑤ Linux Server
→ bitcampncp-vpc-server1
-------------------------------------------------------------------------------------
java 스레드
$java Hello
java → JVM
<<process>JVM (Heap, Method Area) 
→ <<Thread>>main(실행위치정보) (stack) 
→ main() call -------------> 종료
		└> new Thread().start(); → <<Thread>>MyThread1(실행위치정보) (stack) → run() -------------> 종료
		└> new Thread().start(); → <<Thread>>MyThread2(실행위치정보) (stack) → run() -------------> 종료

→ 다른 실행 흐름
→ 병행으로 진행
→ 인스턴스(Heap)은 스레드끼리 공유
→ main Thread = parent Thread
→ MyThread1 = child Thread
-------------------------------------------------------------------------------------
스레드 만드는 방법

① 상속
class MyThread extends Thread{
  run(){
    → run() 메소드 오버라이딩
    → 병행으로 실행시킬 코드를 둔다
  } 
}
new MyThread().start();

② 인터페이스 구현
interface Runnable{
  void run();
}

new Thread(new Runnable() {
  @Override
  public void run() {
    → run() 메소드 오버라이딩
    → 병행으로 실행시킬 코드를 둔다
  }
}).start();
→ 인터페이스 구현을 람다 문법으로 바꿀 수 있어서 더 많이 쓰인다	
-------------------------------------------------------------------------------------
JAM의 기본 스레드
→ 기본적으로 <<Thread>>main를 갖고 있다

JVM → System/
             → main/
                  → main스레드
	→ InnocuousThreadGroup
	→ Reference Handler
   	→ Finalizer
   	→ Signal Dispatcher
   	→ Attach Listener
   	→ Notification Thread


// 현재 스레드의 이름
Thread main = Thread.currentThread();
System.out.println("실행 흐름명 = " + t.getName());

// 스레드는 그룹에 소속되기도 한다.
// 현재 스레드의 소속 그룹을 알고 싶다면?
ThreadGroup group = main.getThreadGroup();
System.out.println("그룹명 = " + group.getName());

// 스레드 그룹에 소속된 스레드 목록을 알고 싶다면?
Thread[] arr = new Thread[100];
int count = mainGroup.enumerate(arr, false);
// 두 번째 파라미터 값을 false로 지정하면,
// 하위 그룹에 소속된 스레드들은 제외한다.
// 즉, 현재 그룹에 소속된 스레드 목록만 가져오라는 뜻!

System.out.println("main 그룹에 소속된 스레드들:");
for (int i = 0; i < count; i++)
  System.out.println("   => " + arr[i].getName());

// 스레드 그룹에 소속된 하위 그룹을 알고 싶다면?
ThreadGroup[] groups = new ThreadGroup[100];
int count = mainGroup.enumerate(groups, false);
// 두 번째 파라미터 값을 false로 지정하면,
// 하위 그룹에 소속된 그룹들은 제외한다.
// 즉, 현재 그룹에 소속된 하위 그룹의 목록만 가져오라는 뜻!

System.out.println("main 그룹에 소속된 하위 그룹들:");
for (int i = 0; i < count; i++)
  System.out.println("   => " + groups[i].getName());

// 스레드 그룹의 부모 그룹을 알고 싶다면?
ThreadGroup parentGroup = mainGroup.getParent();
System.out.printf("main 스레드 그룹의 부모: %s\n", parentGroup.getName());

// "system" 그룹의 부모 그룹은?
ThreadGroup grandparentGroup = parentGroup.getParent();
if (grandparentGroup != null) {
  System.out.printf("%s 스레드 그룹의 부모: %s\n", 
    parentGroup.getName(), 
    grandparentGroup.getName());
}

// System 스레드 그룹의 자식 그룹들
ThreadGroup[] groups = new ThreadGroup[100];
int count = systemGroup.enumerate(groups, false);

System.out.println("system 스레드 그룹의 자식 그룹들:");
for (int i = 0; i < count; i++) {
  System.out.println("   =>" + groups[i].getName());
}

// System 스레드 그룹에 소속된 스레드들
Thread[] arr = new Thread[100];
int count = systemGroup.enumerate(arr, false);

System.out.println("system 스레드 그룹에 소속된 스레드들:");
for (int i = 0; i < count; i++) {
  System.out.println("   =>" + arr[i].getName());
}
-------------------------------------------------------------------------------------
멀티태스킹
→ 동시에 여러 작업을 실행하는 것(병행 처리 = concurrenry)
    → 별도의 cpu로 실행 = 완전한 동시 실행
    → 하나의 cpu로 돌아가면서 실행 = 현실!
        → 여러 프로세스를 왔다갔다 하면서 실행
        → 가능한 이유는 cpu가 매우 빠르다
CPU
→ process 
→ process 
→ process 
-------------------------------------------------------------------------------------
CPU Scheduling
→ 여러 프로세스를 돌아가면서 실행하는 규칙
→ OS가 관리

① Round-Robin(windows)
→ 일정 시간을 돌아가면서 실행한다
CPU
→ A process → 0.01초
→ B process → 0.01초
→ C process → 0.01초

② priority + aging(unix/linux)
→ 우선순위가 높은 프로세스를 더 자주 실행
CPU
→ A process(1순위) → 4번 실행
→ B process(3순위) → 1번 실행
→ C process(2순위) → 2번 실행
-------------------------------------------------------------------------------------
context switching
→ 실행 정보 교환
→ 너무 자주 교환하면 명령을 실행하는 시간보다 context switching 하는데 시간을 다 낭비하게 된다
→ 컨텍스트 스위칭 시간을 최적화 하는게 중요하다!
→ OS가 고민할 문제다!!

cpu 
→ a 실행 → a의 실행 상태 저장 
→ b 실행 → b의 실행 상태 저장
→ a의 실행 상태 로딩 → 이어서 실행 → a의 실행 상태 저장
→ b의 실행 상태 로딩 → 이어서 실행 → b의 실행 상태 저장
-------------------------------------------------------------------------------------
★ 스레드 주의사항
// CPU 사용을 스레드에게 배분할 때, 스레드를 생성한 순서대로 배분하지는 않는다.
// OS의 CPU 스케줄링 정책에 따라 스레드가 실행된다.
// 즉 JVM에서 스레드를 실행하는 것이 아니라 OS가 실행한다.
// 결론!
// => 똑 같은 자바의 스레드 코드가 OS에 따라 실행 순서가 달라질 수 있다.
//
// 우선 순위로 조정하면 되지 않나요?
// => Windows OS의 경우 우선 순위(priority) 값이 실행 순서나 실행 회수에 큰 영향을 끼치지 않는다.
//    그래서 우선 순위의 값을 조정하여 스레드의 실행 회수를 조정하려 해서는 안된다.
// => 왜? OS에 따라 실행 정책이 다르기 때문이다.
// => 그냥 특정 코드를 동시에 실행하고 싶을 때 스레드를 사용한다고 생각하라!
// 모든 스레드가 끝날 때까지 프로그램은 종료 되지 않는다 
// => 메인 스레드가 끝났다고 해도 다른 스레드가 실행 중이라면 프로그램 종료가 아니다!!
-------------------------------------------------------------------------------------
익명 클래스
→ 이름이 없는 클래스
→ 일회성으로 사용되는 간단한 클래스를 정의할 때 유용한 기능
→ 인터페이스를 구현하거나 클래스를 상속할 때 사용
-------------------------------------------------------------------------------------



2024.01.24(수)
-------------------------------------------------------------------------------------
리눅스 update

① prompt 기호
# → 관리자
$ → 일반 사용자

② 패키지 update
# apt update
$ sudo apt update
sudo → 관리자 권한으로 실행 

③ 사용자 추가
# adduser student
new password : ncp!@#123

④ 관리자 권한으로 일반 사용자를 sudo 그룹에 추가
# usermod -aG sudo student
-------------------------------------------------------------------------------------
IP주소 표기 방법
CIDR(Classless Inter-Domain Routing) (사이더) → 10.1.0.0/16
→ 앞 16비트를 고정 뒤 16비트로 가변 주소 할당 가능
-------------------------------------------------------------------------------------
스레드의 생명주기(thread lifecycle)
// new Thread()    start()              sleep()/wait()
//     준비 -------------------> Running ---------------> Not Runnable
//                                      ^  |    <---------------
//                                       |  |    timeout/notify()
//                                      X  |
//                                       |  |  run() 메서드(실행) 종료
//                                       |  V
//                                     Dead
// Running 상태?
// - CPU를 받아서 실행 중이거나 CPU를 받을 수 있는 상태
//
// Not Runnable 상태?
// - CPU를 받지 않는 상태
// 
// run() 메서드 종료 후 다시 running 상태로 돌아갈 수 없다. 
// => 새로 스레드를 만들어 실행하는 방법 밖에 없다!
-------------------------------------------------------------------------------------
스레드 메소드 활용

// t 스레드가 종료될 때까지 "main" 스레드는 기다린다.
t.join();
// 즉 t 스레드가 종료된 후 다음 코드를 실행한다.
System.out.println("스레드 종료 후");

// 3초 동안 not runnable 상태로 만든다.
// => 즉 3초 동안 CPU가 놀고 있더라도 CPU를 사용하지 않는다.
// => 3초가 지나면(timeout) 다시 "main" 스레드는 CPU를 받아 실행할 수 있다.
// => sleep()을 호출하면 그 순간에 실행하는 스레드를 잠들게 한다.
Thread.sleep(3000); // milliseconds

// 스레드 우선 순위 정보

// => 스레드의 우선 순위 범위
System.out.printf("우선 순위 범위: %d ~ %d\n", //
  Thread.MIN_PRIORITY, //
  Thread.MAX_PRIORITY);

// => 스레드의 기본 우선 순위
System.out.printf("우선 순위 기본값: %d\n", Thread.NORM_PRIORITY);

// => "main" 스레드의 우선 순위 조회
System.out.printf("main 스레드 우선 순위: %d\n", Thread.currentThread().getPriority());

// 스레드의 우선순위 설정
MyThread t1 = new MyThread("홍길동(1)");
t1.setPriority(1);
-------------------------------------------------------------------------------------
스레드 실행
main 스레드 → main() call ----------------------> 종료
			→ T1 스레드 → run() call → 종료
			→ T2 스레드 → run() call → 종료
			→ T3 스레드 → run() call → 종료
-------------------------------------------------------------------------------------
Critical Region = Critical Section
→ 여러 스레드가 같은 변수의 값을 변경할 때 기존 값을 덮어 쓸 수 있는 문제가 발생하는 코드
→ 여러 스레드가 같은 변수의 값을 변경할 때 기존에 작업한 값을 덮어쓰는 문제가 발생한다(add())
→ Thread safe(스레드가 안전) 하지 않다
→ Critical Region = Critical Section

Thread safe
→ 여러 스레드가 동시에 실행하더라도 문제가 발생하지 않는 코드
→ 같은 변수를 여러 스레드가 접근하더라도 변경이 아닌 조회용으로 사용할 경우 문제가 발생하지 않는다(print())
→ Thread safe(스레드가 안전) 하다

<<Thread>> Woker → w1 → add(111) → Mylist → int[] 
<<Thread>> Woker → w2 → add(222) → Mylist → int[]
<<Thread>> Woker → w3 → add(333) → Mylist → int[]
→ 20번씩 add()를 호출한다고 가정하면 int[] 배열에는 총 60개의 값이 들어가야 한다
→ 실제 실행을 해보면 중간 중간에 값을 덮어쓰는 경우가 발생한다

new[] values = new int[100];
add(int value){
  values[size] = value;
  size = size+1;
}

w3 → value[0] = 333 → size에 1을 더해야 하는데 cpu를 뺏겨서 대기중
w1 → value[0] = 111 → size = 1 하고 cpu를 뺏겨서 대기중
w2 → value[1] = 222 → size = 2 하고 cpu를 뺏겨서 대기중
w3 → size = 3 → value[3] = 333 → size = 4 하고 cpu를 뺏겨서 대기중
→ 111(333) 222 0 333 0 ..... 0
-------------------------------------------------------------------------------------
Critical Section(Region) 을 Thread safe로 전환하는 방법

// Critical Section에 오직 한 개의 스레드만 접근하게 하면 
// 비동기로 인한 문제가 발생하지 않는다.
// => 즉 동기화로 처리한다.
// => 동기화? 
//    - 여러 스레드가 동시에 실행하는 것이 아니고
//      여러 스레드가 순차적으로 접근하는 것.
//    - 단 순차적으로 실행한다는 것은 동시 실행의 이점을 버리는 것이기 때문에
//      스레드를 사용하기 전의 상태와 같다.
//      기존의 실행 방식 처럼 실행 시간이 많이 걸린다.
// 
// 다음 메서드를 동기화 처리해 보자.
// => synchronized
//    - 크리티컬 섹션 구간에 이 키워드를 붙이면 오직 한 번에 한 개의 스레드만이 접근할 수 있다.
//    - 먼저 접근한 스레드가 나가야만 다음 스레드가 진입할 수 있다.
//    - 즉 크리티컬 섹션을 뮤텍스 구간으로 설정한다.

synchronized void add(int value){
  values[size] = value;
  size = size+1;
}

synchronized → 한 번에 한 스레드만 진입 가능 = semmaphore(1) = mutex(Mutual Exclusion)
-------------------------------------------------------------------------------------
인스턴스와 synchronized ⅰ
synchronized play() → critical section일 경우 → 인스턴스1, 인스턴스2

인스턴스1 사용
T1 → play() call → 대기
T2 → play() call → 실행
T3 → play() call → 대기

인스턴스2 사용
T1 → play() call → 대기
T2 → play() call → 대기
T3 → play() call → 실행

→ 다른 인스턴스를 사용하기 때문에 2개의 스레드가 진입 가능
-------------------------------------------------------------------------------------
인스턴스와 synchronized ⅱ
인스턴스 → play1(), play2(), play3()
Worker1 → play1() call → 대기
Worker2 → play2() call → 실행
Worker3 → play3() call → 대기
Worker4 → play1() call → 대기
-------------------------------------------------------------------------------------
인스턴스와 synchronized ⅲ
인스턴스1 → play1(), play2(), play3()
인스턴스2 → play4(), play5(), play6()
Worker1 → play1() call → 대기
Worker2 → play2() call → 실행
Worker3 → play3() call → 대기
Worker4 → play4() call → 실행
-------------------------------------------------------------------------------------



2024.01.25(목)
-------------------------------------------------------------------------------------
스레드 생성
JVM → 스레드 생성 요청 → OS → 생성 → 스레드(peer) → JVM에게 스레드 정보 리턴
└> Thread 인스턴스(스레드 정보) → 제어 → 스레드(peer)

→ 스레드 생성에 시간 소요
→ 메모리 사용
→ 자주 스레드를 생성하고 버리면 실행시간과 메모리 효율성이 떨어진다
→ 개선방안
  → 스레드 재사용
-------------------------------------------------------------------------------------
스레드 생명주기
new Thread() → start() → Runnable <= notify()(작업을 다시 시작) wait()(작업이 끝나면) => Not Runnable
			└> Read to Run/Running → run() 실행 종료 → Dead
-------------------------------------------------------------------------------------
스레드 재사용
재사용 전
App → new → Thread → 100까지 출력
       └> new → Thread → 20까지 출력
       └> new → Thread → 72까지 출력
→ 매번 스레드 인스턴스 생성 = OS의 스레드 생성
→ 작업 종료 후 가비지 = 일정시간동안 메모리 차지 = 가비지 컬렉터가 메모리를 해제하기 전까지 메모리 차지

재사용 후
new Thread() → start() → Runnable <= sleep()/timeout => Not Runnable
			└> Running → run() → dead
→ 작업이 끝나면 다음 작업을 준비할 수 있게 일정시간 동작을 멈춘다
→ 설정된 시간이 끝나면 준비된 작업을 실행한다
-------------------------------------------------------------------------------------
synchronized 메소드가 없을 때 not runnable 상태 만들기
synchronized (this) {
    this.wait();
    this.notify();
}
-------------------------------------------------------------------------------------
과제 45. ServerApp에서 스레드 재사용하기

① 기존 방식
C1 → 연결 → Server → 서버와 통신을 하고 스레드 종료
C1 → 연결 → Server → 서버와 통신을 하고 스레드 종료
C1 → 연결 → Server → 서버와 통신을 하고 스레드 종료

② 개선 → Pooling 기법 적용
s = Socket
ss = ServerSocket
1)
Client1 s → 연결 → ss Server → get → Thread pool(스레드 저장소) → 스레드(T1)를 생성하고 리턴
		└> accept() →  s T1 → 클라이언트와 통신
2)
Client1 s < 통신 > s T1
Client2 s → 연결 → ss Server → get → Thread pool(스레드 저장소) → 스레드(T2)를 생성하고 리턴
		└> accept() → s T2 → 클라이언트와 통신
3)
Client1 s < 통신 > s T1 → 통신 종료 → Thread pool(스레드 저장소)에 T1을 반납 
Client2 s < 통신 > s T2
Client3 s → 연결 → ss Server → get → Thread pool(스레드 저장소) → 스레드(T1)를 리턴
		└> accept() → s T1 → 클라이언트와 통신
-------------------------------------------------------------------------------------
Pooling 기법 적용
→ 생성된 객체가 있으면 재사용해서 자원을 효율적이게 사용하자
→ GoF의 Flyweight 디자인 패턴과 유사하다 = 하나의 객체를 이용해서 새로운 객체를 만들 때 사용한다
→ 객체 생성 → (재)사용 → 보관 → (재)사용
→ 객체 생성에 비용(시간, 메모리)이 큰 경우 사용한다
-------------------------------------------------------------------------------------
★ java의 ThreadPool → ExecutorService ★
→ Executors.newFixedThreadPool();
→ Executors.newCachedThreadPool();
→ Executors.newSingleThreadPool();

★ 1) 불변 스레드 풀
Executors.newFixedThreadPool(3) → executorService 
Runnable 구현 객체를 생성자에 넣어준다 → executorService.excute() → 스레드 생성 → Thread.start() → run() → pool에 보관

// 스레드풀을 생성한다.
// - 최대 3개의 스레드를 생성한다.
// 스레드풀 개수를 고정하는 객체 생성(=팩토리 메소드)
ExecutorService executorService = Executors.newFixedThreadPool(3);

// 스레드풀에 작업 수행을 요청한다.
// - 작업은 Runnable 구현체로 작성하여 넘겨준다.
// - 스레드풀은 스레드를 생성하여 작업을 수행시킨다.
executorService.execute(() -> System.out.printf("%s - Hello!\n", Thread.currentThread().getName()));

// 스레드풀에 있는 모든 스레드들이 요청한 작업을 끝내면
// 종료하도록 지시한다.
// 모든 스레드가 종료될 때까지 기다리지 않고 바로 리턴한다.
// shutdown() 호출 이후에는 새 작업 요청은 받지 않는다.
// 즉 execute()를 호출하면 예외가 발생한다.
executorService.shutdown();

★ 2) 가변 스레드 풀 
// 스레드의 수를 고정하지 않고 필요할 때마다 스레드를 생성하는 스레드풀이다.
// 물론 작업을 끝낸 스레드는 다시 사용할 수 있도록 pool에 보관한다.
ExecutorService executorService = Executors.newCachedThreadPool();

// 놀고 있는 스레드가 없으면 새 스레드를 생성한다.
//
executorService.execute(new MyRunnable(6000));
executorService.execute(new MyRunnable(2000));
executorService.execute(new MyRunnable(9000));
executorService.execute(new MyRunnable(1000));

// 작업을 끝낸 스레드가 생길 때까지 일부러 기다린다.
//
Thread.sleep(3000);

// 그러면 새 스레드를 생성하지 않고
// 작업을 끝낸 스레드가 요청한 작업을 처리한다.
//
executorService.execute(new MyRunnable(4000));

executorService.shutdown();

★ 3) 싱글 스레드 풀
// 한 개의 스레드만 갖는 스레드풀이다.
ExecutorService executorService = Executors.newSingleThreadExecutor();

// 스레드가 한 개이기 때문에 순차적으로 실행한다.
executorService.execute(new MyRunnable(6000));
executorService.execute(new MyRunnable(3000));
executorService.execute(new MyRunnable(9000));
executorService.execute(new MyRunnable(2000));
executorService.execute(new MyRunnable(4000));

executorService.shutdown();
-------------------------------------------------------------------------------------
★ 스레드 풀 활용

1)
// 스레드풀에 수행할 작업을 등록한다.
// 스레드풀은 execute()를 호출한 순서대로 작업큐에 작업을 보관한다.
// 그리고 놀고 있는 스레드가 있다면, 작업큐에서 작업을 꺼내 수행시킨다.
// 놀고 있는 스레드가 없으면, 새로 스레드를 생성한다.
// 스레드가 최대 개수라면 기존 스레드가 작업을 끝낼 때까지 기다린다.
// => 수행한 작업의 종료 여부를 확인할 수 없다.
executorService.execute(new MyRunnable(6000));

// 더이상 맡은 작업이 없으면 스레드풀을 종료하라고 지시한다
executorService.shutdown();

2)
// execute()와 같다.
// => 단 작업의 종료 상태를 확인할 수 있는 Future 객체를 리턴한다.
// => 커피숍에서 주문한 후 알람벨을 받는 것과 같다!
Future<?> future1 = executorService.submit(new MyRunnable(2000));
Future<?> future2 = executorService.submit(new MyRunnable(4000));

// Future.get()
// => 요청한 작업이 완료될 때 까지 기다린다.(pending)
// => 요청한 작업이 완료되면 null을 리턴한다.
//
future2.get();
System.out.println("두 번째 작업이 끝났음");

future1.get();
System.out.println("첫 번째 작업이 끝났음");
-------------------------------------------------------------------------------------
★ shutdown() vs shutdownNow();

ExecutorService executorService = Executors.newFixedThreadPool(3);
Thread Pool => (T1 | T2 | T3)

executorService.execute(new MyRunnable(작업));
execute(작업1) ------ 
execute(작업2) |	| 
execute(작업3) |	------> Queue(작업5 | 작업4 | 작업3 | 작업2 | 작업1)
execute(작업4) |	|
execute(작업5) ------

T1 → run() → 작업1
T2 → run() → 작업2

// 가능한 현재 수행 중인 작업들을 모두 멈추도록 지시한다.
// => shutdown()과 차이점:
// - 만약 Running 상태의 스레드가 Not Runnable 상태(sleep()/wait())에 놓인다면,
// 바로 스레드를 멈출 기회라고 보고 스레드를 강제 종료할 것이다.
// - 즉 실행 중인 작업만 완료시키고, 대기 중인 작업은 취소시키는 효과가 있다.
// => Running 상태에서 Not Runnable 상태가 될 때까지 기다린다.
// => 그리고 취소한 대기 작업 목록을 리턴해준다.
// => 현재 스레드가 실행 중인 작업은 완료하고 나머지 작업은 취소해!
List<Runnable> tasks = executorService.shutdownNow();
System.out.println("실행 취소된 작업들:");
System.out.println("--------------------------------");
for (Runnable task : tasks) {
      System.out.println(((MyRunnable) task).millisec);
}
System.out.println("--------------------------------");

// 물론 새 작업 요청도 거절한다.
// => 예외 발생!
// executorService.execute(new MyRunnable(4000));

// shutdown() vs shutdownNow();
// - shutdown()
// 진행 중인 작업을 완료하고 대기 중인 작업도 완료한 다음 종료.
// - shutdownNow()
// 진행 중인 작업은 완료하고, 대기 중인 작업은 취소하고 그 목록을 리턴한다.
-------------------------------------------------------------------------------------
★ 스레드풀 종료 대기
→ main 스레드를 유지하고 싶을 때 사용한다

// 스레드풀의 모든 스레드가 종료되면 즉시 true를 리턴한다.
// 만약 지정된 시간(예: 10초)이 경과할 때까지 종료되지 않았다면 false를 리턴한다.
//
if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {
  System.out.println("아직 종료 안된 작업이 있다.");
} else {
  System.out.println("모든 작업을 종료하였다.");
}
-------------------------------------------------------------------------------------



2024.01.26(금)
-------------------------------------------------------------------------------------
과제 47. DBMS 도입하기
- DBMS 설치 및 사용법
- SQL 및 JDBC Driver 개념과 사용법
- 회원 및 게시판 테이블 정의 및 예제 데이터 입력 SQL 준비
- DBMS와 연동하여 작업하는 DAO 구현
-------------------------------------------------------------------------------------
Database Management System
DBMS <관리> Database(파일 저장소)
→ 데이터 정의
→ 업데이트
→ 검색
→ 관리
  → 사용자 등록/모니터링
  → 데이터 보안
  → 성능 모니터링
  → 데이터 무결성 유지
  → 동시성 제어
  → 오류 제어
-------------------------------------------------------------------------------------
★ DBMS와 통신
Oracle, SQLServer=MS가 만듦, DB2=IBM이 만듦, MySQL=Oracle이 만듦, postgreSQL, 
(Altibase, Tibero, Cubrid 한국에서 만듦)

App <call/return> <Vendor API=Native API> = 각 회사가 제공한다
App <call/return> Oracle client API <DBMS 전용 프로토콜을 이용해 요청/응답> OracleDBMS
App <call/return> SQLServer client API <DBMS 전용 프로토콜을 이용해 요청/응답> SQLServer
App <call/return> MySQL client API <DBMS 전용 프로토콜을 이용해 요청/응답> MySQL

→ c/c++로 만들었다
→ DBMS 마다 API 사용법이 다르다
  → 프로그래밍의 일관성이 없다
→ DBMS 마다 따로 App 작성 = 전용 App이 필요하다
→ 개발비 증가
→ 전용 DBMS client API(function=method)가 DBMS와 직접 통신
-------------------------------------------------------------------------------------
★ ODBC(Open Database Connectivity)

App <call/return> ODBC Driver <통신> Vendor API=Native API <통신> DBMS
App <call/return> ODBC API(규칙=명세) <= call/return => <Vendor API=Native API> = 각 회사가 제공한다
App <call/return> Orcle ODBC 구현체 <= call/return => Oracle client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => OracleDBMS
App <call/return> SQLServer ODBC 구현체 <= call/return => SQLServer client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => SQLServer
App <call/return> MySQl ODBC 구현체 <= call/return => MySQL client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => MySQL

→ 호출 규칙이 동일하기 때문에 App을 한번만 작성하면된다
→ c/c++로 만들었다 = java App으로는 호출 불가능하다
-------------------------------------------------------------------------------------
★ JDBC Driver (Java Database Connectivity Driver)
→ jaca.sql.*    javax.sql.*

① Type1 드라이버
java App < call/return > JDBC Driver < call/return > ODBC Driver <통신> Vendor API=Native API <통신> DBMS
java App < call/return > JDBC Driver < call/return > Orcle ODBC 구현체 <= call/return => Oracle client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => OracleDBMS
				      └>	SQLServer ODBC 구현체 <= call/return => SQLServer client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => SQLServer
				      └>	MySQl ODBC 구현체 <= call/return => MySQL client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => MySQL
→ ODBC-JDBD Bridge
→ JRE에 기본 포함
→ local에 설치된 ODBC 드라이버를 사용
→ 실행속도 느리다

② Type2 드라이버 = Native API call
java App <call/return> JDBC Driver <call/return> Vendor API=Native API <통신> DBMS
java App <= call/return => Oracle JDBC Driver <= call/return => Oracle client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => OracleDBMS
		└> SQLServer JDBC Driver <= call/return => SQLServer client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => SQLServer
	             └> MySQL JDBC Driver <= call/return => MySQL client API <= DBMS 전용 프로토콜을 이용해 요청/응답 => MySQL
→ Vendor에서 다운로드 해야함
→ local에 설치된 Native API를 사용
→ Type1 보다 속도 빠르다
→ DBMS를 교체하면 로컬에 설치된 JDBC 드라이버도 교체해야한다

★ ③ Type4 드라이버 = native 드라이버
java App <call/return> JDBC Driver <통신> DBMS
java App <= call/return => Oracle JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => OracleDBMS
		└> SQLServer JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => SQLServer
		└> MySQL JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => MySQL
→ Vendor에서 다운로드 해야함
→ local에서 c/c++ API 설치 불필요
→ 순수 자바 드라이버(pure Java)
→ DBMS를 교체하면 로컬에 설치된 JDBC 드라이버도 교체해야한다

④ Type3 드라이버 = network 드라이버
                        <local> 			|                  <Middleware>                     |	<Server>
java App <call/return> 중계서버 JDBC 드라이버 <통신> 중계서버 <call/return> JDBC Driver <통신> DBMS
java App <= call/return => 중계서버 JDBC 드라이버 <통신> 중계서버 <call/return> Oracle JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => OracleDBMS
		                                                                       └> SQLServer JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => SQLServer
		                                                                       └> MySQL JDBC Driver <= DBMS 전용 프로토콜을 이용해 요청/응답 => MySQL
→ 3rd-party에 다운로드
→ 미들웨어 서버 구매 비용 발생
→ 특정 DBMS에 종속이 안됨
→ DBMS 교체 → 미들웨어 서버측만 JDBC 드라이버 파일을 교체하면된다
-------------------------------------------------------------------------------------
JDBC API 프로그래밍

① JDBC Driver 준비
→ java.sql.Driver 구현체를 생성하여 DriverManager에 등록한다
→ Service Provider 명세에 따라 JDBC Driver 파일에 들어있는 설정대로 Driver 객체를 자동으로 생성하고 등록한다
Driver diver = new com.mysql.jdbc.Driver();
DriverManager.register(driver);
→ 생략 가능!

② DriverManager를 통해 DBMS 연결을 요청
Connection con = DriverManager.getConnection(url, user, password);
Connection con = DriverManager.getConnection("jdbc:mysql://localhost/studydb", "study", "1111");
-------------------------------------------------------------------------------------
DBMS 사용하기

① 직접사용
user <= 입력/출력 => MySQL client(mysql.exe) <= 명령어 전달/응답 => MySQL Server(mysqld.exe) → 처리
→ c/s Architecture
→ 입력할 때 SQL 문법으로 입력
→ 명령어 전달할 때 SQL 문법으로 전달

② App에서 사용
user <= 입력/출력 => App <= call/return => JDBC Driver(mysql-connector-j.jar) <= 명령어 전달/응답 => MySQL Server → 처리
→ App이 SQL 명령어로 JDBC Driver를 호출한다
-------------------------------------------------------------------------------------



2024.01.29(월)
-------------------------------------------------------------------------------------
JDBC API 프로그래밍

① JDBC Driver 준비
→ java.sql.Driver 구현체를 생성하여 DriverManager에 등록한다
→ Service Provider 명세에 따라 JDBC Driver 파일에 들어있는 설정대로 Driver 객체를 자동으로 생성하고 등록한다
Driver diver = new com.mysql.jdbc.Driver();
DriverManager.register(driver);
→ 생략 가능!

② DriverManager를 통해 DBMS 연결을 요청
Connection con = DriverManager.getConnection(url, user, password);
Connection con = DriverManager.getConnection("jdbc:mysql://localhost/studydb", "study", "1111");

③ SQL을 DBMS에 전달해줄 객체 준비
Statement stmt = con.createStatement();

④ SQL을 DBMS에게 전달
ResultSet rs = stmt.executeQuery(SQL문);
→ 실행 결과의 번호표를 리턴

⑤ select 실행결과 데이터중 한 개의 데이터(= record, row, tuple)를 서버에서 가져오기
re.next();
→ 다음 번호에 해당하는 값(레코더, 1행, 1튜플)을 리턴

⑥ 서버에서 가져온 레코드에서 컬럼 값 꺼내기 
rs.getString(컬럼이름 or 컬럼번호); → 문자열
rs.getInt(컬럼이름 or 컬럼번호); → 숫자
int boardNo = rs.getInt("board_no");
String title = rs.getString("title");
String content = rs.getString("content");
String writer = rs.getString("writer");
Date createdDate = rs.getDate("created_date");
-------------------------------------------------------------------------------------
sql 기본적인 문법
DDL : Data Definition Language

-- 로그인
mysql -u study -p
Bitcamp!@#123

-- 데이터베이스 보기
show databases;

-- 테이블 고기
show tables;

-- 사용할 데이터베이스 지정
use studydb;

-- 테이블 생성
create table boards(
  board_no int primary key auto_increment,
  title varchar(255) not null,
  content text not null,
  writer varchar(30) not null,
  created_date datetime null default now()
);

-- 테이블 제거
drop table boards;

insert into boards(board_no, title, content, writer)
  values(1, '제목1', '내용1', '홍길동');
insert into boards(board_no, title, content, writer)
  values(2, '제목2', '내용2', '임꺽정');
insert into boards(board_no, title, content, writer)
  values(3, '제목3', '내용3', '유관순');
insert into boards(board_no, title, content, writer)
  values(4, '제목4', '내용4', '안중근');
insert into boards(board_no, title, content, writer)
  values(5, '제목5', '내용5', '윤봉길');

select * from boards;

select *
from boards
where board_no = 3;

update boards set
  title='okok',
  content='nono',
  writer='hoho'
where board_no = 3;

delete from boards where board_no=3;
-------------------------------------------------------------------------------------
비밀번호 암호화
insert into members(email, name, password) values('a@a', '이순신', sha2('aaa', 256));
update members set email='aa@aa', name='홍길동', password=sha2('abcde',256) where member_no=1;
-------------------------------------------------------------------------------------



2024.01.30(화)
-------------------------------------------------------------------------------------
★ SQL(Structured Query Language)
→ DBMS에게 내릴 명령을 작성하는 프로그래밍 언어
client <= sql명령문/결과 => DBMS <= in/out => 파일

표준문법 + DBMS 전용 문법 = 실무 SQL
표준문법 → DBMS 수준에 따라 지원율이 다르다(모든 DBMS에 합집합)
DBMS 전용 문법 → DBMS마다 다르다

DDL(Data Definition Language)
→ 테이블, 뷰, 함수 등을 정의, 삭제, 변경
DML(Data Manipulation Languge)
→ 데이터 입력, 변경, 삭제
DQL(Data Query Languge)
→ 데이터 조회
-------------------------------------------------------------------------------------
★ key
→ 데이터를 구분할 때 사용하는 값 또는 집합
key(candidate key=후보키(primary key=주키, alternate key=대안키))

예)
- {email}, {jumin}, {id}, {name, tel}, {tel, basic_addr, gender, name}
- {name, jumin}, {email, id}, {id, name, email} ...

- candidate key (후보키 = 최소키)
  - key 들 중에서 최소 항목으로 줄인 키
  - {jumin}, {email}, {id}, {name, tel}
- primary key(주키)
  - 후보키 중에서 DBMS 관리자가 사용하기로 결정한 키
  - {id}
- alternate key(대안키)
  - 후보키 중에서 주키로 선택된 키를 제외한 나머지 키
  - {jumin}, {email}, {name, tel}
- artificial key=surrogate key(인공키=대리키)
  - 주키로 사용하기에 적절한 컬럼을 찾을 없다면 key로 사용할 컬럼을 추가한다

- 두 개 이상의 컬럼을 묶어서 PK로 선언하고 싶다면
  - constraint 제약조건이름 primary key (컬럼명, 컬럼명, ...)
  - constraint test1_pk primary key(name, age)

- PK는 아니지만 PK처럼 중복되어서는 안되는 컬럼을 지정할 때 사용한다.
- 그래서 PK를 대신해서 사용할 수 있는 key라고 해서 "대안키(alternate key)"라고 부른다.
- 즉 대안키는 DBMS에서 unique 컬럼으로 지정한다.
  - constraint test1_uk unique (name, age)
-------------------------------------------------------------------------------------
★ 컬럼 타입

#### int
- 4바이트 크기의 정수 값 저장
- 기타 tinyint(1바이트), smallint(2바이트), mediumint(3바이트), bigint(8바이트)

#### float
- 부동소수점 저장

#### numeric = decimal
- 전체 자릿수와 소수점 이하의 자릿수를 정밀하게 지정할 수 있다.
- numeric(n,e) : 전체 n 자릿수 중에서 소수점은 e 자릿수다.
  - 예) numeric(10,2) : 12345678.12
- numeric : numeric(10, 0) 과 같다.

#### char
char(5) - 불변 
varchar(5) - 가변 

#### text(65535), mediumtext(약 1.6MB), longtext(약 4GB)
- 긴 텍스트를 저장할 때 사용하는 컬럼 타입이다.
- 오라클의 경우 long 타입과 CLOB(character large object) 타입이 있다.

#### date
- 날짜 정보를 저장할 때 사용한다.
- 년,월,일 정보를 저장한다.
- 오라클의 경우 날짜 뿐만 아니라 시간 정보도 저장한다.

#### time
- 시간 정보를 저장할 때 사용한다.
- 시, 분, 초 정보를 저장한다.

#### datetime
- 날짜와 시간 정보를 함께 저장할 때 사용한다.

#### boolean
- 보통 true, false를 의미하는 값을 저장할 때는 정수 1 또는 0으로 표현한다.
- 또는 문자로 Y 또는 N으로 표현하기도 한다.
- 실제 컬럼을 생성할 때 tinyint(1) 로 설정한다.
-------------------------------------------------------------------------------------
★ index 컬럼

rowid name age kor math eng
1  안중근  24  80  80  80
2  임꺽정  20  90  90  90
3  유관순  18  100  100  100
4  홍길동  20  100  100  100 
5  김구    50  70  70  70

rowid → DBMS가 레코드에 붙이는 관리번호
→ name을 index 컬럼 설정
→ DBMS가 인덱스 테이블을 생성하고(A~Z)
rowid
김구     5
안중근  1
유관순  3
임꺽정  2
홍길동  4
select * from table where name='유관순';
→ 조건을 가지고 인덱스 테이블에서 찾는다
→ name 컬럼이 정렬됐기 때문에 더 빨리 찾을 수 있다
  → 인덱스 컬럼으로 찾을 때 속도 빠르다 단 입력, 변경, 삭제할 때마다 색인표를 갱신해야 한다
  → 입력, 변경, 삭제할 때마다 속도가 느리다
  → 조회 위주의 작업을 하는 테이블에 인덱스 설정을 한다
  → 입력, 변경, 삭제가 잦은 테이블에는 인덱스를 걸지 않는게 좋다
★ fulltext index test1_name_idx (name)
-------------------------------------------------------------------------------------
★ i++;
- 특정 컬럼의 값을 자동으로 증가하게 선언한다.
- 단 반드시 key(primary key 나 unique)여야 한다.
alter table test1 modify column no int not null auto_increment; /* 아직 no가 pk가 아니기 때문에 오류*/
-------------------------------------------------------------------------------------
★ 뷰(view)
- 조회 결과를 테이블처럼 사용하는 문법
- select 문장이 복잡할 때 뷰로 정의해 놓고 사용하면 편리하다.

- 직장인만 조회
select no, name, class from test1 where working = 'Y';

- 직장인만 조회한 결과를 가상 테이블로 만들기
create view worker as select no, name, class from test1 where working = 'Y';

→ 실행 결과를 테이블로 만든다?
→ select * from worker;
→ select no, name, class from test1 where working = 'Y';
→ create view에 정의된 조건(select문)을 재실행한다

뷰 삭제
drop view worker;
-------------------------------------------------------------------------------------
★ 제약 조건 조회

0) 데이터베이스 변경
use information_schema;

1) 테이블의 제약 조건 조회

select table_name, constraint_name, constraint_type
from table_constraints;


2) 테이블의 키 컬럼 정보 조회

select table_name, column_name, constraint_name
from key_column_usage;


3) 테이블과 컬럼의 키 제약 조건 조회

select
  t2.table_name,
  t2.column_name,
  t2.constraint_name,
  t1.constraint_type
from table_constraints t1
  inner join key_column_usage t2 on t2.constraint_name=t1.constraint_name;
-------------------------------------------------------------------------------------
값 변경하기
update 테이블 set 컬럼=값 ;
update 테이블 set 컬럼=값 where 조건;
-------------------------------------------------------------------------------------



0224.01.31(수)
-------------------------------------------------------------------------------------
sql 활용
## autocommit
mysql은 autocommit의 기본 값이 true이다.
따라서 명령창에서 SQL을 실행하면 바로 실제 테이블에 적용된다.
수동으로 처리하고 싶다면 autocommit을 false로 설정하라!

> set autocommit=false;

insert/update/delete을 수행한 후 승인을 해야만 실제 테이블에 적용된다.

> commmit;

마지막 commit 상태로 되돌리고 싶다면,

> rollback;
-------------------------------------------------------------------------------------
Transaction(트랜잭션) 
→ 한 단위로 묶은 작업
→ 하나의 업무가 여러 개의 작업으로 이루어진 경우
→ 한 단위로 다룰 수 있도록 여러 작업을 묶는 것
  → 주문업무(주문등록, 결제등록, 배송등록)
  → 주문업무(주문등록, 결제등록, 배송등록)
  → 주문업무(주문등록, 결제등록, 배송등록)
  → 하나의 작업이라도 실패하면 업무 미완성으로 보고 이전에 수행했던 작업도 모두 취소한다 = rollback
  → 모든 작업이 성공했으므로 업무가 완성되었다 = commit
  → 임시 DB에 저장될 수 있다

실제 테이블
  12, 'xxx'
  13, 'yyy'
  14, 'zzz'
set autocommit = false;
→ insert → 임시 DB에 insert가 저장된다
→ update → 임시 DB에 update가 저장된다
→ delete  → 임시 DB에 delete가 저장된다
→ select → 실제 테이블의 데이터 + 임시작업 결과를 보여준다
→ rollback → 임시 DB에 보관된 모든 작업결과를 취소한다, 마지막으로 commit 상태로 되돌려 준다
→ commit → 임시DB에 보관된 모든 작업결과를 실제 테이블에 적용된다
→ ★ 여러 개의 작업을 묶어 한 단위로 다룰 수 있다
→ ★ Thread(스레드)별로 임시 DB를 관리한다

set autocommit = false;
client1 < Thread 연결 > DBMS
→ select
  12, 'xxx'
  13, 'yyy'
  14, 'zzz'
  18, 'kkk'
  19, 'mmm' 출력
임시 DB

set autocommit = false;
client2 < Thread 연결 > DBMS
→ insert → 임시 DB에 insert가 저장된다 
→ insert → 임시 DB에 insert가 저장된다 
임시 DB
  18, 'kkk'
  19, 'mmm'
→ commit → 실제 테이블에 적용
실제 테이블
  12, 'xxx'
  13, 'yyy'
  14, 'zzz'
  18, 'kkk'
  19, 'mmm'
-------------------------------------------------------------------------------------
select → projection/selection
no name class working tel
1  aaa               Y
2  bbb              N
3  ccc                Y
4  ddd              N
5  eee               Y
projection = 컬럼 지정
select no, name → 결과 데이터로 추출할 컬럼 선택 
from test1 → 참조할 테이블
selection = 데이터 지정
where working='Y'; → 결과 데이터를 조건에 맞춰 선택	
-------------------------------------------------------------------------------------
가상의 컬럼 값을 조회하기
select no, concat(name,'(',class,')') from test1;
no  concat(name,'(',class,')')
1  aaa(java101)
2  aaa(java102)

### 조회하는 컬럼에 별명 붙이기
- 별명을 붙이지 않으면 원래의 컬럼명이 조회 결과의 컬럼이름으로 사용된다.
- 위의 예제처럼 복잡한 식으로 표현한 컬럼인 경우 컬럼명도 그 식이 된다.
- 이런 경우 별명을 붙이면 조회 결과를 보기 쉽다.


/* 컬럼에 별명 붙이기*/
select 컬럼명 [as] 별명 ...
select
    no as num,
    concat(name,'(',class,')') as title
from test1;

/* as를 생략해도 된다.*/
select
    no num,
    concat(name,'(',class,')') title
from test1;

★ select와 insert
insert into test1(no, name) select bno, cname from test2 where addr='seoul';
-------------------------------------------------------------------------------------
/* 주의!
 * where 절을 통해 결과 데이터를 먼저 선택(selection)한 다음
 * 결과 데이터에서 가져올 컬럼을 선택(projection)한다.
 * 따라서 실행 순서는:
 ★ from ==> join ==> on ==> where ==> group by ==> select ==> having ==> order by ==> limit
 */
==> DBMS 마다 실행순서가 조금씩 다르다 각 실행순서를 확인 하면서 코드를 짜야한다
고객
번호  이름  나이  성별
1  홍길동  20  남
2  유관순  18  여
3  임꺽정  30  남
4  안중근  40  남
5  조수미  50  여
6  신혜선  30  여

주문
제품번호  제품명  가격  고객번호  수량
100  aaa  20000  1  2
101  bbb  3000  1  3
102  ccc  31000  2  2
103  ddd  2700  3  5
104  eee  5000  5  10

select client.no, name, p_name, concat(price*quantity) from client join order1 on client.no=order1.c_no where order1.price>=10000 order by order1.price desc;
select 번호, 이름, 제품명, 총액
from 고객 join 주문 on 고객.번호=주문.고객번호 
where 주문.가격>=10000
order by 주문.가격 desc;

실행 순서

1) from → join 
→ Cartesion join(=cross join)을 한다
→ Cartesion join(=cross join)은 모든 경우의 수를 구한다 = 30가지의 경우를 구한다

2) on 고객.번호=주문.고객번호
→ 조건에 해당하는 튜플만 남긴다
→ inner join
번호  이름  나이  성별  제품번호  제품명  가격  고객번호 수량
1  홍길동  20  남  100  aaa  20000  1  2
1  홍길동  20  남  101  bbb  3000  1  3
2  유관순  18  여  102  ccc  31000  2  2
3  임꺽정  30  남  103  ddd  2700  3  5
5  조수미  50  여 104  eee  5000  5  10

3) where 주문.가격>=10000
번호  이름  나이  성별  제품번호  제품명  가격  고객번호 수량
1  홍길동  20  남  100  aaa  20000  1  2
2  유관순  18  여  102  ccc  31000  2  2

4) select 번호, 이름, 제품명, (수량*가격) as 총액
→ 컬럼을 지정한다
→ 총액이라는 가상 컬럼을 만든다
총액
40000
62000

5) order by 가격 desc;
→ 컬럼 가격에 대해서 내림차순으로 정렬시킨다

6) return
번호  이름  제품명  총액
2  유관순  ccc  62000
1  홍길동  aaa  40000
-------------------------------------------------------------------------------------
★ 기타 명령어
/* 재직자가 아닌 사람만 조회하라!*/
select no, name, class, working
from test1
where not working = 'Y';

select no, name, class, working
from test1
where working != 'Y';

select no, name, class, working
from test1
where working <> 'Y';
/* 전화 번호가 있는 학생만 조회하라!*/
/* => 다음과 같이 null에 != 연산자를 사용하면 조건이 맞지 않는다.*/
select *
from test1
where tel != null;

/* => null인지 여부를 가릴 때는 is 또는 is not 연산자를 사용하라!*/
select *
from test1
where tel is not null;

select *
from test1
where not tel is null;

/* 전화 번호가 없는 학생만 조회하라!*/
/* => null인지 여부를 가릴 때는 = 연산자가 아닌 is 연산자를 사용해야 한다.*/
select *
from test1
where tel = null; /* 실패 */

select *
from test1
where tel is null; /* OK */

### 사칙연산
- +, -, *, /, % 연산자를 사용할 수 있다.

select (4 + 5), (4 - 5), (4 * 5), (4 / 5), (4 % 5);

### 비교연산
- =, !=, >, >=, <, <=, <>

select (4=5), (4!=5), (4>5), (4>=5), (4<5), (4<=5), (4<>5);

### between 값1 and 값2
- 두 값 사이(두 값도 포함)에 있는지 검사한다.

select 5 between 3 and 5;

### like
- 문자열을 비교할 때 사용한다.

/* class 이름에 java를 포함한 모든 학생 조회하기
   이 경우 조회 속도가 느리다.*/
select *
from test1
where class like '%java%';

- 날짜 값 비교하기

/* 특정 날짜의 게시글 찾기 */
select *
from test1
where regdt = '2022-6-17';

/* 특정 기간의 게시글 조회 */
select *
from test1
where regdt between '2022-11-1' and '2022-12-31';

select *
from test1
where regdt >= '2022-11-1' and regdt <= '2022-12-31';

- 날짜를 다루는 연산자와 함수

/* 현재 날짜 및 시간 알아내기 */
select now();

/* 현재 날짜 알아내기 */
select curdate();

/* 현재 시간 알아내기 */
select curtime();

/* 주어진 날짜, 시간에서 날짜만 뽑거나 시간만 뽑기 */
select regdt, date(regdt), time(regdt) from test1;

/* 특정 날짜에 시,분,초,일,월,년을 추가하거나 빼기*/
date_add(날짜데이터, interval 값 단위);
date_sub(날짜데이터, interval 값 단위);

select date_add(now(), interval 11 day);
select date_sub(now(), interval 11 day);

/* 두 날짜 사이의 간격을 알아내기 */
datediff(날짜1, 날짜2);
select datediff(curdate(), '2023-2-10');

/* 날짜에서 특정 형식으로 값을 추출하기 */
date_format(날짜, 형식)
select regdt, date_format(regdt, '%m/%e/%Y') from test1; /* 09/7/2022 */
select regdt, date_format(regdt, '%M/%d/%y') from test1; /* September/07/17 */
select regdt, date_format(regdt, '%W %w %a') from test1; /* Thursday 4 Thu */
select regdt, date_format(regdt, '%M %b') from test1; /* September Sep */
select now(), date_format(now(), '%p %h %H %l'); /* PM 01 13 1 */
select now(), date_format(now(), '%i %s'); /* 05 45 */

/* 문자열을 날짜 값으로 바꾸기 */
select str_to_date('11/22/2022', '%m/%d/%Y');
select str_to_date('2022.2.12', '%Y.%m.%d');


/* 날짜 값을 저장할 때 기본 형식은 yyyy-MM-dd이다. */
insert into test1 (title, regdt) values('aaaa', '2022-11-22');

/* 다음 형식의 문자열을 날짜 값으로 지정할 수 없다.*/
insert into test1 (title, regdt) values('bbbb', '11/22/2022');

/* 특정 형식으로 입력된 날짜를 date 타입의 컬럼 값으로 변환하면 입력할 수 있다.*/
insert into test1 (title, regdt) values('bbbb', str_to_date('11/22/2022', '%m/%d/%Y'));
-------------------------------------------------------------------------------------
Foreign key(참조 키)

게시글과 첨부파일
→ 파일은 HDD에 저장하고
→ DB에는 파일 경로를 저장한다
→ 첨부파일은 스토리지에 저장한다( AWS S3, Azure Blob storage, NCP object Storage )

고민해볼 사항!
- 첨부 파일의 개수를 5 개로 정해 놓았다.
- 따라서 최대 5개의 첨부 파일만 테이블에 저장할 수 있다.
- 첨부파일이 없더라도 5개의 컬럼은 메모리를 차지한다.

실무에서 원하는 것!
- 첨부 파일의 개수에 제한을 받고 싶지 않다.
- 첨부 파일 개수만큼만 값을 저장하고 싶다.

이렇게 같은 데이터를 저장할 컬럼이 중복된 경우에는,
- 중복 컬럼을 별도의 테이블로 분리한다.
- 중복 컬럼의 값이 어느 테이블의 어느 데이터의 값인지 지정한다.


## 게시글과 첨부파일의 정보를 여러 개의 테이블에 분산 저장하기
board 
no  title  content  regdate  file1  file2  file3
1  aaa                            a.pdf
2  bbb                           b1.pdf  b2.pdf  b3.pdf
3  ccc                            c1.pdf
4  ddd                           d1.gif  d2.gif  d3.gif  d4.gif
→ 중복 컬럼이 있을 경우 분리한다 = 제1정규화
board 
no(pk)  title  content  regdate
attached_file
file_no(pk)  path  board_no(fk)

board-|---------o|<-attached_file
(부모 테이블)        (자식 테이블)

board
no  title  content  regdate
1  aaa  ~  ~                          
2  bbb  ~  ~                      
3  ccc  ~  ~                        
4  ddd  ~  ~       
                
attached_file
file_no  path  board_no
101  a.pdf  1
102  b1.pdf  2
103  b2.pdf  2
104  b3.pdf  2
105  c1.pdf  3
106  d1.gif  4
107  d2.gif  4
108  d3.gif  4
109  d4.gif  4

다른 테이블의 PK를 참조하는 컬럼으로 선언한다.

★ alter table 테이블명 add constraint 제약조건이름 foreign key (컬럼명) references 테이블명(컬럼명);

예)
/* 기존에 테이블에 무효한 데이터가 있을 수 있기 때문에 먼저 테이블의 데이터를 지운다.*/
delete from test2;

/* fk 컬럼을 설정하기 전에 무효한 데이터를 삭제해야 한다. */
alter table test2
    add constraint test2_bno_fk foreign key (bno) references test1(no);
-------------------------------------------------------------------------------------



2024.02.01(목)
-------------------------------------------------------------------------------------
Entity Relationship

1) 1 : 0 or 1
회원-|-----o|-학생
pk            fk=key(pk, unique)
1 홍길동      1 인류학	
→ 식별(identifying) 관계
→ FK = PK
→ FK : 관계를 가리킨다, PK : 식별자로 사용된다
→ primary key로 사용되는 foreign key


2) 1 : 다(0 or 1이상)
매니저-|----o|<-강의
pk               pk        fk    
2 대리          100 자바 2
3 주임          101 자바 3
4 주임          102 AI 2
                   103 파이썬 2
→ 비식별(non-identifying)관계
→ fk != key (pk, unique)
→ foreign key가 일반 컬럼
-------------------------------------------------------------------------------------
select 활용

/* distinct 와 all */
/* 모든 데이터를 가져온다.*/
select all loc from room;

/* all은 생략할 수 있다*/
select loc from room;

/★ 중복 값을 한 개만 추출할 때 distinct 를 붙인다.*/
select distinct loc from room;  

/* 컬럼이 2 개 이상일 때 그 컬럼들의 값이 중복될 경우만 한 개로 간주한다.*/
select distinct loc, name from room;

select concat(name, '(', loc, ')') title
from room;

/* count()를 호출할 때 컬럼 이름을 지정하면 
   해당 컬럼의 값이 null 이 아닌 데이터만 카운트한다. */
select count(mno) cnt
from lect;

/* union 과 union all */

/* select 결과 합치기
   union : 중복 값 자동 제거*/
select distinct bank from stnt
union
select distinct bank from tcher;

/* union all: 중복 값 제거 안함*/
select distinct bank from stnt
union all
select distinct bank from tcher;

/* 차집합
   mysql 은 차집합 문법을 지원하지 않는다.
   따라서 다음과 기존의 SQL 문법을 사용해서 처리해야 한다.
*/
select distinct bank
from stnt
where not bank in (select distinct bank from tcher);

/* 교집합
   mysql 은 교집합 문법을 지원하지 않는다.
   따라서 다음과 기존의 SQL 문법을 사용해서 처리해야 한다.
*/
select distinct bank
from stnt
where bank in (select distinct bank from tcher);
-------------------------------------------------------------------------------------
-- 실행 순서: from -> where -> select -> order by
-- 1) from 또는 join : 테이블의 전체 데이터 또는 조인 데이터 
-- 2) where : 조건에 따라 결과로 뽑을 데이터를 selection 한다.
-- 3) group by : 조건에 따라 뽑은 데이터를 특정 컬럼을 기준으로 데이터를 묶는다.
-- 4) having : 그룹으로 묶은 데이터를 조건에 따라 선별한다.
-- 5) select : 최종 결과로 뽑을 컬럼을 표시(projection)한다. 표현식으로 계산한 컬럼도 포함시킨다.
-- 6) order by : select 절에서 추가한 임의 컬럼이나 테이블 컬럼을 기준으로 정렬한다.
-- 7) limit : 결과 데이터에서 지정한 범위의 데이터를 선택한다.
-- 8) 결과 추출: 7번을 수행한 결과 데이터에서 5번에 표시된 컬럼만 추출한다.
-------------------------------------------------------------------------------------
/* 조인
=> 서로 관련된 테이블의 데이터를 연결하여 추출하는 방법
=> 기법
1) CROSS 조인(=Cartesian product)
2) NATURAL 조인
3) JOIN ~ USING(컬럼명)
4) [INNER] JOIN ~ ON
5) OUTER JOIN
*/
-- cross join 고전 문법 */
select board1.bno, title, content, fno, filepath, attach_file1.bno
from board1, attach_file1;

-- 컬럼명 앞에 테이블명을 붙이면 너무 길다.
-- 테이블에 별명을 부여하고 그 별명을 사용하여 컬럼을 지정하라.
select b.bno, title, content, fno, filepath, a.bno
from board1 as b cross join attach_file1 as a;

-- as는 생략 가능
select b.bno, title, content, fno, filepath, a.bno
from board1 b cross join attach_file1 a;

-- 고전 문법
select b.bno, title, content, fno, filepath, a.bno
from board1 b, attach_file1 a;
-------------------------------------------------------------------------------------
NATURAL 조인
--    같은 이름을 가진 컬럼 값을 기준으로 레코드를 연결한다.
select b.bno, title, content, fno, filepath, a.bno
from board1 b natural join attach_file1 a;
  
-- 고전 문법
select b.bno, title, content, fno, filepath, a.bno
from board1 b, attach_file1 a
where b.bno = a.bno;

-- natural join 의 문제점
-- 가. 두 테이블의 조인 기준이 되는 컬럼 이름이 다를 때 연결되지 못한다.
-- 나. 상관 없는 컬럼과 이름이 같을 때 잘못 연결된다.
-- 다. 같은 이름의 컬럼이 여러 개 있을 경우 잘못 연결된다.
--    모든 컬럼의 값이 일치할 경우에만 연결되기 때문이다.

-- 가. 두 테이블의 조인 기준이 되는 컬럼 이름이 다를 때:
-- natural join의 기준이 되는 같은 이름을 가진 컬럼이 양 테이블에 존재하지 않는다.
-- => cross join 처럼 실행된다.
select no, title, content, fno, filepath, bno
from board2 b natural join attach_file2 a;

-- 고전 문법 : 
-- 고전 문법에서는 where 절의 조건으로 두 테이블의 조인 기준이 되는 컬럼 값을 검사하기 때문에 
-- 실행 결과는 정상적으로 나온다.
select no, title, content, fno, filepath, bno
from board2 b, attach_file2 a
where b.no = a.bno;

-- 나. 같은 이름을 가진 컬럼이 있지만 서로 상관(PK와 FK 관계)이 없는 컬럼일 때:
-- board3의 no와 attach_file3의 no는 PK/FK 관계가 아니다.
-- 그럼에도 불구하고 이름이 같기 때문에 이 컬럼을 기준으로 데이터를 연결한다.
select b.no, title, content, a.no, filepath, bno
from board3 b natural join attach_file3 a;

-- 다. 같은 이름을 가진 컬럼이 여러 개 있을 때:
-- board4와 attach_file4에 같은 이름을 가진 컬럼이 여러 개 있다.
-- 해당 컬럼들의 값이 같을 때만 두 테이블의 데이터를 연결한다.
-- 따라서 실행 결과 데이터는 없을 것이다.
select b.bno, b.title, content, a.fno, a.title, a.bno
from board4 b natural join attach_file4 a;
-------------------------------------------------------------------------------------
JOIN ~ USING
--    같은 이름을 가진 컬럼이 여러 개 있을 경우 USING을 사용하여 컬럼을 명시할 수 있다.
select b.bno, b.title, content, a.fno, a.title, a.bno
from board4 b join attach_file4 a using (bno);

-- 두 테이블의 데이터를 연결할 때 기준이 되는 컬럼이 이름이 같지 않다.
-- 이런 경우 using을 사용할 수 없다. 실행 오류!
select no, title, content, fno, filepath, bno
from board5 b join attach_file5 a using (bno);
-------------------------------------------------------------------------------------
JOIN ~ ON(=INNER JOIN)
-- 조인 조건을 on에 명시할 수 있다.
select no, title, content, fno, filepath, bno
from board5 b join attach_file5 a on b.no=a.bno;

-- 조건에 일치하는 경우에만 두 테이블의 데이터를 연결한다.
-- 이런 조인을 'inner join' 이라 부른다.
-- SQL 문에서도 inner join 이라 기술할 수 있다.
-- 물론 inner를 생략할 수도 있다.
select no, title, content, fno, filepath, bno
from board5 b inner join attach_file5 a on b.no=a.bno;
-------------------------------------------------------------------------------------
OUTER JOIN
--    조인 조건에 일치하는 데이터가 없더라도 두 테이블 중에서 한 테이블의 데이터를 
--    결과로 포함시키는 명령이다.
--    문법:
--         select  컬럼명, 컬럼명, ...
--         from 테이블1 t1 [left|right] outer join 테이블2 t2 on t1.컬럼=t2컬럼
--    left outer join => 왼쪽 테이블의 데이터는 반드시 포함시키라는 뜻이다.
--    right outer join => 오른쪽 테이블의 데이터를 반드시 포함시키는 뜻이다.
--  
select no, title, content, fno, filepath, bno
from board5 b [{(left, right)}] outer join attach_file5 a on b.no=a.bno
order by no desc;
-------------------------------------------------------------------------------------
/* 서브 쿼리
=> 쿼리문 안에 쿼리문을 실행하는 기법
=> 성능 문제를 생각하면서 사용해야 한다.
*/
-------------------------------------------------------------------------------------



2024.02.05(월)
-------------------------------------------------------------------------------------
모델링
→ 시스템을 분석학 구조화시켜 글과 그림으로 표현(추상화)한 것
렌더링 
→ 명령어를 해석하여 화면에 출력하는 것
DB 모델링
→ 데이터를 분석하고 구조화시켜 데이터 속성과 관계를 글과 그림으료 표현(추상화)한 것
→ 데이터가 중복되지 않도록 데이터를 테이블로 구조화하는 것
→ 중복 데이터를 제거 → 데이터의 안정성, 신뢰성을 높인다 → 인관성, 무결성을 유지한다
-------------------------------------------------------------------------------------
## 주요 용어

- table(relation; entity; file)
- intension(schema; header) => 데이터 구조 설계도
- extension(instance; data) => 데이터
- row(tuple; record) => 데이터(여러 컬럼으로 이루어진) 한 개. 예) 학생
- column(attribute; field) => 데이터의 한 항목. 예) 이름, 학번, 전화번호
- mandatody => 필수 저장
-------------------------------------------------------------------------------------
제1정규화
→ 데이터 중복을 찾아내어 별도의 테이블로 데이터를 분리시키는 것
→ 중복 데이터 또는 중복 컬럼을 별도의 테이블로 분리하여 부모-자식 관계를 맺는다

제2정규화
→ pk가 여러 컬럼으로 이루어진 경우에 수행
→ 모든 일반 컬럼은 반드시 pk컬럼에 종속되어야 한다

제3정규화
→ 어떤 컬럼이 pk가 아닌 다른 일반 컬럼에 종속되는 경우가 있다면 
→ 별도 테이블로 분리하여 부모-자식 관계를 맺는다
→ 우편번호와 기본주소
------------------------------------------------------------------------------------
DB모델링 - 포함관계와 배타적 관계

① 포함관계
회원 → 학생회원, 매니저회원, 강사회원 
	  ┌o|-학생
회원-|----and-o|-강사
	  └o|-매니저
→ 회원으로서 학생, 강사, 매니저 역할 모두 수행할 수 있을 경우

② 배타적 관계
	  ┌o|-학생
회원-|------or-o|-강사
	  └o|-매니저
→ 회원은 학생 또는 강사 또는 매니저 중에서 한 가지 역할만 수행할 수 있을 경우
-------------------------------------------------------------------------------------
도메인 정의 및 적용
- 비슷한 종류의 컬럼들을 묶어 새 타입으로 정의한다.
- 이점: 타입을 변경할 때 한 번에 여러 컬럼을 변경할 수 있어서 유지보수에 좋다.
-------------------------------------------------------------------------------------



2024.02.06(화)
-------------------------------------------------------------------------------------
JDBC 프로그래밍

JDBC API
→ 자바에서 제공하는 인터페이스 및 클래스
→ DB 프로그래밍에서 사용하는 객체 규칙
→ java.sql.x, java.sql.x

JDBC Driver
→ vendor에서 제공하는 인터페이스 구현체 및 보조 클래스

API → 구현체
<<interface>> Driver → 구현체 → com.mysql.cj.jdbc.Driver
<<interface>> Connection → 구현체 → com.mysql.cj.jdbc.ConnectionImpl
<<interface>> Statement → 구현체 → com.mysql.cj.jdbc.StatementImpl
<<interface>> PreparedStatement → 구현체 
<<interface>> ResultSet → 구현체

① Driver
② DriverManager
③ Connection
④ Statement
⑤ ResultSet 
⑥ PreparedStatement
⑦ Transaction : commit/rollback
⑧ Connection pool : DataSource

JDBC 구현체 간의 관계
connect(URL, 기타정보) → Driver 구현체 생성 → Connection 구현체 생성 → Statement 구현체 생성 → ResultSet 구현체 생성
→ connect를 직접 사용하지 말 것!
DriverManager.getConnection() → connection.createStatement() → statement.executeQuery() → rs.next()/rs.getxxx()
-------------------------------------------------------------------------------------
Driver 와 DriverManager
1) Driver 구현체 등록
Driver의 인스턴스 생성 → 등록 → <<concrete>> DriverManager → Driver 구현체 목록을 가지고 있다(JDBC URL, Driver 인스턴스)
DriverManager.registerDriver(객체);
DriverManager.getDriver("JDBC URL");
→ 드라이버를 가리키는 주소

★ 드라이버 자동 로딩!!
// 그럼에도 MariaDB Driver를 찾을 수 있다!
// 왜?
// - JVM은 프로그램을 실행할 때 
//   'service-provider loading' 절차에 따라
//   .jar 파일에 있는 특정 클래스를 찾아 로딩하거나 객체를 자동으로 생성한다.
// - JDBC의 경우도 이 규칙을 따른다.
//   DriverManager의 getDriver()를 호출할 때 
//   'service-provider loading' 규칙에 따라 .jar 파일에서 
//   Driver 구현체를 찾아 자동으로 로딩한다.
=> java.sql.Driver 클래스의 서비스 제공자를 찾아 로딩한다.
=> jar 파일 안에 META-INF/services/java.sql.Driver 파일을 찾는다.
Connection con = DriverManager.getConnection(URL, id, pwd);
→ 드라이버를 자동 로딩 하고 driver.connect()를 호출해서 connection 객체를 리턴
-------------------------------------------------------------------------------------
Connection
DriverManager.getConnection(JDBC URL, Id, Pwd) → Driver 객체.connect() → new xxxConnection()
→ JDBC URL에 지정된 Driver를 찾아서 connect 호출
→ Driver 구현체 → Connection 객체 생성 → DBMS와 Connection 구현체와 연결
→ Connection 객체를 리턴한다
자원해제
→ 파일과 마찬가지로 DBMS에 연결한 후 더이상 사용하지 않으면 연결을 해제해야한다
→ close()를 호출하지 않으면 서버쪽에서는 일정 기간(timeout) 동안 커넥션을 유지한다
→ 꼭 해줘야한다 con.close();
→ autocloseable 구현체여서 try-with-resources 문법 사용 가능
-------------------------------------------------------------------------------------
Statement
connection 객체.createStatement() → Statement 구현체 리턴

SQL 실행
statement 객체.executeUpdate(insert, update, dlete 등) → DBMS에게 작업 요청 
→ 결과를 응답 → 적용된 레코드 수 리턴
statement 객체.executeQuery(select) → DBMS에게 작업 요청
→ 결과를 응답 → ResultSet 구현체 생성 → ResultSet 구현체 리턴
ResultSet 구현체 → 서버에서 결과를 가져오는 일을 할 객체

// 용어정리
// "DML(Data Manipulation Language)"
// => insert, update, delete 처럼 데이터를 조작하는 sql 명령을 말한다.
// "DQL(Data Query Language)"
// => select처럼 data를 조회하는 sql 명령을 말한다.
-------------------------------------------------------------------------------------
ResultSet
rs객체 → 통신 DBMS → 응답 → rs객체에게 컬럼 값, 응답여부 리턴
ResultSet 객체.next() → DBMS에게 레코드를 꺼내달라고 요청 → DBMS는 1개의 레코드를 꺼내서 응답한다
→ 서버에서 받은 레코드의 컬럼 값을 보관 → 레코드를 가져온 여부를 리턴

rs객체.getxxx(컬럼번호 또는 컬럼 이름) 
→ DBMS에 설정된 컬럼의 값을 xxx타입으로 리턴한다
// => int, number: getInt()
// => char, varchar, text: getString()
// => date, time, datetime: getDate(), getTime()
// => float: getFloat()
-------------------------------------------------------------------------------------



2024.02.07(수)
-------------------------------------------------------------------------------------
DB 모델링
→ 데이터 중복을 최소화하고 구조를 최적화한다
→ 일관성, 무결성, 효율성을 향상시킨다
→ 데이터 저장 공간을 절얄할 수 있다
-------------------------------------------------------------------------------------
PreparedStatement
→ 값을 가지고 SQL을 만드는 것이 아니다 = Dynamic SQL
→ SQL문과 값을 분리하여 실행한다

PreparedStatement pstmt = con.prepareStatement("insert into x_board(title, contents) values(?,?)");
?,? → in-parameter
→ 주어진 SQL문을 값과 분리하여 DBMS가 이해할 수 있는 형식으로 미리 변환(compile)한다
→ 값은 다로 DBMS에 전달한다

값을 설정하는 방법
pstmt.setxxx(1,'aaa');
→ in-parameter 타입에 맞춰서 적절한 메소드 호출
→ in-parameter 순서, 값
-------------------------------------------------------------------------------------
// => 게시글을 입력할 때 자동 생성된 PK 값을 받겠다고 설정한다.
PreparedStatement boardStmt = con.prepareStatement(
	"insert into x_board(title,contents) values(?,?)", Statement.RETURN_GENERATED_KEYS);
// 위에서 입력한 게시글의 PK 값을 알아내기
ResultSet keyRS = boardStmt.getGeneratedKeys();
keyRS.next(); // PK가 들어있는 레코드를 한 개 가져온다.
// int boardId = keyRS.getInt("board_id"); // PK 값이 들어있는 레코드에서 컬럼 값을 꺼낸다. MariaDB에서 오류 발생!
int boardId = keyRS.getInt(1);
-------------------------------------------------------------------------------------
트랜잭션
→ 여러 개의 변경 작업을 수행하기 위해서 autocommit을 false로 설정해야한다
con.setAutoCommit(false);
con.commit;
con.rollback;
-------------------------------------------------------------------------------------
과제 48. SQL 삽입 공격 차단하기
- SQL 삽입 공격의 원리 이해
- PreparedStatement 적용하기
-------------------------------------------------------------------------------------



2024.02.08(목)
-------------------------------------------------------------------------------------
StringWriter
→ 출력하는 문자열을 내부 버퍼에 유지
print("aaa");
print("bbb");
print("ccc");
→ 버퍼에 보관(aaa, bbb, ccc)
new PrintWriter(new StringWriter());
-------------------------------------------------------------------------------------



2024.02.13(화)
-------------------------------------------------------------------------------------
과제 49. Applications architecture
→ 모든 비즈니스 로직은 로컬이 아닌 서버에서 동작된다
→ 비즈니스 로직이 바뀔 때마다 로컬에 있는 APP을 재설치 해야한다
→ 유지보수가 번거로우니 서버에서 동작하게 하면 서버만 바꾸면 돼서 유지보수가 쉽다
→ 클라이언트는 ui만 담당한다
-------------------------------------------------------------------------------------
과제 50. DB 커넥션 공유의 문제점 단순 해결책
c1 <> t1 
c2 <> t2            →       server(con)         →    DBMS
c3 <> t3
c1 → insert, insert, update
c3 → update, delete, commit
임시 DB → insert, insert, update, delete
→ c1에 있는 update 오류 발생! → rollback → c3가 commit을 해서 rollback 할 수 없다
→ c1이 요청한 작업은 c3가 commit을 실행할 때 함께 commit 되었기 때문에 c1에서 rollback을 요청 하더라도 취소할 수 없다

해결책
→ 클라이언트마다 connection을 만들어서 각자 임시 DB 생성
→ c1이 insert를 여러 번 해도 다른 클라이언트 임시 DB에 영향을 끼치지 않는다
→ 각자 commit을 해야 DBMS에 반영된다
-------------------------------------------------------------------------------------
스레드 별로 DB 커넥션을 따로 유지하기

방법1 - SQL 실행할 때마다 생성하기
→ SQL 실행할 때마다 새 DB 커넥션 생성
→ 다른 스레드의 SQL 작업을 간섭하지 않는다

단점
Connection 생성
→ 사용자 인증(Authentication) - id, pw, 유효성 검증
→ 권한 조회(Athorization) - 사용자의 권한 범위 조회
  → auth
→ 매번 반복한다면 시간낭비, 연결에 시간 지체
Transaction
→ connection이 다르다
  → 트랜잭션으로 묶을 수 없다
  → 트랜잭션을 실행하는 동안에는 같은 connection을 사용해야 한다

방법2 - 스레드 당 1개의 connection 유지
→ 같은 트랜잭션으로 묶을 수 있다
→ 스레드마다 다른 connection 사용
  → 다른 스레드의 commit/rollback에 영향을 받지 않는다
→ 스레드가 SQL을 실행하는 동안 같은 connection 사용한다
  → 여러 개의 데이터 변경작업을 하나의 트랜잭션으로 묶을 수 있다
-------------------------------------------------------------------------------------
과제 52. 트랜잭션 제어를 담당할 객체
→ 같은 connection으로 SQL문 실행하기 때문에
→ DAO에서 commit/rollback을 실행하면 트랜잭션을 제대로 제어할 수 없다
→ DAO를 호출하는 쪽에서 트랜잭션 제어 = Business Logic 예) xxxHandler
→ DAO의 메소드는 업무에 따라 여러 개를 하나의 트랜잭션으로 묶어 실행해야 할 때가 있다
  → 따라서 트랜잭션은 DAO를 호출하는 Business Logic 객체에서 제어해야 한다
단점
→ DB 커넥션이 낭비된다
-------------------------------------------------------------------------------------
과제 53. DB 커넥션 재사용 : DB 커넥션 풀
→ Thread 수만큰 DB connection이 생성된다 => 커넥션 낭비
→ 클라이언트가 DB 작업을 요청하지 않으면 connection은 사용되지 않는다
  → 자원을 비효율적으로 관리
  → 당장 쓰지도 않는 DB connection을 계속 유지!
-------------------------------------------------------------------------------------



2024.02.14(수)
-------------------------------------------------------------------------------------
DB 커넥션과 프록시 패턴
→ 프록시 객체는 오리지날 인터페이스를 구현한다
→ 개발자가 원하는 부분만 고친다(close() 부분만)
→ 쌍방 참조가 발생하면 인터페이스를 만들어서 참조하게 한다
-------------------------------------------------------------------------------------
과제 54. 트랜잭션 제어 기능을 분리하기
→ 트랜잭션 제어 기능을 별도의 클래스로 캡슐화하기
→ 커넥션 객체 사용 후 커넥션풀에 자동 반납하는 방법
  → Proxy 패턴을 이용하여 Connection 객체의 close() 기능 변경
-------------------------------------------------------------------------------------
과제 55. 외부키(Foreign Key) 사용하기
- 외부키를 설정하고 사용하는 법
- 조인을 이용하여 외부 테이블의 값을 가져오는 방법
-------------------------------------------------------------------------------------



2024.02.15(목)
-------------------------------------------------------------------------------------
과제 56. 로그인 적용하기
- 로그인을 구현하는 방법
- 로그인 정보를 가지고 관련 데이터를 다루는 방법
  - 게시글 입력할 때 로그인 사용자 번호를 입력하기
-------------------------------------------------------------------------------------
★ 웹 애플리케이션 서버 아키텍처
웹 브라우저 <HTTP> Tomcat Server(web server <> servlet container) <call/return> App <> DBMS
웹 브라우저 → 네트워킹, HTTP

Tomcat Server(Spring Boot의 종류)
<HTTP 요청/응답> web server <요청 위임> servlet container <call/return> java app(동적 자원)
		     ↓↑
	           HTML, CSS, JS(정적 자원)
정적 자원 서비스 → 요청에 따라 응답결과가 항시 같다 → src/main/webapp
동적 자원 → 서비스 할 때마다 결과가 달라질수 있다 → build/classes/java/main
톰켓 서버 → 네트워킹, HTTP, 멀티스레딩
-------------------------------------------------------------------------------------
Servlet Container
Servlet Container <생성, 실행, 소멸> JAVA class(javax.servlet.Servlet 구현체)

Servlet
Servlet → Server App. + let(작은 것) 
→ 작은 서버 App (예 : 인사관리시스템=서버App) 
→ 서버 App의 작은 기능 => servlet

<<interface>>Servlet <----- <<concrete>>HelloWorld(인터페이스 메소드구현 + 배치정보 설정 @WebServlet(경로))
배치정보 → 클라이언트가 서블릿 실행을 요청할 때 사용할 경로

init() → 객체 생성 후 호출됨
service() → 요청이 들어올 때마다 호출됨
destroy() → app 종료할 때 호출됨
→ 서블릿 생명주기 메소드
getServletInfo()
getServletConfig()

caller = 서블릿 컨테이너
callee = app 클래스
-------------------------------------------------------------------------------------
Web Browser
plain text → Web Browser → 단순 출력
HTML → Web Browser → HTML 문법에 맞춰 렌더링
PDF → Web Browser → PDF 뷰어를 실행
JPEG, GIF → Web Browser → 이미지 출력
zip → Web Browser → 다운로드
-------------------------------------------------------------------------------------
자바에서 톰캣 서버 동작

// 톰캣 서버를 구동시키는 객체 준비
Tomcat tomcat = new Tomcat();

// 서버의 포트 번호 설정
tomcat.setPort(8888);

// 톰캣 서버를 실행하는 동안 사용할 임시 폴더 지정
tomcat.setBaseDir("./temp");

// 톰캣 서버의 연결 정보를 설정
Connector connector = tomcat.getConnector();
connector.setURIEncoding("UTF-8");

// 톰캣 서버에 배포할 웹 애플리케이션의 환경 정보 준비
StandardContext ctx = (StandardContext) tomcat.addWebapp(
  "/", // 컨텍스트 경로(웹 애플리케이션 경로)
  new File("./src/main/webapp").getAbsolutePath() // 웹 애플리케이션 파일이 있는 실제 경로
);
ctx.setReloadable(true);

// 웹 애플리케이션 기타 정보 설정
WebResourceRoot resources = new StandardRoot(ctx);

// 웹 애플리케이션의 서블릿 클래스 등록
resources.addPreResources(new DirResourceSet(
  resources, // 루트 웹 애플리케이션 정보
  "/WEB-INF/classes", // 서블릿 클래스 파일의 위치 정보
  new File("build/classes/java/main").getAbsolutePath(), // 서블릿 클래스 파일이 있는 실제 경로
  "/" // 웹 애플리케이션 내부 경로
));

// 웹 애플리케이션 설정 정보를 웹 애플리케이션 환경 정보에 등록
ctx.setResources(resources);

// 톰캣 서버 구동
tomcat.start();

// 톰캣 서버를 구동한 후 종료될 때까지 JVM을 끝내지 말고 기다린다.
tomcat.getServer().await();
-------------------------------------------------------------------------------------



2024.02.16(금)
-------------------------------------------------------------------------------------
Servlet Container가 관리하는 객체(Component)

ServletContext / HttpSession / ServletRequest → [Servlet Container] → Servlet / filter / listener

ServletContext 
- 웹 애플리케이션 당 1개
- 서블릿, 필터, 리스너가 공유하는 저장소
- DB 커넥션 객체, DAO 객체, 트랜잭션 관리 객체
HttpSession
- 클라이언트 당 1개
- 서블릿, 필터, 리스너가 공유하는 저장소
- 로그인 사용자 정보, 페이지 작업 정보 ...
ServletRequest
- 요청 당 1개
- 서블릿, 필터, 리스너가 공유하는 저장소
- 요청을 처리하는 동안 사용할 정보

Servlet - 클라이언트 요청을 처리
filter - 서블릿 실행 전후에 보조 작업을 수행
listener - 특정 상태(이벤트)에서 작업을 수행
  (이벤트)
  → 웹 앱의 시작/종료
  → 요청을 받거나 응답을 완료했을 때
  → 세션이 시작/종료
  → 등....
→ 서블릿, 필터, 리스너가 공유하는 객체를 저장할 때 사용할 저장소
-------------------------------------------------------------------------------------
Web Browser 와 Web Server, HttpSession
사용자(chrome 여러 창, safari 여러 창) → (1클라이언트, 1HttpSession), (1클라이언트, 1HttpSession) → web server
사용자(chrome 여러 창) → (1클라이언트, 1HttpSession) → web server
→ 같은 브라우저 여러 개를 띄운 것은 같은 클라이언트
→ 같은 브라우저에서 각각 다른 클라이언트로 접속 하고 싶으면 시크릿 창
→ 다른 브라우저로 띄운 것은 다른 클라이언트
→ 세션 저장소
-------------------------------------------------------------------------------------
Servlet Container 와 Web Application, ServletContext
Servlet Container → 인사 관리 시스템, 결재 시스템 → 여러 Web Application
Web Application → (입사, 퇴사, 경력증명서), (상신, 승인) → 여러 Servlet
서블릿 컨테이너 -|------|<- 웹 애플리케이션 -|------|<- 서블릿
→ 웹 애플리케이션 당 1개의 ServletContext
→ 웹 애플리케이션 저장소
-------------------------------------------------------------------------------------
Servlet과 요청, ServletRequest
서블릿 컨테이너 요청 <ServletRequest 생성/소멸> Servlet 응답
1요청 → 1ServletRequest
→ 요청 저장소
-------------------------------------------------------------------------------------
서블릿 컨테이너, 서블릿, 프로토콜
web browser <Http> Servlet Container → service(ServletRequest, ServletResponse) → Servlet
→ Http 프로토콜 정보를 포함한 HttpServletRequest, HttpServletResponse 객체를 넘겨준다

web browser <xxx프로토콜> Servlet Container → service(ServletRequest, ServletResponse) → Servlet
→ xxx 프로토콜 정보를 포함한 xxxServletRequest, xxxServletResponse 객체를 넘겨준다
service(ServletRequest, ServletResponse) 
→ 그래서 파라미터 타입은 다양한 프로토콜에 대응할 수 있도록 선언되어 있다
-------------------------------------------------------------------------------------
URL(Uniform Resource Locator)

https://localhost:8888/auth/login?email=xxx&password=1111
https → schema
localhost → host
8888 → port
/auth/login → resource path → static / dynamic
email=xxx → query string → parameter name=parameter value 
-------------------------------------------------------------------------------------
정적 자원과 동적 자원

http://localhost:8888/aurh/form.html
→ 정적자원 = 실행 결과가 고정됨
→ .html, .css, .js, .pdf, .gif, .jpg

http://localhost:8888/auth/login
→ 동적자원 = 실행 결과가 가변적
→ servlet, jsp 등 프로그램 실행

서버(web app server)	클라이언트(web browser)
BoardListServlet		요청/실행/결과
HTML, CSS, js, jpeg		요청/파일 다운로드 후 실행
-------------------------------------------------------------------------------------
URL 인코딩(퍼센트% 인코딩)
→ url을 작성할 때 특별한 의미를 지니는 단어의 경우(예: / : ? # & = @ 등) 
→ 일반 문자로 사용해서는 안되기 때문에 특별한 형식으로 변환한다

인코딩 대상 문자
! → %21		= → %3D		공백 → +
* → %2A		+ → %2B		가(EAB080) → %EA%B0%80
' → %2C		$ → %24
( → %28		, → %2C
) → %29		/ → %2F		
; → %3B  	? → %3F
: → %3A		# → %23
@ → %40	[ → %5B
& → %26		] → %5D

인코딩 제외 문자
→ 영어 대소문자
→ 숫자(0~9)
→ - _ . ~

url 인코딩/디코딩
"가 @" url 인코딩 → web browser → %EA%B0%80+%40 → web server → url 디코딩 "가 @"
→ 웹 브라우저가 웹서버에게 데이터를 보내기 전에 url 인코딩을 수행
→ 웹 서버는 웹 브라우저가 보낸 데이터를 url 디코딩해서 리턴한다
→ 개발자는 url 인코딩/디코딩을 직접 수행할 필요가 없다
-------------------------------------------------------------------------------------



2024.02.19(월)
-------------------------------------------------------------------------------------
과제 58. 리스너 및 웹 애플리케이션 저장소 활용하기
- ServletContextListener 활용법
  - 웹애플리케이션을 시작하거나 종료할 때 작업을 수행시키는 방법 
  - 예) 모든 서블릿이 공유하는 자원을 준비하기에 적절한 위치다.
- ServletContext 활용법
  - 웹애플리케이션당 1개가 생성되는 객체 저장소
  - 웹애플리케이션에서 공유할 객체를 보관하기에 적절하다.
  - 예) DB 커넥션, DAO, 트랜잭션 관리자 등
-------------------------------------------------------------------------------------
웹 애플리케이션 과 컨텍스트
웹 애플리케이션 = 컨텍스트 = 서블릿 컨텍스트
-------------------------------------------------------------------------------------
ServletContextListener
→ 웹 애플리케이션이 시작되거나 종료될 때 호출하는 메소드의 규칙
Servlet Container → call → <<interface>> ServletContextListener <---- 리스너(contextDestroyed(){}, contextInitialized(){{}) 구현체
웹 애플리케이션의 생명주기가 변화 했을 때 호출한다
→ 웹 애플리케이션이 시작된 직후 → contextInitialized(){{}
  → 웹 애플리케이션이 실행되는 동안 사용할 자원을 준비
  → DB 커넥션, DAO, 서비스 객체, 트랜잭션....
→ 웹 애플리케이션이 종료 직전 → contextDestroyed(){}
  → 웹 애플리케이션을 종료하기 전에 사용한 자원을 해제
-------------------------------------------------------------------------------------



2024.02.20(화)
-------------------------------------------------------------------------------------
★ Web
CERN → 유럽 입자 물리 연구소 → 팀 버너스 리 → 논문의 원활한 공유(텍스트+그림 등 기타 미디어 매체)
논문에 언급된 다른 논문을 보기 위해서는 그 논문이 업로드 되어 있는 서버에 접속해서(서버 주소와 파일 경로를 알아야 함) 다운로드 받아야 한다
→ FTP(File Transfer Protocol) C/S 사용
→ 논문의 공유가 어렵다
→ 논문이 텍스트 위주이다
→ 개선할려고 Hyper-Text 고안
  → 문서 안에 다른 문서의 연결정보를 삽입
  → 그림 등 다른 매체를 삽입
→ Markup Language를 정의 
  → Hyper-Text Markup Language(HTML)
  → Markup → 데이터를 제어하는 명령 = meta data = tag

HTTP
클라이언트 <FTP(텍스트 논문)> 서버
개선→ 클라이언트 <HTTP(HTML을 전문적으로 주고 받는 프로토콜)> 서버
HTTP Client <> HTTP Server
Web browser <> Web Server
→ 기존의 프로토콜(FTP)로는 다른 문서와 연결된 HTML을 주고 받기에는 불편했다
→ 문서간의 연결이 거미망과 유사하여 "Web"이라 부른다!

발전사
→ ① 논문 공유 
→ ② 홍보(회사홍보, 제품홍보, 온라인 카탈로그) 
→ ③방명록, 게시판, 방문자수(프로그램을 결합=웹프로그램 시초)
  web browser <방명록 작성> web server <실행/리턴 (=CGI)> 방명록 등록 App
  → 방명록 등록 App(CGI 프로그램=CGI 규칙에 따라 웹서버와 데이터를 주고 받는 프로그램=웹애플리케이션 시초 c/c++)
  → CGI(Common Gateway Interface) → 웹 서버와 App 사이에 데이터를 주고 받는 규칙
→ ④ 주문 서비스(스크립트를 결합)
  → 컴파일 방식에서 인터프리터 방식으로 변환, 텍스트 처리가 쉬움
  web browser <> web server <> 스크립트 엔진 <스크립트 실행/결과리턴> → 스크립트
→ ⑤ 웹 애플리케이션 
  → 프로그램 변경 및 배포 용이
  → 보안이 쉽다
  → C/S 아키텍처에서 web App 아키텍처로 변경
    C/S 아키텍처
    → 클라이언트가 DBMS에 직접 접속하면 ID/PW 노출시 치명적이다
    → 기능 변경 때마다 재배포
    Web App
    → DBMS 접속은 서버에서 이루어지므로 ID/PW 노출될 일이 없다
    → 기능 변경시 서버쪽에만 배포하면 되므로 배포가 쉽다
-------------------------------------------------------------------------------------
Web Application

★ Monolithic 아키텍처 
→ 한 개의 서비스나 웹 애플리케이션에 모든 기능을 담는 방식
과제관리 시스템(회원관리, 과제관리, 게시글관리, 강사관리, 사용자인증) <> DBMS(회원, 강사, 과제, 게시글)
장점
→ 기능 간의 연동이 쉽다
→ 직접 메소드 호출 가능
단점 
→ 기능 변경시 전체 서비스를 재시작 
→ 일부 기능만 동작시키거나 멈출 수 없다
→ 특정 기능에 더 많은 자원을 할당할 수 없다
→ 강결합 → 상호 기능이 매우 의존적이다

★ Microservice 아키텍처 
→ 기능별로 서비스를 분리하는 방식
회원관리 - DBMS
과제관리 - DBMS
강사관리 - DBMS
게시글관리 - DBMS
사용자인증 - DBMS
장점
→ 기능별 제어가 쉽다(일부 기능만 끄거나 실행할 수 있다)
→ 기능 변경시 배포가 쉽다
→ 특정 기능에 자원을 더 할당할 수 있다
단점
→ 기능간의 연동시 오버헤드 발생(반복적인 부가작업이 늘어남) - 자원 과다 사용
→ 세션유지 및 관리가 번거롭다
→ DB 무결성 관리가 어렵다
-------------------------------------------------------------------------------------
Java Web Application

Java EE(Enterprise Edition=기업용)
→ 기업에서 사용할 App을 만드는데 필요한 기술과 도구를 제공한다
개인용과 기업용 차이점
  → 동시 접속 제어(통신, 멀티스레딩)
  → 사용자 인증/권한 제어
  → 자원 관리
  → App 분산 처리
→ 다중 동시 사용자용 App 개발에 필요한 기술 모음 및 도구 모음 => Java EE

Java EE의 주요 기술
기술명/Java EE버전 기술버전 JavaEE 8 | JavaEE 7 | JavaEE 6 | JavaEE 5
웹 기술 
Servlet 			4.0	3.1	 3.0	 2.5
JSP 			2.3	2.3	 2.2	 2.1
JSF 			2.3	2.2	 2.0	 1.2
EL 			3.0	3.0	 2.2	  x
JSTL			1.2	1.2	 1.2	 1.0

분산 컴포넌트 
EJB			3.2 	3.2	 3.1	 3.0
JPA 			2.2	2.1	 2.0	 1.0
JTA			1.2	1.2	 1.1	 1.0

분산 서비스 
WebService		1.3 	1.3	 1.3	 1.0
JAX-RPC			1.1	1.1	 1.1	 1.1

→ JSF 태그 => HTML, javascript, css 자동 생성 
  → 개발자가 정적코드를 직접 작성하는 부담을 덜어줌 
  → 망함!
  → JS 기술 발전으로 인해 JS 라이브러리가 많이 등장
-------------------------------------------------------------------------------------
분산 컴포넌트
Server1[월급 정산Handler] <call/직원정보returne> Server2[EmployDao]
 	└<call/월급정보return> Server3[PayDao]
→ 원격 객체의 메소드 호출
→ component = 시스템을 구성하는 부품
→ 여러 컴퓨터에 배치되어 있다 = 분산 컴포넌트
-------------------------------------------------------------------------------------
Servlet 과 EJB
web browser <HTTP 요청/(HTML,XML,JSON 등)응답> java ee 서버 <call/return> 서블릿 실행
App <call/return> Stub <메소드 호출 요청/메소드의 리턴값 응답> java ee 서버(Skeleton) <call/return> EJB 실행(Remote Object)
     				RMI-IIOP					메소드의 리턴타입 리턴
Stub → 원격객체의 클라이언트측 대행자
Skeleton → 원격객체의 서버측 대행자
대행자 → ORB(Object Request Broker)	
Servlet → 웹 컴포넌트를 만드는 기술
EJB → 분산 컴포넌트를 만드는 기술

분산 컴포넌트
예) myapp ver.40 BoardListHandler <findAll()/return> BoardDaoImpl <요청/응답 통신> Server <findAll()/return> BoardDaoImpl <I/O> JSON파일
						 stub		          skeleton		     remote object
★ RESTful
App <HTTP 요청/(XML,JSON 등)응답> java ee 서버 <call/return> 서블릿 실행
→ 웹 컴포넌트를 원격 객체로 만드는 기술
→ 기존의 웹기술을 사용해서 원격 객체 서비스를 제공
→ App에서 HTTP 요청을 이용해 원격의 서블릿을 실행시키는 방법
→ EJB 방식은 stub 객체가 자바 객체이기 때문에 java app에서만 사용할 수 있다
→ HTTP 요청은 프로그래밍 언어와 상관없다
  → 플랫폼, 기술 독립적이다
→ App은 java, c#, python, javascript 등... 가능
→ 그래서 EJB 폭망! RESTful 떡상!
→ 서버 쪽을 꼭 자바로 만들 필요가 없다 php, c#, python, javascript 등... 가능
-------------------------------------------------------------------------------------
★원격 메소드 호출

호출방식		로컬(local)	원격(remote)
로컬 메소드 	App → f() call 

RPC(절차적)	App ------------------> f() call  => HTTP 기반 stub<>skel

CORBA(언어독릭)	c.App ----------------> C# f()
		pascall.App ---------> COBOL f()  => HTTP 기반 stub<>skel
		C#.App --------------> python f()

RMI(객체지향)	java.App ------------> java객체(원격객체) call  => HTTP 기반 stub<>skel

EJB		java.App ------------> EJB 객체 call  => HTTP 기반 stub<>skel
(Java EE 기술)

Web Service  	c.App ---------------> C# f()  
		java.App ------------> python f()    => HTTP 기반 stub<>skel
		C#.App -------------> c f()

RESTful		c.App ---------------> C# f()  
		java.App ------------> python f()    => HTTP 요청

CORBA → 이기종 언어간에 메소드 호출
RESTful → stub과 skel이 없다
-------------------------------------------------------------------------------------
★ Java EE와 서버

Java EE
Implementation     ------------>    웹기술 / 분산 컴포넌트 / 분산 서비스 / 자원관리 등... 전체 기술 구현
Server
→ Java EE 기술 명세에 따라 동작하도록 구현한 서버
→ 예) JBoss, WebLogic, WebSphere, Jeus, Geronimo, GlassFish 등...
→ 웹 기술만 구현한 서버가 Servlet Container이다 
  → Jave EE 기술중 웹 기술만 구현(Servlet, JSP, JSTL, EL 등...)
  → 예) Tomcat, Resin, Jetty, Undertow

JBoss  ---->  Servlet, JSP, EJB, WebService         
→ 모두 실행 가능
Tomcat Server  ---->  Servlet, JSP, EJB, WebService     
→ 웹 기술인 Servlet, JSP만 실행 가능
-------------------------------------------------------------------------------------
Jave EE 기술버전과 서버 버전

	Tomcat		Servlet		JSP
	Java EE
-----	Tomcat 6		2.5		2.1
Jave	Tomcat 7		3.0		2.2
EE	Tomcat 8		3.1		2.3
-----	Tomcat 9		4.0		2.3
Jakarta	Tomcat 10	5.0		3.0
EE	Tomcat 10.1 	6.0		3.1
-------------------------------------------------------------------------------------
Java EE 와 Jakarta EE

Oracle이 유지보수
~ Java EE 8((Servlet 4.0, JSP 2.3), EL 3.0, JSTL 1.2)
Eclipse에서 유지보수
Jakarta EE 8(Servelt 4.0, JSP 2.3 ...) 
Jakarta EE 9(Servlet 5.0, JSP 3.0, EL 4.0, JSTL 2.0) 
Jakarta EE 10(Servlet 6.0, JSP 3.1, EL 5.0, JSTL 3.0) ~

Tomcat 9 = Java EE 8
Tomcat 10 = Jakarta EE 9
Tomcat 10.1 = Jakarta EE 10

Java EE 8 = Jakarta EE 8
→ 같은 버전 단 패키지명만 변경되었다
→ javax.servlet => jakarta.servlet
→ javax.servlet.jsp => jakarta.servlet.jsp
→ javax.* => jakarta.*
-------------------------------------------------------------------------------------
자바 소스 디렉토리 와 자바 패키지
app/	→ 프로젝트 폴더
      bin/
      src/      → 자바 소스 폴더
           com/    → 자바 루트 패키지 폴더
                  eomcs/
		  Hello.java
		  package com.eomcs;

app/	→ 프로젝트 폴더
      bin/
      src/      → 일반 폴더
           main/        → 일반 폴더
                   java/       → 자바 소스 폴더 → 루트 패키지 바로 위
           		com/    → 자바 루트 패키지 폴더
                  	       eomcs/
		                 Hello.java
		             package com.eomcs;
app/
       build/
             classes/
                        java/
                               com/
                                       eomcs/
                                                  Hello.class

$ java -calsspath 루트패키지를두는폴더의경로 FQName(패키지명+클래스명)
			또는
		       .jar 파일 경로
FQName = Fully-Qualified class name
app$ java -calsspath build/classes/java com.eomcs.Hello
-------------------------------------------------------------------------------------
web 프로젝트 표준 디렉토리 구조
app/	
      src/      
           main/        
                   java/    → 자바소스폴더 : .java
	      resources/    → 자바소스폴더 : .xml, .properties 등
	      webapp/      
		     WEB-INF/
			     web.xml     → deployment descrpton file(DDFile) = component 배치 정보를 기술한 파일 → 선택 사항
			     기타 웹 애플리케이션 관련 설정 파일
  	                   HTML, css, JavaScripte, 이미지, 등 = static resource

-------------------------------------------------------------------------------------



2024.02.21(수)
-------------------------------------------------------------------------------------
서블릿 만들기
<<interface>> Servlet <------ MyServlet[init(), service(), destroy(), getServletConfig, getServletConfigInfo()]
	          ↑---- <<abstract>> GenericServlet <----- MyServlet[service()]
				↑---- <<abstract>> HttpServlet <---- MyServlet[doGet(), doPost()]
-------------------------------------------------------------------------------------
서블릿 객체 생성 과정
					 if(not exist){ → 서블릿을 최초로 실행할 때 객체를 생성
Web browser → /ex01/first → Servlet/Container → new → Servlet01
					    └> 생성자 호출 → init() call} → service() call
init() → 서블릿이 사용할 자원을 준비한다
-------------------------------------------------------------------------------------
서블릿 배치 방법

★ ① 애노테이션
@WebServlet(value={"path", "", ""})
class Servlet01 () {}

② XML(DD파일=Deployment Descriptor 파일)
/WEB-INF/web.xml
<servlet>
  <servlet-name>서블릿 별명</servlet-name>
  <servlet-class>서블릿 클래스의 FQname</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>서블릿 별명</servlet-name>
  <url-patten>/hello</url-patten>
</servlet-mapping>
-------------------------------------------------------------------------------------
GenericServlet
<<interface>> Servlet 	<<interface>> ServletConfig 		<<interface>> Serializable
            ↑		[getServletName(), getServletContext()		  ↑
	|		 getInitParameter(), getInitParameterName()]	   |
            └---------┐┌----------------↑------------------------------------------------┘	
<<abstract>> GenericServlet <---- MySerblet[service()]

Server1(인사관리시스템(s1, s2, s3))	┐       → 1. 서버에 문제 발생 Serialize
				↓       → 2. 다른 서버로 현재 실행 상태를 그대로 옮긴다 deserialize
Server2(화계관리시스템(), 인사관리시스템(s1, s2, s3))
→ 서블릿 객체를 serialize 하는 상황
→ 이런 이유로 GenericServlet에서 Serializable 인터페이스를 구현하는 것이다
-------------------------------------------------------------------------------------
HttpServlet
<<abstract>> GenericServlet ← <<abstract>> HttpServlet ← MyServlet
→ GenericServlet이 구현하지 않은 Servlet의 service() 메소드를 구현

service(ServletRequest req, ServletResponse resp){
  service((HttpServletRequest) req, (HttpServletResponse) resp);
}

service(HttpServletRequest req, HttpServletResponse resp){
  GET 요청 → doGet() call
  POST 요청 → doPost() call
}

doGet()
doPost()
doHead()
-------------------------------------------------------------------------------------
★ Filter 만들기
<<interface>> Filter [init(), doFilter(), destroy()]
init() → 웹 애플리케이션 실행 → 필터 객체 생성 후 
doFilter() → 서블릿 요청에 필터가 적용될 때
destroy() → 웹 애플리케이션 종료
→ 서블릿 실행 전/후에 기능을 추가할 때 사용
  → 기능 : 암호 해제 / 암호화
  → 압축 해제 / 암축
  → 디코딩 / 인코딩
  → 로깅
→ GoF의 "chain of responsibility"
→ 기존 코드를 손대지 않고 기능을 추가 하거나 제거할 수 있는 설계 기법
→ FilterChain : 체인의 총괄 매니저
-------------------------------------------------------------------------------------
★ 필터 실행 ★

주요 웹 컴포넌트
Filter01(/ex02/*)  		Servlet01(/ex02/s1)  	Listener01(ServletContextListener)
Filter02(/ex02/a/*)  		Servlet02(/ex02/a/s2)  	Listener02(ServletRequestListener)

1)
1. /ex02/s1 → Servlet Container → 2. doFilter() → /ex02/*(Filter01) → 3. service() → /ex02/s1(Servlet01)
→ 4. /ex02/*(Filter01) → 5. Servlet Container → 6. 응답

Servlet Container		F1	S1	
요청
-----------|       doFilter()
            |------------------------| service()
			 |-----------|
			 |-----------|
            |------------------------|
-----------|
응답

2)
1. /ex02/s1 → Servlet Container → 2. doFilter() → /ex02/*(Filter01) → 3. doFilter() → /ex02/a/*(Filter02) → 4. service() → /ex02/a/s2(Servlet02)
→ 5. /ex02/a/*(Filter02) → 6. /ex02/*(Filter01) → 7. Servlet Container → 8. 응답

Servlet Container		F1	F2	S2
요청
-----------|       doFilter()
            |------------------------| doFilter()
			 |-----------| service()
				 |-----------|
				 |-----------|
			 |-----------|
            |------------------------|
-----------|
응답

UML의 Interaction Diagram 중에서 "Sequence Diagram"
→ 서블릿 실행 전/후에 기능을 추가할 때 사용
  → 기능 : 암호 해제 / 암호화
  → 압축 해제 / 암축
  → 디코딩 / 인코딩
  → 로깅
→ GoF의 "chain of responsibility"
→ 기존 코드를 손대지 않고 기능을 추가 하거나 제거할 수 있는 설계 기법
→ FilterChain : 체인의 총괄 매니저
-------------------------------------------------------------------------------------
필터 구동 실체
요청 → Servlet Container → call → FilterChain → F1 → doFilter() → F2 → doFilter() → Servlet → service()
→ return → F2 → return →  F1 → FilterChain → return → Servlet Container → 응답
→ 클래스 간의 coupling을 맺지 않는다
→ 의존 관계가 아니다
→ 유지 보수가 쉽다
-------------------------------------------------------------------------------------
★ 리스너 실행 ★

Filter01(/ex02/*)  		Servlet01(/ex02/s1)  	Listener01(ServletContextListener)
Filter02(/ex02/a/*)  		Servlet02(/ex02/a/s2)  	Listener02(ServletRequestListener)

		┌ <2.  requestInitialize() call / 3. return> Listener02
1. /ex02/s1 → Servlet Container → 4. doFilter() → Filter01 → 5. doFilter() → Filter02 → 6. service() → Servlet02
→ 7. Filter02 → 8. Filter01 → 9. Servlet Container <10. requestDestroyed() call / 11. return> Servlet Container → 12. 응답
→ 시스템이 특정 상태에 놓일 때 알림(메소드가 호출됨)을 받아 작업 수행
→ "Listener" = Observer => GoF의 Observer 패턴
// => 서블릿 컨테이너 또는 서블릿, 세션 등의 객체 상태가 변경되었을 때 보고 받는 옵저버
// => "Observer" 디자인 패턴이 적용된 것이다.
// => ServletContextListener
//    - 웹 애플리케이션을 시작하거나 종료할 때 보고 받고 싶다면 이 인터페이스를 구현하라.
// => ServletRequestListener
//    - 요청이 들어오거나 응답할 때 보고 받고 싶다면 이 인터페이스를 구현하라.
// => HttpSessionListener
//    - 세션이 생성되거나 종료될 때 보고 받고 싶다면 이 인터페이스를 구현하라.
// => XxxListener
//    - 기타 다양한 인터페이스가 있다. 문서를 참고하라.
-------------------------------------------------------------------------------------
리스너, 필터, 서블릿 우선순위

→ 서버 실행 → ContextListener 생성 → RequestListener 생성 → Filter 생성
→ 요청 → RequestListener 호출 → 필터 호출 → 서블릿 생성 호출 or 서블릿 호출 
→ 서블릿 종료 → 필터 종료 → RequestListener 종료 → ContextListener 종료 → 서버 종료

웹 애플리케이션 실행 →
ContextListener → 생성과 실행
RequestListener → 생성
Filter → 생성
웹 요청 →
RequestListener → 요청 들어왔을 때 실행 
Filter → 요청리스너를 거쳐 실행
Servlet → 필터를 거쳐 생성 실행 or 실행 
종료 →
Servlet → 종료
Filter → 리턴
RequestListener → 종료
Filter, ContextListener → 다른 요청이 없고 웹 애플리케이션 종료 직전에 종료
-------------------------------------------------------------------------------------



2024.02.22(목)
-------------------------------------------------------------------------------------
★ 서블릿에서 출력하기
getWriter() → ServletResponse → PrintWrite 리턴
print(콘텐트) → PrintWriter → 버퍼에 콘텐트 저장
→ 버퍼에 있는 콘텐트를 응답할 때 UTF-16BE를 ISO-8859-1로 변환해서 응답한다
→ 한글은 ISO-8859-1 코드표에 존재하지 않는 문자이기 때문에 변환불가!
→ 그런 의미에서 '?' 문자로 변환된다

response.setContentType("text/plain;charset=UTF-8"); // UCS2(UTF-16) ==> UTF-8
PrintWriter out = response.getWriter();

MIME Type : Multi-purpose Internet Mail Extension
 => 콘텐트의 형식을 표현
 => 콘텐트타입/상세타입
 => 예) text/plain, text/css, text/html 등
 => 웹 브라우저는 콘텐트를 출력할 때 서버가 알려준 MIME 타입을 보고 어떤 방식으로 출력할 지 결정한다.
-------------------------------------------------------------------------------------
★ binary data 응답
/photo.jpeg
web browser <photh.jpeg요청 / photh.jpeg응답> webserver	servlet container		servlet04
					    └ /photh.jpeg 읽기
web browser </ex03/s4요청 / 응답> webserver <위임> servlet container <service() / return> servlet04 → FileInputStream로 읽고 OutputStream으로 출력
-------------------------------------------------------------------------------------
HTTP - web browser와 web server 사이에 데이터를 주고 받는 규칙
① 요청 규칙
Method SP Request-URI SP HTTP-Version CRLF → Request-Line	GET /photo.jpeg HTTP/1.1 (enter)
Mehod → GET, POST, HEAD, PUT, DELETE, TRACE, OPTIONS
general-header * → 요청, 응답에 모두 사용; Date, Connection 등	Connection : close (enter)
request-header * → 요청에서 사용; Accept, Host, User-Agent 등	User-Agent : 브라우저 정보 (enter)
entity-header * → 서버에 보내는 데이터 정보; Content-Type, Content-Length 등 	Content-Type : application/json, Content-Length : 14 (enter)
CRLF									
message-body → 서버에 보내는 데이터(POST 요청)		{"name":"aaa"}
=entity

② 응답 규칙
HTTP-Version SP Status-Code SP Reason-Phrase CRLF		HTTP/1.1 200 ok (enter)
Status-Code → 1xx, 2xx(성공), 3xx, 4xx(요청오류), 5xx(서버오류)
general-header *  
response-header * → 응답할 때 사용; Server, Location 등		Server : 응답하는 서버의 정보 (enter)
entity-header * 
CRLF
message-body 						클라이언트에게 보내는 데이터
-------------------------------------------------------------------------------------
Proxy Server
|	        Local		           |	        Remote	    |
web browser < 요청 / 응답> Proxy Server < 요청 / 응답> Web Server
Proxy Server 역할
→ 주고 받는 데이터를 관찰, 감시
→ cache 기능 : 서버에서 받은 콘텐트를 보관
예) JDK 다운로드
GET → GET → 응답 → Proxy Server cache에 JDK 보관 → 응답
GET → HEAD → 응답 : JDK 정보 → 서버에서 받은 JDK 정보와 캐시에 보관된 JDK를 비교하여 같다면, 보관된 JDK를 web browser에게 준다 다르다면, 서버에서 다시 다운로드한다
HEAD → JDK 정보를 달라는 메소드
-------------------------------------------------------------------------------------
GET 요청에서 데이터 보내기
Request-URI에 Query String으로 보낸다
예) http://서버:포트/ex04/s1?name=aaa&age=20
name=aaa&age=20 → Query String
name → parameter name
aaa → parameter value

POST 요청에서 데이터 보내기
message-body에 데이터를 실어 보낸다
예) POST /ex04/s2 Http/1.1 (enter)
...
content-Type : application/x-www-form-urlencoded (enter)
content-Length : 33 (enter)
...
name=AB%EA%B0%80%EA%B0%81&age=123
-------------------------------------------------------------------------------------
GET 요청 데이터 전송
name=AB%EA%B0%80%EA%B0%81&age=123
web browser → utf-8변환+url인코딩 → web server (url 디코딩) → getParameter() 하면 utf-8=>UTF-16BE로 변환 → "AB가각" 
UTF-16 0041 0042 AC00 AC01 AB가각

★ POST 요청 데이터 전송
name=AB%EA%B0%80%EA%B0%81&age=123
web browser → utf-8변환+url인코딩 → web server (url 디코딩) → getParameter() 하면 ISO-8859-1=>UTF-16BE로 변환 → "AB가각" 
→ getParameter() 호출하면 ISO-8859-1로 생각한다
ISO-8859-1 0041 0042 00ea 00b0 0080 00ea 00b0 0081 AB????
→ 클라이언트가 보낸 문자의 charset을 ISO-8859-1로 착각한다
→ getParameter()를 호출하기 전 request.setCharacterEncoding("UTF-8")을 먼저 호출한다
-------------------------------------------------------------------------------------
GET vs POST

			GET			POST
데이터전송		url에 포함		message-body에 포함
binary data 전송		전송불가			multipart/form-data 포맷으로 인코딩한다면 가능
			(단 binary 데이터를 base64로 인코딩해서 텍스트로 변환한다면 가능)
전송크기 		웹서버에 설정된 크기 = 보통64KB 또는 8K	제한없음(단 서블릿에서 제한할 수 있다)
보안 		웹 브라우저는 url을 보관한다		데이터 노출 안됨
		→ 데이터가 노출된다
용도		url에 데이터를 포함해야 하는 경우	게시글 등록과 같은 대량의 데이터 전송
		→ 게시글 조회 url			binary data 전송
-------------------------------------------------------------------------------------
★ apache commons-fileupload 사용법

DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
ServletFileUpload multipartDataHandler = new ServletFileUpload(fileItemFactory);

실제 경계 문자열 예) ------WebKitFormBoundaryogFq6gl3Nbl5A4sI
---------------------------------
name=aaa
---------------------------------
age=20
---------------------------------
file1
---------------------------------
file2
---------------------------------
→ 분석 → ServletfileUpload → 파트를 넘긴다 → DiskfileItemFactory → 각 파트마다 FileItem 생성
	→ 멀티파트 데이터 부분		→ 파트의 데이터를 FileItem 객체에 담는다

Part part = get.part();
-------------------------------------------------------------------------------------



2024.02.23(금)
-------------------------------------------------------------------------------------
메소드 재정의와 메소드 호출
1)
<<abstract>> GenericServlet <---- <<abstract>> MyHttpServlet[service(ServletRequest, ServletResponse){service(req, res);}, service(HttpServletRequest, HttpServletResponse){}] 
					    ↑
					Servlet02[service(HttpServletRequest, HttpServletResponse){}]
Servlet Container → service(ServletRequest, ServletResponse) → Servlet02
→ Servlet 인터페이스에 정의된 규칙에 따라 service(ServletRequest, ServletResponse)를 호출한다
→ 메소드를 호출할 때 항상 객체의 클래스부터 찾아 super 클래스로 올라간다

2)
<<abstract>> GenericServlet
		↑
<<abstract>> MyHttpServlet[service(ServletRequest, ServletResponse){service(req, res);}, service(HttpServletRequest, HttpServletResponse){}, doGet(){}, doPost(){}] 
					    ↑
					Servlet03[service(HttpServletRequest, HttpServletResponse){}, doGet(){}, doPost(){}]
Servlet Container → service(ServletRequest, ServletResponse) → Servlet03
→ Servlet 인터페이스에 정의된 규칙에 따라 service(ServletRequest, ServletResponse)를 호출한다
→ 클라이언트 요청(GET, POST) 방식에 따라 Servlet03에 있는 doGet(), doPost()를 호출한다
-------------------------------------------------------------------------------------
// 클라이언트가 실행을 요청하지 않아도 서블릿을 미리 생성하고 싶다면,
// loadOnStartup 프로퍼티 값을 지정하라.
//     loadOnStartup=실행순서
// 미리 생성할 서블릿이 여러 개 있다면, loadOnStartup에 지정한 순서대로 생성한다.
// 서블릿을 미리 생성하는 경우?
// => 서블릿이 작업할 때 사용할 자원을 준비하는데 시간이 오래 걸리는 경우
//    웹 애플리케이션을 시작할 때 미리 서블릿 객체를 준비하는 것이 좋다.
//    예) DB 연결, 소켓 연결, 필요한 환경 변수 로딩, 스프링 IoC 컨테이너 준비 등
@WebServlet(value="/ex06/s1", loadOnStartup=1)
-------------------------------------------------------------------------------------
★ Forwarding - 서블릿 실행을 위임하기
Servlet01(/ex07/s1) +
Servlet02(/ex07/s2) -
Servlet03(/ex07/s3) error	
/ex07/s1?op=+&a=100&b=200 → Servlet Container < call / return > Servlet01[service()]
/ex07/s1?op=-&a=100&b=200 → Servlet Container < call / return > Servlet01[service()] < call / return > Servlet02[service()]
→ 서블릿이 역할에 맞으면 리턴
→ 역할에 맞지 않다면 다른 서블릿에게 위임
→ 요청에 -라면 Servlet01에 service()를 호출하고 Servlet02에게 위임한다 처리하고 Servlet01에게 리턴한다
→ Forwarding 하기 전에 버퍼에 출력된 모든 내용은 삭제한다!
→ Forwarding 서블릿을 실행한 수 리턴되면 그 이후에 출력은 모두 무시된다!
-------------------------------------------------------------------------------------
★ Including - 다른 서블릿의 작업을 포함시키기
/ex07/s1?op=+&a=100&b=200 → Servlet Container < call / return > Servlet11[service()]
include <> Servlet_plus
include <> Servlet_minus
include <> Servlet_error
→ including은 forwarding과 달리 include 전에 수행했던 출력을 그대로 유지한다
→ 리턴된 후에도 출력할 수 있다
→ Servlet11 작업 + Servlet11_plus 작업 or Servlet11_minus 작업 or Servlet11_error 작업
-------------------------------------------------------------------------------------
forwarding / including 응용
/doard/list → Servlet Container → BoardListServlet → include() → HeaderServlet → 출력
				└> 게시글 목록 출력
				└> include() → FooterServlet → 꼬리말 출력
				└> forward() → ErrorServlet → 실행오류 페이지만 출력
→ 3개의 서블릿이 협업
-------------------------------------------------------------------------------------
Refresh - 클라이언트에게 다른 url을 요청하라는 명령
web browser < 요청 / 응답 > Servlet01 → 작업
		      └> 다시 요청할 url을 포함
	└< 요청 / 응답 > Servlet02 → Refresh 응답 헤더에 설정된 시간이 지난 후 알려준 url로 자동 요청한다

HTTP/1.1 200 ok (enter)
content-Type : text/plain;charset=UTF-8 (enter)
content-Length : 28 (enter)
Refresh : 3;url=s100 (enter)
...
// HTML을 출력하는 경우
// 응답 헤더가 아니라 HTML 헤더에 리프래시 명령을 설정할 수 있다.
out.println("<meta http-equiv='Refresh' content='3;url=s100'>");
-------------------------------------------------------------------------------------
Redirect - 응답할 때 콘텐트를 보내지 않는다, 바로 다른 페이지를 요청하고 명령한다
web browser < 요청 / 응답 > Servlet01 → 작업
		      └> 다시 요청할 url을 포함, 콘텐트는 포함하지 않는다
	└< 요청 / 응답 > Servlet02 → 응답 받는 즉시 알려준 url로 요청한다

HTTP/1.1 302 Found (enter)
content-Type : text/plain;charset=UTF-8 (enter)
content-Length : 0 (enter) → 콘텐트를 보내지 않기 때문이다
Location : s100 (enter)
...
message-body는 없다
-------------------------------------------------------------------------------------
★ forward, include, refresh, redirect ★

① forward
 RequestDispatcher 요청배달자 = request.getRequestDispatcher("/ex07/s2");
요청배달자.forward(request, response);

클라이언트 < 요청 / 응답 > 서블릿1 출력1 < RequestDispatcher.forward() / 리턴 > 서블릿2 출력2
→ 출력1은 무시하고 출력2만 출력

② include
RequestDispatcher 요청배달자 = request.getRequestDispatcher("url");
요청배달자.include(request, response);
or
request.getRequestDispatcher("/header").include(request, response);

클라이언트 < 요청 / 응답 > 서블릿1 출력1 < RequestDisPatcher.include() / 리턴 > 서블릿2 출력2
→ 출력1 + 출력2 출력

③ refresh
response.setHeader("Refresh", "1;url=/index.html"); 
or
out.println("<meta http-equiv='Refresh' content='3;url=s100'>");

클라이언트 < 요청 / 응답 > 서블릿1 콘텐트+url
     └> 콘텐트 출력 후 다른 url 요청 / 응답
200 ok
Refresh : url
→ 서블릿1 요청 응답 후 콘텐트 출력 
→ 다른 url 요청

④ redirect 
response.sendRedirect("/board/list?category=" + category);
return;

클라이언트 < 요청 / 응답 > 서블릿1 +url
     └> 다른 url 요청 / 응답
302 Found
Location : url
→ 서블릿1 요청 응답 후 url 요청
→ 콘텐트는 없다
-------------------------------------------------------------------------------------
과제 59. GET/POST 요청을 구분하기
- HttpServlet의 doGet(), doPost를 이용하여 GET 요청과 POST 요청을 구분하여 처리하기
- 로그인, 게시글 등록 및 변경, 회원 등록 및 변경, 과제 등록 및 변경에 적용
-------------------------------------------------------------------------------------
과제 60. refresh/redirect 다루기
- 로그인 후 refresh 하기
- 로그아웃 후 redirect 하기
- 데이터 등록/변경/삭제 후 목록 페이지로 이동할 때 redirect 하기
-------------------------------------------------------------------------------------
과제 61. forward/include 다루기
- 상단 메뉴 및 하단 정보 출력에 include 사용하기
- 오류 메시지 출력에 forward 사용하기
-------------------------------------------------------------------------------------



2024.02.26(월)
-------------------------------------------------------------------------------------
forward 응용
클1 <요청/응답> 서블릿1 → 오류발생 → forwarding → ErrorServlet → 오류 메세지 출력
클2 <요청/응답> 서블릿2 → 오류발생 → forwarding → ErrorServlet → 오류 메세지 출력
→ 오류 정보를 ServletRequest에 저장 후 넘긴다 
→ ServletRequest에서 오류 정보를 꺼내서 오류 메세지를 출력한다
-------------------------------------------------------------------------------------
forward/include 서블릿끼리 객체 공유
클라이언트 → 서블릿1 → forward/include → 서블릿2
	      request, response  → 전달 → request, response
RequestDipatcher rd = request.getRequestDispatcher("/s2");
rd.forward(request, response);
rd.include(request, response);
forward/include 하는 서블릿에게 request와 response를 넘긴다 = 공유한다
-------------------------------------------------------------------------------------
★ ServletRequest/ServletResponse Lifecycle
요청 → HttpServletRequest, HttpServletResponse 생성 → 응답
   └ s1 → forward/include → s2 → forward/include → s3 ┘
→ refresh/redirect는 다른 url을 요청하는 것이기 때문에 새로운 ServletRequest/ServletResponse를 생성한다
-------------------------------------------------------------------------------------
과제 62. 파일 업로드 다루기 - multipart/form-data POST 요청 파라미터 인코딩
- Servlet API를 이용하여 multipart/form-data 파라미터를 다루는 방법
- 회원 사진 추가
- DDL 변경
-------------------------------------------------------------------------------------
Cookie
1) 쿠키 저장
web browser < 요청 / 응답+쿠키 > Servlet
       ↓
쿠키 저장(key, value)

HTTP/1.1 ok (enter)
Set-Cookie:email=user1@test.com;Max-Age=12;
Set-Cookie:쿠키이릅=값;Max-Age=12;
message-body

2) 쿠키 읽기
web browser → 쿠키 로딩 → 요청+쿠키 → 서블릿 → 응답
GET /auth/login HTTP/1.1 (enter)
Cookie:email=test1@test.com;쿠키명=값; ... (enter)
→ 클라이언트는 웹서버에서 받은 쿠키를 해당 웹서서에 방문한 때마다 보낸다
-------------------------------------------------------------------------------------
프로젝트 절차

1) 프로젝트 주제 
→ 현황 및 문제점(프로젝트를 하게 된 이유)
→ 해결방안 및 사용자의 이점
→ 주요 기능 소개
  → 간단한 ui 프로토타입

2) 요구사항 정의
→ use-case 모델
  → actors
  → usecase
→ ui 프로토타입

3) 분석 설계
→ DB 모델링
  → DDL, sample data

4) 구현
→ 코드

5) 발표
→ 프로젝트 소개
→ 시연
→ 팀별로 소감
-------------------------------------------------------------------------------------



2024.02.27(화)
-------------------------------------------------------------------------------------
Wep App 보관소

웹 앱 시작 → ServletContext 생성 / 종료 → 웹 앱 종료
=> 웹 앱당 하나
=> DAO, service, Transaction, DB 커넥션 등

클라이언트 접속 → HttpSession 생성 / 종료 → 클라이언트 종료(타임 아웃/세션 무효화)
=> 클라이언트당 하나
=> 로그인 정보, 이전 페이지 정보, 트랜잭션 작업 관련 등

요청 → ServletRequest 생성 → s1 → s2(forward/include) → s3(forward/include) → 응답
=> 요청당 하나
=> 오류 정보, 페이지 작업 정보

요청 → ServletRequest 생성 → JSP(java server page) → JSP → 응답
				└ JSP Context	     └ JSP Context
=> JSP 마다 JSP Context를 갖고 있다
=> JSP 실행할 때 생성되고 JSP 종료될 때 사라진다
-------------------------------------------------------------------------------------
쿠키(Cookie) - 클라이언트에게 보내기
→ 웹 서버가 웹 브라우저에게 맡기는 데이터
→ 응답할 때 응답 헤더에 포함시켜 보낸다
→ 웹브라우저는 응답헤더로 받은 쿠키 데이터를 보관하고 있다가 지정된 url을 요청할 때 요청 헤더에 포함시켜 웹 서버에게 쿠키를 다시 보낸다

웹 브라우저 </auth/login 요청/응답> 서블릿 컨테이너
└ 쿠키 저장

응답
HTTP/1.1 ok (enter)
Set-Cookie : 이름=값; ...
Set-Cookie : email=a@test.com

쿠키테이블
name	value	유효기간	   사용범위
이름	값	기간	   ...
email	a@test.com
→ 유효기간을 설정하지 않으면 웹 브라우저가 실행되는 동안만 유효하다
→ 사용범위 설정하지 않으면 /auth/*
→ 웹 브라우저는 사용범위에 해당하는 요청을 할 때만 쿠키를 보낸다
-------------------------------------------------------------------------------------
쿠키(Cookie) - 서버로 보내기

쿠키테이블
name	value	유효기간	   사용범위
이름	값	기간	   ...
email	a@test.com

웹 브라우저 </auth/login 요청/응답> 서블릿 컨테이너
└ 쿠키 읽기

GET /auth/login HTTP/1.1 (enter)
Cookie : email=a@test.com
...
→ 요청 헤더 
-------------------------------------------------------------------------------------
★ 쿠키 사용 하기 ★
Cookie c = new Cookie("v1", "aaa");
Cookie c5 = new Cookie("name3", URLEncoder.encode("홍길동", "UTF-8"));
// 프로토콜 예 => Set-Cookie: name3=%ED%99%8D%EA%B8%B8%EB%8F%99
URLDecoder.decode(c5.getValue(), "UTF-8")

c.setMaxAge(60); // 쿠키를 보낸 이후 60초 동안만 유효
c.setPath("/ex10/a"); // 쿠키 범위 설정

// 쿠키 꺼내기
// => 쿠키를 이름으로 한 개씩 추출할 수 없다.
// => 한 번에 배열로 받아야 한다.
// => 요청 헤더에 쿠키가 없으면 리턴 되는 것은 빈 배열이 아니라 null이다.
// => 따라서 무조건 반복문을 돌리면 안된다.
Cookie[] cookies = request.getCookies();
out.printf("%s=%s,%s\n", c.getName(), c.getValue(), URLDecoder.decode(c.getValue(), "UTF-8"));
-------------------------------------------------------------------------------------
쿠키 범위
웹 브라우저 → 요청 → 서블릿 컨테이너

v1 → /ex10/*	=>	(/ex10/s22), (/ex10/a/b/c/s23)
v2 → /ex10/a/*	=>	(/ex10/a/b/c/s23)
v3 → /		=>	(/ex10/s22), (/ex10/a/b/c/s23), (/ex10_1/s24)
-------------------------------------------------------------------------------------
HttpSession 과 Cookie의 관계

웹 브라우저 	      서블릿 컨테이너
요청 without 세션ID <=> 응답 
요청 without 세션ID  =>  getSession() → new HttpSession
쿠키 테이블에 저장	  <=  응답+쿠키(세션 id=2720)
요청 without (2720)  =>  getSession() → 2720번 기존 세션을 찾아서 리턴
		  <=  응답 → 새로 세션을 만들지 않았기 때문에 세션id를 쿠키로 보내지 않는다
→ 클라이언트에서 세션id를 보내지 않았다고 무조건 세션을 만드는 것이 아니다
→ getSession()(=세션이 없을 때)을 호출할 때, 유효기간이 지난 경우 생성한다
→ 클라이언트 전용 세션이 없으면 생성한다
→ 새로 세션을 만들면 클라이언트에게 알려주기 위해 세션id를 쿠키로 보낸다

쿠키 테이블
name	  value	max-age	    path
JSSESION   2720	x	    /
-------------------------------------------------------------------------------------
client 와 HttpSession
사용자1		서블릿 컨테이너		사용자2
크롬    <------->	new HttpSession   <------>	크롬
	200			  300
크롬    <------->	HttpSession
→ 쿠키 테이블 공유 200을 넘김, 같은 session 객체 사용
해킹s/w <------>	HttpSession
→ 서블릿 컨테이너는 크롬인지 해킹s/w인지 확인을 하지 않는다, 같은 session 객체 사용

사용자1 쿠키 테이블
세션id = 200

사용자2 쿠키 테이블
세션id = 300
-------------------------------------------------------------------------------------
HttpSession 저장소 활용
클라이언트	서블릿 컨테이너	         HttpSession
s11 요청  -------->	
	<--------  응답
이름:aaa  --------->  s12	------------>   name:aaa
	<--------  응답
나이:20   --------->  s13        ------------>   age:20
	<--------  응답
전화:111   --------->  s14      <------------   name, age
	<--------  응답
이름:aaa
나이:20
전화:111
	 --------->  s15      ------------->  DBMS에 name, age, tel을 저장
→ 여러 개의 작업이 이루어질 때 사용(트랜잭션)
→ transaction에서 입력 받는 데이터나 중간 계산 결과를 임시 보관할 때 사용
-------------------------------------------------------------------------------------
세션 사용 하기

HttpSession session = request.getSession();
// 세션에 데이터 보관하기
session.setAttribute("v1", "aaa");
→ 새로 세션을 만들면, 무조건 응답할 때 새 세션의 아이디를 쿠키로 보낸다.
→ 세션 객체를 만들어야 서버가 세션id를 만들어 준다

session.setMaxInactiveInterval(10);
→ 시간(초)이 지나면 session 객체를 무효화 시킨다
→ 기본 설정으로 새로운 session 객체를 만든다

session.invalidate(); // 세션을 무효화시킨다.
-------------------------------------------------------------------------------------
서블릿 배치 정보 설정

1) web.xml에 배치 정보 등록
<servlet>
    <servlet-name>ex12.Servlet01</servlet-name>
    <servlet-class>com.eomcs.web.ex12.Servlet01</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>ex12.Servlet01</servlet-name>
    <url-pattern>/ex12/s01</url-pattern>
</servlet-mapping>

2) 애노테이션에 등록
@WebServlet("/ex12/s02")

3) ★ 객체를 직접 생성하여 등록 : 웹 애플리케이션을 시작할 때 ★
@WebListener
public class Listener01 implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent sce) {
    ServletContext sc = sce.getServletContext();
    Servlet03 servlet = new Servlet03();
    Dynamic 서블릿설정정보 = sc.addServlet("ex12.Servlet03", servlet); // <servlet>...</servlet>
    서블릿설정정보.addMapping("/ex12/s03"); // <servlet-mapping>...</servlet-mapping>
  }
}
-------------------------------------------------------------------------------------



2024.02.28(수)
-------------------------------------------------------------------------------------
필터 init-param 값 꺼내기

encoding = filterConfig.getInitParameter("encoding");

<filter>
    <filter-class>bitcamp.myapp.filter.CharacterEncodingFilter</filter-class>
    <filter-name>CharacterEncodingFilter</filter-name>
    <init-param>
      <param-name>encoding</param-name>
      <param-value>UTF-8</param-value>
    </init-param>
  </filter>
  <filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
-------------------------------------------------------------------------------------
과제 64. 필터 활용하기
- 필터를 활용하는 방법
-------------------------------------------------------------------------------------
JSP 도입
JSP 소스 → JSP Engine이 컴파일 → 자바 서블릿 소드 → Java Compiler가 컴파일 → 자바 클래스 완성

form.jsp			<<interface>>JspPage[jspInit(), jspDestroy()] <------- <interface>>HttpJspPage[jspService()]       <┐
				→ JSP로 만든 서블릿은 반드시 구현해야 한다					|
|			       javax					    |		Tomcat		|	        		
<<interface>>Servlet <-------- <<abstract>>GenericServlet <ㅡㅡㅡ <<abstract>>HttpServlet <ㅡㅡㅡ <<abstract>>HttpJspBase[] <ㅡㅡㅡ <<concrete>>form_jsp[-jspService()]
												└> jspInit(), jspDestroy() 구현
init() → call → jspInit()
destroy() → call → jspDesttroy() 
service() → call → -jspService()

form.jsp → JSP Engine이 컴파일 → form_jsp.java → Java Compiler가 컴파일 → 자바 클래스 완성
-------------------------------------------------------------------------------------
JSP와 MVC 모델 1
		View, Controller			         Model(업무 관련 로직 실행)
요청/응답 <> JSP(UI 생성, 입출력 데이터 가공, 업무 흐름 제어) <> DAO(데이터 처리) <> DBMS

		View, Controller				Model()		    		  Model(업무 관련 로직 실행)
요청/응답 <> JSP(UI 생성, 입출력 데이터 가공, 실행 흐름 제어) <> service(업무 흐름 제어 → 트랜잭션 제어) <> DAO(데이터 처리) <> DBMS
-------------------------------------------------------------------------------------
JSP와 MVC 모델 2
	       Controller		  Model
요청/응답 <> 서블릿(실행 흐름 제어) <> DAO(데이터 처리) <> DBMS
	       ↓↑ forward/include
	       JSP(UI 생성) → View
도메인(Board, Member, Assignment) → 모든 객체가 사용한다, Model이다
-------------------------------------------------------------------------------------
Servlet  과 JSP의 역할
요청/응답 <> 서블릿 <forward/include> JSP

서블릿
→ 입력 데이터를 작업하기 적합하게 가공
→ 모델 객체를 통해 요청한 작업을 처리한다
→ JSP가 출력하기 적합하게 작업한 데이터 가공
→ 클라이언트로 보낼 화면을 만들 JSP를 실행(forward, include)

JSP
→ 서블릿이 준비하는 데이터를 가지고 화면을 만든다
→ HTML, CSS, JacaScript 등
-------------------------------------------------------------------------------------
과제 65. JSP를 이용하여 MVC 모델2 구조로 변경하기
- MVC 모델1/모델2 특징 이해
- JSP 구동 원리 이해 및 사용법
- 서블릿과 JSP의 역할 및 구동 원리
-------------------------------------------------------------------------------------



2024.02.29(목)
-------------------------------------------------------------------------------------
과제 66. EL/JSTL
- EL 사용법
- JSTL 사용법
-------------------------------------------------------------------------------------
JSP 태그
<%@ page ~~~~ %> → JSP 페이지 설정			|
<%@ page include="~" %> → 다른 파일의 콘텐트를 삽입		| → directive element
<%@ taglib ~~~ %> → 외부 태그를 가져오기			|

<% ~자바 코드~ %> 
→ 서블릿 클래스에 삽입할 코드
→ scriptlet

<%= 표현식 %> 
→ 표현식의 리턴 값을 출력
→ expression element

<%! 필드 및 메소드 %> 
→ 서블릿 클래스에 필드 및 메소드 삽입
→ declaration element

<jsp:xxx ~~~ /> 
→ 특정 자바코드 삽입
→ JSP action tag
-------------------------------------------------------------------------------------
EL(Expression Language)
${객체.프로퍼티.프로퍼티. ....}
→ OGNL(Object Graph Navigation Language) 표기법을 이용하여 값을 다룬다

JSTL(JSP Standard Tag Library)
→ JSP 확장 태그
-------------------------------------------------------------------------------------
과제 67. Front Controller 디자인 패턴 도입하기
- Front Controller 디자인 패턴의 효과 및 적용 방법
- 프론트 컨트롤러와 페이지 컨트롤러의 역할 이해
-------------------------------------------------------------------------------------
Front Controller 도입

1) 도입 전
/board/list <요청/응답> BoardListServlet → BoardDao
       			↓↑		↓
	     	 /board/list.jsp	→       Board List

/member/list <요청/응답> MemberListServlet → MemberDao 
       			↓↑		↓
	      	/memeber/list.jsp  →	Member List

→ 각각의 서블릿이 요청을 받아 처리한다

2) 도입 후
모든 요청 → DispatcherServlet(프론트 컨트롤러) → include → BoardListServlet, MemberListServlet(페이지 컨트롤러)
		↓↑
	              JSP

BoardListServlet → BoardDao
       	↓↑		↓
		       Board List

MemberListServlet → MemberDao 
       	↓↑		↓
		       Member List

→ 모든 요청을 받는다
→ 서블릿이 반복적으로 하던 일을 처리한다
-------------------------------------------------------------------------------------
상대경로
http://localhost:8888/app/assignmnet/list → list는 자원의 이름
http://localhost:8888/app/assignmnet/list/app/assignment/add

<a href="app/assignment/add"> 새 과제 </a>
→ /가 없으면 상대경로를 가리킨다
→ 현재 웹브라우저 경로를 기준으로 계산한다

화성시 동탄대로 4길 333동 1111호 홍길동

절대경로
http://localhost:8888/app/assignmnet/list
http://localhost:8888/app/assignment/add

<a href="/app/assignment/add"> 새 과제 </a>
→ 절대경로는 포트번호 뒤에 붙는다
-------------------------------------------------------------------------------------
과제 68. 페이지 컨트롤러를 POJO로 전환하기
- 페이지 컨트롤러를 POJO 클래스로 변경 POJO = Plain Old Java Object (그냥 일반 자바 문법으로 만든 클래스)
- 의존 객체 주입하기
- 일반 자바 클래스가 되어도 문제 없다
- 특별한 확장 라이브러리를 사용하지 않은 자바 클래스
- 서블릿 객체에서 일반 객체로 전환

모든 요청 → DispatcherServlet(프론트 컨트롤러) → call → <<interface>>PageController <------- BoardListController, MemberListController
		↓↑
	              JSP
-------------------------------------------------------------------------------------



2024.03.04(월)
-------------------------------------------------------------------------------------
JSP의 구동원리
/hello.jsp → servlet Container → 서블릿 클래스가 없거나 JSP가 변경되었다면
→ JSP Engine이 서블릿 클래스 생성 
→ hello.java → java 컴파일러가 컴파일 
→ hello.class → 서블릿 컨테이너가 인스턴스 생성 init() 호출
→ hello 인스턴스 → service() 호출
-------------------------------------------------------------------------------------
JSP 태그
1) directive element
<%@ ~~ %>
→ 특정 자바코드를 생성한다
<%@ page 
    language="java" 
    contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"
    trimDirectiveWhitespaces="true"
    errorPage="ex20_error.jsp" → 에러가 뜨면 해당 경로로 포워딩(exception 객체는 ServletRequest 객체에 저장되어 이동)
    isErrorPage="true" → 에러를 받는 jsp에서 설정을 해야 exception 객체를 빌트인 해준다
    import="java.util.List,java.util.Map,java.util.Set"
    buffer="8kb"
    autoFlush="false"
%>
<%@ taglib 
    uri="확장 태그를 정의할 때 부여한 확장 태그 URI" 
    prefix="확장태그를 사용할 때 붙이는 접두사"%>
<%@ page import="java.sql.Statement"%>

2) declaration element
<%! ~~ %>
→ 필드, 메소드
→ 클래스 블록 안에 그대로 복사

3) scriptlet
<% ~~ %>
→ 자바 코드를 그래도 복사

4) expression element
<%= ~~ %>
→ 표현식
→ 출력문의 파라미터 자리에 복사
expression language
${객체.객체.객체.프라퍼티}

5) JSP action tag
<jsp:~ ~~ %>
<jsp:useBean id="객체명" class="클래스명" scope="보관소명"/>   
<jsp:useBean id="레퍼런스명" type="레퍼런스타입" scope="보관소"/>
<jsp:useBean id="b3" class="com.eomcs.web.vo.Board" scope="page"/>
                               └> type은 객체가 없으면 에러, class는 객체가 없으면 인스턴스 생성(type, class 같이 사용 가능)
<jsp:setProperty name="b3" property="no" value="100"/>
<jsp:setProperty name="b3" property="contents" value="내용입니다."/>
<jsp:setProperty name="b3" property="viewCount" value="88"/>
<%=b3%> => out.print(b3);<br> 

<jsp:include page="ex19_header.jsp"/>

6) template date
→ 그냥 작성 → 출력문을 생성한다 예) out.write("out.write("템플릿 데이터")");

7) JSP 주석
<%-- ~~ --%>

8) HTML 주석
<!-- ~~ -->
-------------------------------------------------------------------------------------
서버 루트와 웹애플리케이션 루트

1) 다른 경우
http://localhost:8888/myapp/board/list
/myapp → 서버 루트+경로
/board/list → 웹 애플리케이션 루트(=컨텍스트 루트)+경로

2) 같은 경우
http://localhost:8888/board/list
/ → 서버 루트 이면서 웹 애플리케이션 루트
board/list → 리소스 경로(자원)
-------------------------------------------------------------------------------------
<%@ include %> vs <jsp:include ~~ />

1) <%@ include %>
a.jsp  |  x.txt  |  y.txt
a.jsp{
  x.txt 삽입
  y.txt 삽입
}
→ 생성 → a.java
→ 파일을 삽입해서 하나의 자바 파일을 생성

2) <jsp:include ~~ />
a.jsp  |  x.jsp  |  y.jsp
a.java | x.java | y.java  →  생성
→ a.java가 x.java/y.java를 include
→ 자바 파일에서 다른 자바 파일을 include
-------------------------------------------------------------------------------------
JspContext
<board> <board>
→ 개발자가 추가로 정의한 태그
→ 이 태그를 이용해서 자바 소스 코드를 만들어야 한다 → Tag Handler
→ JSP 실행할 때 유지

JSP 태그 개발자
→ 태그 정의
→ 태그의 작업을 수행하는 클래스

JSP와 태그 핸들러
JSP  ◇------------>  JspContext
Tag Handler  <사용>  JspContext
→ JSP와 태그핸들러 사이에 값을 공유하기 위한 저장소
→ JspContext <------- PageContext
<c:forEach items="aaa, bbb, ccc" var="n">
  <li><%=pageContext.getAttribue("n")%></li>
</c:forEach>
→ <c:forEach> 태그 핸들러가 "aaa, bbb, ccc" 문자열에서 한 개의 문자열 추출해서 보관소에 "n" 이름으로 저장
→ JspContext{"n"="aaa"}
→ getAttribue("n") 호출, 보관소에 저장된 값 꺼내기
-------------------------------------------------------------------------------------
JSP 빌트인 객체
- JSP를 가지고 서블릿 클래스를 만들 때 _jspService() 메서드에서 기본으로 준비하는 객체
- JSP 엔진은 반드시 다음과 같은 이름으로 레퍼런스를 선언해야 한다.
  즉 서블릿 컨테이너(ex: 톰캣, jetty, resin 등)에 상관없이 이름이 같다.

1) request - HttpServletRequest => _jspService() 파라미터이다.
2) response - HttpServletResponse => _jspService() 파라미터이다.
3) pageContext - PageContext => _jspService()의 로컬 변수이다.
4) session - HttpSession => _jspService()의 로컬 변수이다.
5) application - ServletContext => _jspService()의 로컬 변수이다.
6) config - ServletConfig => _jspService()의 로컬 변수이다.
7) out - JspWriter => _jspService()의 로컬 변수이다.
8) page - 서블릿 객체를 가리킨다. 즉 this 이다. => _jspService()의 로컬 변수이다.
9) exception - Throwable => _jspService()의 로컬 변수이다.
   - 이 변수는 JSP 페이지가 <%@ page isErrorPage="true"%>로 설정되었을 때만 존재한다.
   - 주로 오류가 발생되었을 때 실행되는 JSP 페이지인 경우 위 설정을 붙인다. 
-------------------------------------------------------------------------------------
JSP action tag
<jsp:~ ~~ %>
<jsp:useBean scope="보관소명" id="객체명" class="클래스명"/>   
<jsp:useBean id="b3" class="com.eomcs.web.vo.Board" scope="page"/>
                               └> type은 객체가 없으면 에러, class는 객체가 없으면 인스턴스 생성(type, class 같이 사용 가능)
<jsp:setProperty name="b3" property="no" value="100"/>
<jsp:setProperty name="b3" property="contents" value="내용입니다."/>
<jsp:setProperty name="b3" property="viewCount" value="88"/>
<%=b3%> => out.print(b3);<br> 

java.util.List list = (java.util.List) pageContext.getAttribute("list");  <=== 제너럴 타입 설정 불가능
  if (list == null) {
    list = new java.util.List();  <=== 이 부분 때문에 인터페이스를 지정할 수 없다.
    pageContext.setAttribute("list", list);
  }

throw new Throwable("list라는 이름의 빈이 없습니다.");

<jsp:include page="ex19_header.jsp"/>
RequestDispatcher rd = request.getRequestDispatcher("/ex19_header.jsp");
rd.include(request, response):
-------------------------------------------------------------------------------------



2024.03.05(화)
-------------------------------------------------------------------------------------
EL(Expression Language)

- 콤마(.)와 대괄호([]) 등을 사용하여 객체의 프로퍼티나,
  리스트, 셋, 맵 객체의 값을 쉽게 꺼내고 설정하게 도와주는 문법이다.
  특히 값을 꺼낼 때는 OGNL 표기법을 사용한다.
  
- OGNL(Object Graph Navigation Language)?
  객체의 프로퍼티 값을 가리킬 때 사용하는 문법이다.
  파일의 경로처럼 객체에 포함된 객체를 탐색하여 값을 쉽게 조회할 수 있다.
  
- 문법
    ${ 객체명.프로퍼티명.프로퍼티명.프로퍼티명 }
    ${ 객체명["프로퍼티명"]["프로퍼티명"]["프로퍼티명"] }

- 보관소의 이름을 지정하지 않으면 다음 순서로 값을 찾는다.
    pageScope ==> requestScope ==> sessionScope ==> applicationScope
    PageContext	ServletRequest	HttpSession	ServletContext
-------------------------------------------------------------------------------------
값 꺼내기

리터럴
문자열: ${"홍길동"}<br>
문자열: ${'홍길동'}<br>
정수: ${100}<br>
부동소수점: ${3.14}<br>
논리값: ${true}<br>
null: ${null}<br>

배열
pageContext.setAttribute("names", new String[]{"홍길동","임꺽정","유관순"});
${names[0]}<br>
${names[1]}<br>
${names[2]}<br>
${names[3]}<br>

일반 객체
Member member = new Member();
member.setNo(100);
member.setName("홍길동");
member.setEmail("hong@test.com");
member.setTel("1111-2222");
pageContext.setAttribute("member", member);

${member.getNo()}<br>
${member.no}<br>
${member["no"]}<br>
${member['no']}<br>

조건 연산자
name 값이 없는가? ${empty name}<br>
name2 값이 없는가? ${empty name2}<br>

<h2>조건 연산자 - 조건 ? 식1 : 식2 </h2>
name == "홍길동" : ${name == "홍길동" ? "맞다!" : "아니다!"}<br>	

→ EL은 로컬 변수를 사용할 수 없다
→ EL은 오직 보관소에 저장된 값을 꺼낼 수 있다
-------------------------------------------------------------------------------------
JSTL(JSP Standard Tag Library)
  - JSP 확장 태그이다.
  - 기본으로 제공하지 않는다.
  - JSTL API를 구현한 외부 라이브러리를 가져와서 사용해야 한다.
- JSTL 라이브러리 가져오기
  - mvnrepository.com 에서 JSTL 검색하여 라이브러리를 정보를 알아낸다.
  - build.gradle 파일의 dependencies {} 블록에 추가한다.
  - 'gradle eclipse' 실행하여 이클립스 설정 파일을 갱신한다.
  - 이클립스 프로젝트를 리프래시 한다.
- JSTL 라이브러리 모듈
  - Core(c) : http://java.sun.com/jsp/jstl/core
  - XML(x) : http://java.sun.com/jsp/jstl/xml
  - I18N(fmt) : http://java.sun.com/jsp/jstl/fmt
  - Database(sql) : http://java.sun.com/jsp/jstl/sql
  - Functions(fn) : http://java.sun.com/jsp/jstl/functions
- JSP 페이지에서 JSTL 라이브러리의 모듈 사용하기
  - JSTL 모듈의 네임스페이스를 가져온다.
      <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
  - JSTL 태그 사용
      <접두어명:태그명 속성="값" 속성="값"/> 
-------------------------------------------------------------------------------------
I18N(Internationalization 의 약자)
=> 프로그램을 짤 때 여러 언어를 고려해서 코딩하는 것을 말한다.
=> 특히 화면에서 버튼에 제목이나 라벨을 출력할 때 특정 언어로 고정된 값을 출력하지 않고,
   외부 파일(예: label_ko_KR.properties)에서 읽어 온 값을 출력하도록 프로그래밍 하는 것.
   
L10N(Localization 의 약자)
=> 특정 언어에 대해 라벨 텍스트를 담은 프로퍼티 파일(예: label_ko_KR.properties)을 
   작성하는 것을 말한다.
-------------------------------------------------------------------------------------
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<%="<h2>오호라!!!</h2>"%>
${"<h2>오호라!!!</h2>"}
------------
<c:out value="<h2>오호라!!!<h2>"/>
<c:out value="출력될 값" default="기본 값"/>
<c:out value="출력될 값">기본값<c:out>
------------
<c:set scope="request" var="name1" value="홍길동2"/>
------------
<jsp:useBean id="m1" class="com.eomcs.web.vo.Member"/>
<jsp:setProperty name="m1" property="no" value="100"/>
<c:set target="${pageScope.m1}" property="email" value="hong@test.com"/>
------------
<c:remove var="name" scope="page"/>
------------
<c:if test="${not empty name}">
    <p>${name}님 환영합니다!
</c:if>
<c:if test="${gender == 'woman'}" var="r1" scope="page"/>
${r1}<br>
${pageScope.r1 ? "여성" : "남성"}<br>
------------
<c:choose>
    <c:when test="${age < 19}">
        <p>미성년입니다.</p>
    </c:when>
    <c:when test="${age >= 19 and age < 65}">
        <p>성년입니다.</p>
    </c:when>
    <c:otherwise>
        <p>노인입니다.</p>
    </c:otherwise>
</c:choose>
------------
<c:forEach items="${names}" var="n">
    <li>${n}</li>
</c:forEach>
-----------
<%-- Map 객체에 대해 반복문을 돌리면 var로 저장되는 것은 
     key와 value를 갖고 있는 Entry 객체이다. --%>
<c:forEach items="${names3}" var="n">
    <li>${n.getKey()} : ${n.getValue()} => ${n.key} : ${n.value}</li>   
</c:forEach>
-----------
<c:forTokens items="${names1}" var="n" delims=",">
    <li>${n}</li>
</c:forTokens>
-----------
<c:url value="https://search.naver.com/search.naver" var="naverUrl">
    <c:param name="where" value="nexearch"/>
    <c:param name="sm" value="top_hty"/>
    <c:param name="fbm" value="1"/>
    <c:param name="ie" value="utf8"/>
    <c:param name="query" value="홍길동"/>
</c:url>
-----------
<h2>HTTP 요청하기</h2>
<c:url value="ex10_sub.jsp" var="url1">
    <c:param name="name" value="홍길동"/>
    <c:param name="age" value="20"/>
    <c:param name="gender" value="woman"/>
</c:url>
<c:import url="${url1}" var="contents"/>
<textarea cols="120" rows="20">${pageScope.contents}</textarea>
-----------
<c:redirect url="http://www.naver.com"/>
response.sendRedirect("http://www.naver.com");
-------------------------------------------------------------------------------------
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
-----------
<fmt:parseDate value="2024-3-5" pattern="yyyy-MM-dd" var="d1"/>
<fmt:parseDate value="3/5/2024" pattern="MM/dd/yyyy" var="d2"/>
-----------
pageContext.setAttribute("today", new Date());
<fmt:formatDate value="${pageScope.today}" pattern="yyyy-MM-dd"/><br>
<fmt:formatDate value="${pageScope.today}" pattern="MM/dd/yyyy"/><br>
<fmt:formatDate value="${pageScope.today}" pattern="yyyy-MM-dd hh:mm:ss"/><br>

<fmt:formatDate value="${pageScope.today}" pattern="yyyy-MM-dd" var="str1"/>
<p>오늘 날짜는 '${pageScope.str1}'입니다.</p>  
-------------------------------------------------------------------------------------
과제 69. 인터페이스 대신 애노테이션으로 request handler 지정하기
- 인터페이스 대신 애노테이션을 사용하여 요청 핸들러를 지정하는 방법
- 특정 애노테이션이 붙은 메서드를 찾아 호출하는 방법

					<<interface>>PageControoler     <--------┐
<요청 / 응답> <<Front Controller>> DispatcherServler <execute()> <<Page Controller>> BoardListController
                                                        └ JSP

<요청 / 응답> <<Front Controller>> DispatcherServler <@RequestMapping 메소드> <<Page Controller>> BoardListController[@RequestMapping]
                                                        └ JSP
→ 인터페이스를 구현할 필요가 없다
→ 메소드 이름을 
-------------------------------------------------------------------------------------
과제 70. CRUD 요청을 한 개의 컨트롤러의 합치기
- 한 개의 페이지 컨트롤러에 CRUD 요청 핸들러를 합치는 방법
- 애노테이션을 이용하여 요청 URL에 따라 핸들러를 구분하는 방법

BoardListController
BoardViewController
BoardAddController		→	BoardController
BoardUpdateController
BoardDeleteController
BoardFileDeleteController
→ CRUD 기능을 한 개의 클래스에 합쳐서 유지보수를 쉽게 만든다
→ 관련된 기능이 한 클래스에 모여있으면 다루기 쉽다
-------------------------------------------------------------------------------------
과제 71. 파라미터 자동인식
void list(HttpServletRequest request, HttpServletResponse response){
~~~
~~~
}
- 요청 핸들러에 선언된 파라미터에 따라 값을 전달하는 방법
- 파라미터 정보를 알아내서 그에 맞는 값을 준비한 후 호출!
-------------------------------------------------------------------------------------



2024.03.06(수)
-------------------------------------------------------------------------------------
셋터 메소드 이름에서 프로퍼티 이름 추출하기
setFirstName(){} → firstName
-------------------------------------------------------------------------------------
과제 72. 페이지 컨트롤러 자동 생성 하기
DispatcherServlet → @Component → .class
→ @Component가 붙은 클래스를 찾아 객체를 자동 생성
- 애노테이션과 리플렉션 API를 사용하여 페이지 컨트롤러를 자동 생성하는 방법
-------------------------------------------------------------------------------------



2024.03.07(목)
-------------------------------------------------------------------------------------
ContextLoaderListener ◇------> Map(공유하는 객체 보관소) → DAO, service, DB 커넥션 등을 보관
			     ↑
	┌-------------------------┘공유
DispatcherServlet ◇-------> Map(웹 관련 객체 보관소) → 페이지 컨트롤러 등을 보관
-------------------------------------------------------------------------------------
과제 73. IoC 컨테이너 만들기
ContextLoaderListener ◇--------> <<IoC 컨테이너>> ApplicationContext(DAO, service, Tx 매니저, DB 커넥션 등) <┐
<<Front Controller>>DispatcherServlet ◇---------> <<IoC 컨테이너>> ApplicationContext(페이지 컨트롤러 등)    ┘참조

- IoC 컨테이너의 구동 원리 이해와 구현하기
- 페이지 컨트롤러 및 의존 객체를 IoC 컨테이너로 관리하기
-------------------------------------------------------------------------------------
Ioc 컨테이너(Inversion Of Control)
1) Dependency Injection(의존성 주입)
→ DI 컨테이너 = IoC컨테이너 = Bean(자바 객체) 컨테이너

2) Event Handl
-------------------------------------------------------------------------------------
과제 74. Spring IoC 컨테이너를 도입하기
- Spring IoC 컨테이너를 이용하여 객체를 자동 생성하는 방법
- 의존 객체를 자동으로 주입하는 방법
- Spring IoC 컨테이너에 들어 있는 객체를 꺼내 사용하는 방법
-------------------------------------------------------------------------------------
Spring IoC Container
ApplicationContext → .xml
	           └> JAVA
→ IoC 컨테이너 설정
-------------------------------------------------------------------------------------
package 와 namespace
package → 자바 클래스가 소속된 그룹
namespace → 자바 외 다른 프로그래밍 언어에서는 namespace라고 부른다 (c#, c++, xml)

[자바]
System.out.println("hello");
→ java.lang 패키지 소속 클래스는 패키지명을 작성하지 않아도 된다

java.util.ArraList arr = null;
→ java.lang 외의 패키지는 이름을 명시해야한다

[xml]
<beans
  xmlns="http://www.springframework.org/schema/beans"
  xmlns="http://www.springframework.org/schema/context"
  xmlns:context="http://~~~~~~~~~~~~~~~~~~~~~~~~"></beans>
xmlns → 기본 namespace				        └> 기본 namespace에 소속된 태그는 바로 사용
xmlns:context → 그 외에는 별명을 정의해야한다
<context:component-scan ~~~~/>
→ namespace 별명을 붙여야한다
-------------------------------------------------------------------------------------



2024.03.08(금)
-------------------------------------------------------------------------------------
74. Spring IoC 컨테이너 도입하기
- Spring IoC 컨테이너를 이용하여 객체를 자동 생성하는 방법
- 의존 객체를 자동으로 주입하는 방법
- Spring IoC 컨테이너에 들어 있는 객체를 꺼내 사용하는 방법
-------------------------------------------------------------------------------------



2024.03.11(월)
-------------------------------------------------------------------------------------
Spring IoC Container
IoC → Inversion of Control (제어의 역전)
IoC Container = DI Container = Bean Container 
Dependency Injection(DI) → 의존 객체 = 사용하는 객체
Event Listener → call 당한다 = callback(cb)
-------------------------------------------------------------------------------------
ApplicationContext 인터페이스
→ IoC 컨테이너 사용법을 정의한 인터페이스
<<interface>>BeanFactory{getBean(), getAliases(), getType()}
→ 객체 생성을 수행하는 역할자의 사용법
<<interface>>HierarchicalBeanFactory{getParentBeanFactory()}
→ 빈 컨테이너 계층 구조 관리
<<interface>>ApplicationContext 
→ 객체 컨테이너
→ properties 다루기
→ 이벤트 다루기
→ i18n 메시지 다루기
→ 계측 구조 컨테이너 다루기
=> Application에서 객체를 보다 쉽게 다룰 수 있는 기능, 규칙을 정의하는 인터페이스
-------------------------------------------------------------------------------------
ApplicationContext 구현체

ClasspathXmlApplicationContext
→ 자바 classpath에 있는 xml 설정 파일을 읽을 때 사용
FileSystemXmlApplicationContext
→ 자바 classpath가 아닌 경로에 있는 xml 파일을 읽을 때 사용
AnnotationConfigApplicationContext
→ xml 파일이 아닌 자바 클래스에 애노테이션으로 지정된 설정 정보를 읽을 때 사용
AnnotationConfigWebApplicationContext
→ 서블릿 컨테이너에서 실행되는 객체를 다룰 때 사용
→ Spring Web MVC에서 사용한다
-------------------------------------------------------------------------------------
Spring IoC Container 구동원리
.xml → 생성자 분석 → 의존 객체 분석 → 파라미터 값 변환기 설정 → setter 호출  → ... → 객체 생성
.class → 생성자 분석 → 의존 객체 분석 → 파라미터 값 변환기 설정 → setter 호출  → ... → 객체 생성
	→ @Component 애노테이션 처리
		       → @Autowired 애노테이션 처리
				       → 기타 애노테이션 처리
							→ ... => 확장작업(확장 작업을 수행할 책체가 필요한다)
ConfigurationClassPathProcessor
AutowiredAnnotationBeanPostProcessor
EventListenerMethodProcessor
DefaultEventListenerFactory

→ 해당 작업을 처리할 객체가 존재한다면 Spring Ioc 컨테이너는 그 객체를 사용해 작업을 수행한다
-------------------------------------------------------------------------------------
xml로 객체 생성하기
<bean id="c1" class="com.eomcs.spring.ioc.ex04.Car">
        <property name="model" value="티코3"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
</bean>

<bean id="c1" class="com.eomcs.spring.ioc.ex04.Car">
        <property name="model" value="티코A"/>
        <property name="maker" value="비트자동차"/>
        <property name="cc" value="890"/>
        <property name="engine">
          <bean class="com.eomcs.spring.ioc.ex04.Engine">
            <property name="maker" value="비트자동차"/>
            <property name="valve" value="16"/>
            <property name="cylinder" value="8"/>
          </bean>
        </property>
</bean>

<bean id="c3" class="com.eomcs.spring.ioc.ex03.Car">
        <constructor-arg index="0" value="티코"/>
        <constructor-arg index="1" value="890"/>
</bean>

리스트, 배열 같은 태그 이용
<bean id="c1" class="com.eomcs.spring.ioc.ex05.a.Car">
        <!-- 배열 프로퍼티 값 설정하기 -->
        <property name="tires">
            <array>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="비트타이어" p:width="100"/>
            </array>
        </property>
</bean>

<bean id="c2" class="com.eomcs.spring.ioc.ex05.a.Car">
        <!-- 배열 프로퍼티 값 설정하기 -->
        <property name="tires">
            <list> <!-- array 태그 대신에 list 태그를 사용해도 된다. -->
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="금호타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire" 
                      p:maker="한국타이어" p:width="180"/>
                <bean class="com.eomcs.spring.ioc.ex05.a.Tire">
                  <property name="maker" value="비트타이어"/>
                  <property name="width" value="100"/>
                </bean> 
            </list>
        </property>
</bean>

Map 객체
<bean id="c1" class="com.eomcs.spring.ioc.ex05.c.Car">
        <!-- Map 프로퍼티 값 설정하기 : 배열과 똑같다.  -->
        <property name="options">
            <map>
                <entry>
                    <key><value>sunroof</value></key> 
                    <value>true</value>
                </entry>
                <entry key="auto" value="true"/>
                <entry key="spareTire">
                    <!-- 객체를 바로 만들어 넣고 싶다면 bean 태그를 사용하라! -->
                    <bean class="com.eomcs.spring.ioc.ex05.c.Tire" p:maker="비트타이"/>
                </entry>
                <entry key="engine" value-ref="e1"/>
            </map>
        </property>
</bean>

Properties 객체 설정
<bean id="c1" class="com.eomcs.spring.ioc.ex05.d.Car">
        <!-- Properties 프로퍼티 값 설정하기  -->
        <property name="options">
            <props>
                <prop key="sunroof">true</prop>
                <prop key="auto">true</prop>
                <prop key="color">black</prop>
                <prop key="blackbox">false</prop>
            </props>
        </property>
</bean>

        <!-- 의존 객체 주입(Dependency Injection; DI) -->
        <property name="engine" ref="e1"/>
-------------------------------------------------------------------------------------
메소드 호출

스태틱 메소드 호출
<bean id="d1" class="java.sql.Date"
          factory-method="valueOf">
        <constructor-arg value="2024-03-11"/>
</bean>

<bean id="c1" 
          class="com.eomcs.spring.ioc.ex06.a.CarFactory"
          factory-method="create">
        <!-- create() 메서드를 호출할 때 넘겨줄 파라미터 값 -->
        <constructor-arg value="티코"/>
</bean>

인스턴스 메소드 호출
<!-- 팩토리 메서드를 통해 객체를 만들기 : 인스턴스 메서드 호출 -->
    <bean id="carFactory" class="com.eomcs.spring.ioc.ex06.c.CarFactory"/>

    <bean id="c1" 
          factory-bean="carFactory"
          factory-method="create">
        <constructor-arg value="SM5"/>
    </bean>

<!-- 팩토리 메서드를 통해 객체를 만들기 : 스프링 규칙에 따라 만들기 -->
    <bean id="c1" class="com.eomcs.spring.ioc.ex06.d.CarFactoryBean">
        <property name="model" value="소나타"/>
    </bean>
// FactoryBean의 구현체 여부에 따라 "c1" 이라는 이름으로 저장할 객체가 다르다.

public class CarFactoryBean implements FactoryBean<Car> {
  public Car getObject() throws Exception {}
  public Class<?> getObjectType() {}
}
-------------------------------------------------------------------------------------
프로퍼티 에디터
→ String 값을 다른 타입의 값으로 변환하는 객체
    // 스프링 빌트인 프로퍼티 에디터(변환기)
    // => primitive 타입 변환기는 기본으로 내장하고 있다.
    // => 따라서 String을
    // byte, short, int, long, float, double, boolean, char로 바꿀 수 있다.
    // => 그 외의 타입은 개발자가 프로퍼티 에디터를 만들어 등록해야 한다.
-------------------------------------------------------------------------------------
★ 새로운 에디터 만들기 - PropertyEditorSupport 상속 받기
public class CustomDateEditor extends PropertyEditorSupport {
  // 이 메서드는 스프링 IoC 컨테이너가 String 타입의 프로퍼티 값을
  // 다른 타입의 값으로 바꿀 때 호출하는 메서드이다.
  @Override
  public void setAsText(String text) throws IllegalArgumentException {
    System.out.println("CustomDateEditor.setAsText()");
    // 파라미터로 넘어온 String 타입의 프로퍼티 값을
    // 원하는 타입(java.sql.Date)의 값으로 바꿔 내부에 저장한다.
    // => 그러면 스프링 IoC 컨테이너를 이 값을 꺼내서 객체에 주입할 것이다.
    this.setValue(Date.valueOf(text));
  }
}

<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="customEditors"> 
		<map>
	             <entry key="java.sql.Date" 
	                   value="com.eomcs.spring.ioc.ex07.c.CustomDateEditor"/>
	             </map>	
	</property>
</bean>
-------------------------------------------------------------------------------------



2024.03.12(화)
-------------------------------------------------------------------------------------
애노테이션을 처리할 도우미 객체를 등록한다
<context:annotation-config/>
→ 위의 태그는 애노테이션을 처리할 객체들을 자동 생성
- ConfigurationClassPostProcessor
- AutowiredAnnotationBeanPostProcessor
- EventListenerMethodProcessor
- DefaultEventListenerFactory
-------------------------------------------------------------------------------------
BeanPostProcessor 인터페이스:
=> 스프링 IoC 컨테이너는 객체 중에 이 인터페이스를 구현한 객체가 있다면,
     설정 파일에 적혀있는 객체를 생성한 후에
     이 구현체의 postProcess....() 메서드를 호출한다. 
=> 즉 빈 생성 이후의 마무리 작업을 진행시킨다.
=> 그래서 이 인터페이스의 이름이 
     BeanPostProcessor(객체 생성 후 처리기) 인 것이다.
-------------------------------------------------------------------------------------
  // @Autowired의 required 값은 기본이 true이다.
  // => 즉 의존객체 주입이 필수사항이다.
  // 해당하는 의존 객체가 없으면 예외가 발생한다.
  // => 선택사항으로 바꾸고 싶으면 false로 설정하라!
  // => required를 false로 설정하면 해당 객체가 없더라도 오류가 발생하지 않는다.
  // @Autowired
  @Autowired(required = false)

  // @Qualifier("e2")
  // 의존 객체가 여러 개 있을 경우, 주입할 의존 객체의 이름을 지정하라!
  // 주의!
  // @Qualifier 애노테이션을 처리할 BeanPostProcessor를 등록해야 한다.
-------------------------------------------------------------------------------------
// @Component
// => 스프링 IoC 컨테이너는 이 애노테이션이 붙은 클래스에 대해 객체를 자동 생성한다.
// 문법:
//      @Component(value="객체이름")
//      @Component("객체이름")
// 만약 다음과 같이 객체의 이름을 생략하면
// 클래스 이름을 객체 이름으로 사용한다.
//      예) bitcamp.java106.step09.Car => "car"
// 즉 클래스 이름에서 첫 알파벳을 소문자로 한 이름을
// 객체 이름으로 사용한다.
-------------------------------------------------------------------------------------
<!-- component-scan 태그는 지정된 패키지에서 
@Component, @Service, @Repository, @Controller 애노테이션이 붙은 클래스를 찾아서 
객체를 자동 생성하도록 명령을 내리는 태그이다.
=> base-package 속성 
     어느 패키지의 있는 클래스를 찾아서 등록할 것인지 지정하는 속성이다.
=> @Component : 일반 클래스에 대해 붙인다.
=> @Repository : DAO 역할을 수행하는 클래스에 대해 붙인다.
=> @Service : 비즈니스 로직을 수행하는 클래스에 대해 붙인다.
=> @Controller : MVC 구조에서 컨트롤러 역할을 하는 클래스에 대해 붙인다.
=> @RestController : MVC 구조에서 REST API 컨트롤러 역할을 하는 클래스에 대해 붙인다.
이렇게 역할에 따라 애노테이션으로 클래스를 분류해두면 나중에 통제하기가 편하다. 

<context:component-scan base-package="com.eomcs.spring.ioc.ex09"/>
-->

    <!-- component-scan 태그를 추가하면 
         내부적으로 annotation-config 태그가 자동으로 추가된다. 
         따라서 다음과 같이 생략해도 된다. -->

 <!-- 다음 패키지의 클래스 중에서 @Component,@Service,@Controller,@Repository
             애노테이션이 붙은 것은 객체를 생성한다. -->
        <context:include-filter type="regex" 
            expression="com.eomcs.spring.ioc.ex09.p2.Service2"/>
        
        <!-- 특정 패키지의 특정 클래스를 객체 생성 대상에서 제외하기  -->
        <context:exclude-filter type="regex" 
            expression="com.eomcs.spring.ioc.ex09.p2.Service1"/>
        
        <!-- 특정 애노테이션이 붙은 클래스는 객체 생성에서 제외시킨다. -->
        <context:exclude-filter type="annotation" 
            expression="org.springframework.stereotype.Controller"/>
            
        <!-- 특정 패키지만 제외하기 -->
        <context:exclude-filter type="regex" 
            expression="com.eomcs.spring.ioc.ex09.p4.*"/>
            
        <!-- 특정 패키지에서 지정된 패턴의 이름을 가진 클래스를 제외하기-->
        <context:exclude-filter type="regex" 
            expression="com.eomcs.spring.ioc.ex09.p5.*Truck"/> 
-------------------------------------------------------------------------------------
    // 패키지명을 지정하면
    // 해당 패키지의 모든 클래스를 찾아
    // @Component, @Service, @Controller, @Repository
    // 애노테이션이 붙은 클래스에 대해 객체를 자동 생성한다.
    // 또한,
    // @Configuration 애노테이션이 붙은 클래스를 찾아 객체를 생성한다.
    // 그리고 그 클래스에 @Bean 애노테이션이 붙은 메서드를 호출하여
    // 그 리턴 값을 저장한다.
    //
    ApplicationContext iocContainer = new AnnotationConfigApplicationContext(
        "com.eomcs.spring.ioc.ex10.b");
-------------------------------------------------------------------------------------
프로퍼티 값 받기

@PropertySource({
  "classpath:com/eomcs/spring/ioc/ex10/c/jdbc.properties",
  "classpath:com/eomcs/spring/ioc/ex10/c/jdbc2.properties"
})
@Autowired
  Environment env;

@Value("${jdbc.url}")
  String jdbcUrl;

@Value("${jdbc.username}") String username
-------------------------------------------------------------------------------------
AppConfig에서 컴포넌트 스캔하기

@ComponentScan(
    basePackages = "com.eomcs.spring.ioc.ex11",
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = "com.eomcs.spring.ioc.ex11.p2.*"
            ),
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            value = org.springframework.stereotype.Controller.class
            )
    })
-------------------------------------------------------------------------------------
use-case 모델링
→ 시스템의 사용기능을 명세화

1) Actor 식별 
→ 시스템을 사용하는 사람, 프로세스, 시스템 식별

2) use-case 식별
→ Actor가 시스템을 통해 달성하고자 하는 업무 목표 식별

3) use-case 명세서
→ Actor가 use-case를 실행하는 과정을 기술
→ 전제조건
→ 성공 시나리오
→ 대안 시나리오
→ 예외 시나리오
→ 종료 조건
→ 우리는 제외
-------------------------------------------------------------------------------------
Actor 식별
사람, 프로세스, 시스템-졸라맨, 시스템-사각형

Primary Actor(주 액터)
→ 시스템을 사용하는 사람, 프로세스, 시스템
예) 
은행원 → 은행 시스템
고객 → 은행 시스템
타이머(프로세스) → 은행 시스템
ATM(시스템) → 은행 시스템

supplementary Actor(=secondary)(보조 액터)
→ 시스템이 의존하는 외부 시스템
예) 
은행 시스템 → 신용 평가 시스템
은행 시스템 → 단문 메시지 전송 시스템
은행 시스템 → 우편 번호 검색 시스템
-------------------------------------------------------------------------------------
액터의 상속 관계
→ 역할에 따라 상속관계를 정의

호스트 --▷ 회원 --▷ 사용자
관리자 --▷ 사용자
-------------------------------------------------------------------------------------
use-case 식별
→ 액터가 달성하고자 하는 업무 목표 식별
→ 액터가 시스템을 통해서 업무를 처리

액터 → 업무 목표(use-case)

식별 가이드 라인
→ 개발 관리 하기에 적절한 크기로 식별하는 방법
  → 2주~4주 기간동안 개발할 크기
1) 한 사람이 한번에 수행하는 작업
    → 주문-결제-배송정보등록
-------------------------------------------------------------------------------------



2024.03.13(수)
-------------------------------------------------------------------------------------
use-case 식별
→ 액터가 달성하고자 하는 업무 목표 식별
→ 액터가 시스템을 통해서 업무를 처리

액터 → 업무 목표(use-case)

식별 가이드 라인
→ 개발 관리 하기에 적절한 크기로 식별하는 방법
  → 2주~4주 기간동안 개발할 크기

업무를 자르는 기준(EBP) 
1) 한 사람이 한번에 수행하는 작업
    → 주문-결제-배송정보등록
    → 한 장소에서 한 번 수행
    → 업무 단위를 자르는 기준
2) 시스템을 사용해서 처리하는 업무
3) 카운트가 가능한 업무
    → 시작과 끝이 명확

use-case 예)
학생 --▷ 과정조회, 과정신청, 과정신청취소, 과정신청조회 
	 과정조회, 과정등록, 과정변경, 과정삭제 ◁-- 매니저

식별 가이드 라인 2번째
1) CRUD에 해당하는 경우 한 개의 use-case로 합치는 것이 관리하기 편하다
    → 합친 것이 2주~4주 개발 단위일 경우
→ 과정등록, 과정조회, 과정변경, 과정삭제   ==>   과정관리
2) 서로 관련된 use-case일 경우 한 개의 use-case로 합친다
로그인, 로그아웃 --▷ 사용자인증
3) 여러 use-case에 중복되는 시나리오가 있다면 별도의 use-case로 분리한다
    → 게시글 등록, 개시글 변경, 게시글 삭제 → include → 로그인
						→ 원래는 업무가 아니기 때문에 use-case가 될 수 없지만
						→ 여러 use-case에 포함되는 공통 시나리오(작업)이기 때문에 관리 및 구현의 펀이를 위해 별도의 use-case로 추출
    → 회원가입, 주문하기 ← extend ← 주소검색
-------------------------------------------------------------------------------------
use-case의 include와 extend(포함관계와 확장관계)
포함
use-case(base) → use-case(inclusion) → 반드시 실행해야 한다
use-case1 → include → use-case2
예) 
회원가입 → include → 주소검색
→ 회원가입 시 주소입력이 필수라는 의미!

확장
use-case1(base) → use-case2(extextion) → 선택, 조건에 맞으면 실행
	         → extent point
use-case1 ← extend → use-case2
예)
회원가입(주소검색 클릭) ← extend ← 주소검색
→ 주소검색을 클릭할 때 실행된다
→ 주소검색 클릭 = 확장점(extend point)
-------------------------------------------------------------------------------------
유스 케이스 목록 예시

1) 액터
- 사용자 - 로그인 하지 않은 사용자
    - 회원 - 회원 가입한 사용자
        - 학생 - 개인 출석 및 과제를 관리하는 회원
        - 매니저 - 전체 과정을 관리하는 회원
        - 강사 - 개인 강의를 관리하는 회원
        - 관리자 - 전체 시스템을 관리하는 회원

2) 유스케이스
- 사용자 - 과정조회, 회원가입(학생, 강사, 매니저), 회원탈퇴(학생, 강사, 매니저)
     - 회원가입 - 주소검색시스템
- 회원 - 로그인, 로그아웃, 과정조회, 게시글관리(전체게시글조회, 개인게시글관리)
     - 로그인 - 페이스북, 네이버, 구글
- 매니저 - 과정관리, 출석관리, 게시글관리(전체게시글)
- 강사 - 과정조회, 과제관리(전체), 출석조회
- 학생 - 과정조회, 과정신청, 과정신청취소, 과정신청조회, 출석조회, 과제관리(개인)
- 관리자 - 회원관리(전체회원)
-------------------------------------------------------------------------------------



2024.03.14(목)
-------------------------------------------------------------------------------------
서블릿 Spring IoC 컨테이너 준비
  <servlet>
    <servlet-name>admin</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>app-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>admin</servlet-name>
    <url-pattern>/admin/*</url-pattern>
  </servlet-mapping>


글로벌 Spring IoC 컨테이너 준비
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>  
  
  <!-- ContextLoaderListener가 사용할 IoC 컨테이너 설정 파일 정보 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/config/app-context.xml</param-value>
  </context-param>
-------------------------------------------------------------------------------------
xml config ----> java config
<servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextClass</param-name>
      <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </init-param>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>bitcamp.config.AppConfig</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>app</servlet-name>
    <url-pattern>/app/*</url-pattern>
  </servlet-mapping>

Appconfig.java 설정추가
@ComponentScan(
    value = "bitcamp.web",
    excludeFilters = @Filter(type = FilterType.REGEX, pattern = "bitcamp.web.admin.*")
)
-------------------------------------------------------------------------------------
서블릿 배치 방법

1) 선언적인 방법 = Declarative
→ XML
  <servlet>
    <servlet-name>admin</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>app-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>admin</servlet-name>
    <url-pattern>/admin/*</url-pattern>
  </servlet-mapping>

→ 애노테이션
@WebServlet("")

2) 프로그램적인 방법 = Programmatic
    ServletContext sc = sce.getServletContext();

    AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();
    appContext.register(AppConfig.class);

    Dynamic 서블릿설정 = sc.addServlet("app", new DispatcherServlet(appContext));
    서블릿설정.addMapping("/app/*");
    서블릿설정.setLoadOnStartup(1);
-------------------------------------------------------------------------------------
WebApplicationInitializer

<<interface>>WebApplicationInitializer
onStartup()

<<abstract>>AbstractContextLoaderInitializer
→ + ContextLoaderListener 생성 및 등록(=ServletContextListener)
createRootApplicationContext() → ContextLoaderListener가 사용할 IoC 컨테이너 리턴
onStartup()

<<abstract>>AbstractDispatcherServletInitializer
→ + DispatcherServelt 생성 및 등록
createServletApplicationContext() → DispatcherServlet이 사용할 IoC 컨테이너 리턴

<<abstract>>AbstractAnnotationConfigDispatcherServletInitializer
→ + DisparcherServlet이 사용할 IoC 컨테이너 생성 및 등록
getRootConfigClasses() → ContextLoaderListener의 IoC 컨테이너 설정
getServletConfigClasses() → DispatcherServlet의 IoC 컨테이너 설정
-------------------------------------------------------------------------------------



2024.03.15(금)
-------------------------------------------------------------------------------------
클라이언트에게 메시지 보내기
@Controller
@RequestMapping("/c01_1")
public class Controller01_1 {

  @RequestMapping // 이 애노테이션을 붙여서 요청이 들어왔을 때 호출될 메서드임을 표시한다.
  @ResponseBody → 이 애노테이션이 없으면 리턴값을 JSP(페이지 url)로 인식
  public String handler() {
    return "c01_1 -> handler()";
  }
}
// URL 한 개 당 한 개의 핸들러만 연결할 수 있다.
// 같은 URL에 대해 다른 메서드를 또 정의하면 실행 오류가 발생한다.
-------------------------------------------------------------------------------------
요청 핸들러 매핑
// 핸들러에서 URL을 지정한다.
// 한 개의 request handler에 여러 개의 URL을 매핑할 수 있다.
@RequestMapping({"/c01_2/h5", "/c01_2/h6", "/c01_2/h7"})
@ResponseBody
public String handler5() {
    return "/c01_2/h5,h6,h7";
}
→ @RequestMapping(value={"/c01_2/h1"}) 정석!
→ value 대신 path 가능

다른 방법
@Controller
@RequestMapping("/c01_3") // 핸들러에 적용될 기본 URL을 지정한다.
public class Controller01_3 {
  @RequestMapping("h1") // 기본 URL에 뒤에 붙는 상세 URL. 예) /c01_3/h1 → / 생략 가능
  @ResponseBody
  public String handler() {
    return "h1";
  }
}
-------------------------------------------------------------------------------------
★ GET/POST 요청 분리 ★

GET
@RequestMapping(method = RequestMethod.GET) // GET 요청일 때만 호출된다.
@GetMapping
@GetMapping(params = "name") // @GetMapping(params = {"name", "age"})
@RequestMapping(method = RequestMethod.GET, headers = {"name", "age}) // @GetMapping(headers={"name", "age})

POST
@RequestMapping(method = RequestMethod.POST) // POST 요청일 때만 호출된다.
@PostMapping
@PostMapping(params = "name") // @PostMapping(params = {"name", "age"})
@RequestMapping(method = RequestMethod.POST, headers = {"name", "age}) // @PostMapping(headers={"name", "age})
-------------------------------------------------------------------------------------
Accept 헤더
  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/html/app1/c03_3.html
  // => 요청 헤더 중에서 Accept의 값에 따라 구분할 때 사용한다.
  //
  // Accept 헤더?
  // => HTTP 클라이언트(웹 브라우저)에서 서버에 요청할 때
  //    받고자 하는 콘텐트의 타입을 알려준다.

@GetMapping(produces = "text/plain")
text

@GetMapping(produces = "text/html")
<html><body><h1>text</h1></body></html>

@GetMapping(produces = "application/json")
{"name":"title"}

@GetMapping(produces = "text/csv")
1,hong,20,female
-------------------------------------------------------------------------------------
Content-Type 헤더의 값에 따라 구분하기
  // Content-Type 요청 헤더
  // => HTTP 클라이언트가 보내는 데이터의 콘텐트 타입이다.
  // => 프론트 컨트롤러는 보내는 데이터의 타입에 따라 처리를 구분할 수 있다.

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/html/app1/c03_4.html
  // => 클라이언트가 POST 요청으로 데이터를 보낼 때 기본 형식은 다음과 같다.
  //      application/x-www-form-urlencoded
  // => <form> 태그에서 enctype 속성에 "mulpart/form-data"를 지정하면
  //    해당 형식으로 서버에 값을 보낸다.
  // => 자바스크립트를 사용하여 개발자가 임의의 형식으로 값을 보낼 수 있다.
  //
  // 클라이언트가 POST로 요청할 때 보내는 데이터의 유형에 따라 호출될 메서드를 구분할 때 사용한다.

  // 다음 메서드는 application/x-www-form-urlencoded 형식의 데이터를 소비한다.
  // => 즉 클라이언트의 HTTP 요청에서 Content-Type 헤더의 값이 위와 같을 때
  //    이 메서드를 호출하라는 의미다.

@PostMapping(consumes = "application/x-www-form-urlencoded")
@ResponseBody
  public String handler1(String name, int age) {
    System.out.printf("%s %d", name, age);
    return "handler1";
  }

@PostMapping(consumes = "multipart/form-data")

@PostMapping(consumes = "text/csv")

@ResponseBody
  public String handler4(@RequestBody String content) {
    System.out.println(content);
    return "handler4";
  }

@PostMapping(consumes = "application/json")
-------------------------------------------------------------------------------------
java 코드로 멀티파트 설정

클라이언트가 보내는 파일을 처리하는 도우미 객체(서블릿 IoC 컨테이너 설정 파일에 선언)
  @Bean
  MultipartResolver multipartResolver() {
    StandardServletMultipartResolver mr = new StandardServletMultipartResolver();
    return mr;
  }

서블릿 추가 설정
  @Override
  protected void customizeRegistration(Dynamic registration) {
    registration.setMultipartConfig(
        new MultipartConfigElement(
            new File("./temp").getAbsolutePath(),
            //new File(System.getProperty("java.io.tmpdir")).getAbsolutePath(),
            1024 * 1024 * 10,
            1024 * 1024 * 100,
            1024 * 1024 * 1));
  }
-------------------------------------------------------------------------------------



2024.03.18(월)
-------------------------------------------------------------------------------------
★ GET/POST 요청 분리 ★

GET
@RequestMapping(method = RequestMethod.GET) // GET 요청일 때만 호출된다.
@GetMapping
@GetMapping(params = "name") // @GetMapping(params = {"name", "age"})
@RequestMapping(method = RequestMethod.GET, headers = {"name", "age}) // @GetMapping(headers={"name", "age})

POST
@RequestMapping(method = RequestMethod.POST) // POST 요청일 때만 호출된다.
@PostMapping
@PostMapping(params = "name") // @PostMapping(params = {"name", "age"})
@RequestMapping(method = RequestMethod.POST, headers = {"name", "age}) // @PostMapping(headers={"name", "age})
-------------------------------------------------------------------------------------
프론트 컨트롤러(DispatcherServlet)로부터 받고 싶은 값이 있다면
요청 핸들러를 정의할 때 받고 싶은 타입의 파라미터를 선언하라!
그러면 프론트 컨트롤러가 메서드를 호출할 때 해당 타입의 값을 넘겨줄 것이다.

// ServletContext는 의존 객체로 주입 받아야 한다.
// 요청 핸들러에서 파라미터로 받을 수 없다.
@Autowired
ServletContext sc;

public void handler1(
// ServletContext sc,
// ServletContext는 파라미터로 받을 수 없다. 예외 발생!
// 의존 객체로 주입 받아야 한다.
ServletRequest request,
ServletResponse response,
HttpServletRequest request2,
HttpServletResponse response2,
HttpSession session,
Map<String, Object> map, // JSP에 전달할 값을 담는 임시 보관소
Model model, // Map과 같다. 둘 중 한 개만 받으면 된다.
PrintWriter out // 클라이언트에게 콘텐트를 보낼 때 사용할 출력 스트림
)
-------------------------------------------------------------------------------------
★ GET 방식에서 파라미터 값 받기

옛날방식
out.printf("name=%s\n", request.getParameter("name"));

스프링 프레임워크 방식
@RequestParam(value = "name") String name1
@RequestParam(name = "name") String name
// 요청 파라미터 이름과 메서드 파라미터(아규먼트)의 이름이 같다면
// 애노테이션을 생략해도 된다.
// 필수 항목이다

String name2, // 애노테이션을 붙이지 않으면 선택 항목으로 간주한다.
// 따라서 파라미터 값이 없으면 null을 받는다.

@RequestParam(value = "name3", required = false) String name3,
// required 프로퍼티를 false로 설정하면 선택 항목으로 간주한다.

@RequestParam(value = "name4", defaultValue = "ohora") String name4
// 기본 값을 지정하면 파라미터 값이 없어도 된다.

Car car
// 아규먼트가 값 객체이면 요청 파라미터 중에서 값 객체의 프로퍼티 이름과 일치하는
// 항목에 대해 값을 넣어준다.
// 값 객체 안에 또 값 객체가 있을 때는 OGNL 방식으로 요청 파라미터 값을
// 지정하면 된다.
// 예) ...&engine.model=ok&engine.cc=1980&engine.valve=16
-------------------------------------------------------------------------------------
개발자가 원하는 파라미터 타입으로 변환하기

// 페이지 컨트롤러의 request handler를 호출할 때 
// 요청 파라미터의 값을 request handler의 아규먼트로 바꿀 때마다 호출되는 메소드
// => 이 메소드에서 파라미터 값을 형변환시키는 도구를 설정한다
  @InitBinder
  public void ok(WebDataBinder 데이터변환등록기) {
    System.out.println("ok()......");
    PropertyEditor 파라미터값변환기 = new DatePropertyEditor();
    데이터변환등록기.registerCustomEditor(
        java.sql.Date.class, // String 값을 어떤 타입으로 바꿀 것인지 지정
        파라미터값변환기 // String 값을 해당 타입으로 변환해줄 변환기 지정
    );
  }

파라미터 값 변환 해주는 클래스
public class DatePropertyEditor extends PropertyEditorSupport {

  @Override
  public void setAsText(String text) throws IllegalArgumentException {
    this.setValue(Date.valueOf(text)); // yyyy-mm-dd ===> java.sql.Date 객레초 변환
  }
}
-------------------------------------------------------------------------------------
Car(사용자 정의) 타입으로 변환하기

public class CarPropertyEditor extends PropertyEditorSupport {

  @Override
  public void setAsText(String text) throws IllegalArgumentException {
    String[] values = text.split(","); // model,maker,capacity,auto,createdDate
    Car car = new Car();
    car.setModel(values[0]);
    car.setMaker(values[1]);
    car.setCapacity(Integer.parseInt(values[2]));
    car.setAuto(Boolean.parseBoolean(values[3]));
    car.setCreatedDate(Date.valueOf(values[4]));
    this.setValue(car);
  }
}

@InitBinder가 붙은 메소드의 등록기 설정
데이터변환등록기.registerCustomEditor(
        Car.class, // String 값을 Car 객체로 만들 것이라고 지정
        new CarPropertyEditor() // String 값을 Car 객체로 변환해줄 변환기 지정
);
-------------------------------------------------------------------------------------
★ 모든 페이지 컨트롤러에게 적용(별도의 클래스 만들어서 적용)

@ControllerAdvice
public class GlobalInitBinder {

  // 페이지 컨트롤러의 request handler를 호출할 때
  // 요청 파라미터의 값을 request handler의 아규먼트로 바꿀 때마다 호출되는 메소드
  // => 이 메소드에서 파라미터 값을 형변환시키는 도구를 설정한다
  @InitBinder
  public void initBinder(WebDataBinder 데이터변환등록기) {
    System.out.println("ok()......");

    데이터변환등록기.registerCustomEditor(
        java.sql.Date.class, // String 값을 어떤 타입으로 바꿀 것인지 지정
        new DatePropertyEditor() // String 값을 해당 타입으로 변환해줄 변환기 지정
    );

    데이터변환등록기.registerCustomEditor(
        Car.class, // String 값을 Car 객체로 만들 것이라고 지정
        new CarPropertyEditor() // String 값을 Car 객체로 변환해줄 변환기 지정
    );

    데이터변환등록기.registerCustomEditor(
        Engine.class, // String 값을 Car 객체로 만들 것이라고 지정
        new EnginePropertyEditor() // String 값을 Car 객체로 변환해줄 변환기 지정
    );
}
-------------------------------------------------------------------------------------
// 클라이언트의 HTTP 요청 헤더를 받고 싶으면
// request handler의 아규먼트 앞에 @RequestHeader(헤더명) 애노테이션을 붙여라!
@RequestHeader("Accept") String accept
@RequestHeader("User-Agent") String userAgent
-------------------------------------------------------------------------------------
쿠키 주고 받기

쿠키 보내기
response.addCookie(new Cookie("name2", URLEncoder.encode("AB가각", "UTF-8")));

쿠키 받기
@CookieValue(value = "name2", defaultValue = "") String name2
-------------------------------------------------------------------------------------
쿠키에서 인코딩 디코딩

    // 1) URLEncoder.encode("AB가각", "UTF-8")
    // ==> JVM 문자열은 UTF-16 바이트 배열이다.
    //     0041 0042 ac00 ac01
    // ==> UTF-8 바이트로 변환한다.
    //     41 42 ea b0 80 ea b0 81
    // ==> 8비트 데이터가 짤리지 않도록 URL 인코딩으로 7비트화 시킨다.
    //     "AB%EA%B0%80%EA%B0%81"
    //     41 42 25 45 41 25 42 30 25 38 30 25 45 41 25 42 30 25 38 31
    // ==> 웹 브라우저에서는 받은 값을 그대로 저장
    //
    // 2) 쿠키를 다시 서버로 보내기
    // ==> 웹 브라우저는 저장된 값을 그대로 전송
    //     "AB%EA%B0%80%EA%B0%81"
    //     41 42 25 45 41 25 42 30 25 38 30 25 45 41 25 42 30 25 38 31
    // ==> 프론트 컨트롤러가 쿠키 값을 꺼낼 때 자동으로 URL 디코딩을 수행한다.
    //     즉 7비트 문자화된 코드를 값을 원래의 8비트 코드로 복원한다.
    //     41 42 ea b0 80 ea b0 81
    // ==> 디코딩 하여 나온 바이트 배열을 UTF-16으로 만든다.
    //     문제는 바이트 배열을 ISO-8859-1로 간주한다는 것이다.
    //     그래서 UTF-16으로 만들 때 무조건 앞에 00 1바이트를 붙인다.
    //     0041 0042 00ea 00b0 0080 00ea 00b0 0081
    //     그래서 한글이 깨진 것이다.
    //
    // 해결책:
    // => UTF-16을 ISO-8859-1 바이트 배열로 변경한다.
    //    41 42 ea b0 80 ea b0 81
    byte[] originBytes = name2.getBytes("ISO-8859-1");

    // => 다시 바이트 배열을 UTF-16으로 바꾼다.
    //    이때 바이트 배열이 UTF-8로 인코딩된 값임을 알려줘야 한다.
    //    0041 0042 ac00 ac01
    String namex = new String(originBytes, "UTF-8");

    return String.format(//
        "name1=%s\n name2=%s\n name2=%s\n name3=%s\n age=%d\n", //
        name1, name2, namex, name3, age);
-------------------------------------------------------------------------------------
스프링 프레임워크에서 multipart 받기

Part photo // Servlet API의 객체

    String filename = null;
    if (photo != null && photo.getSize() > 0) {
      filename = UUID.randomUUID().toString();
      String path = sc.getRealPath("/upload/" + filename);
      photo.write(path);
    }

MultipartFile photo // Spring API의 객체
    String filename = null;
    if (photo != null && !photo.isEmpty()) {
      filename = UUID.randomUUID().toString();
      String path = sc.getRealPath("/upload/" + filename);
      photo.transferTo(new File(path));
    }

MultipartFile[] photo // 배열로 받기
    for (MultipartFile f : photo) {
      if (!f.isEmpty()) {
        String filename = UUID.randomUUID().toString();
        String path = sc.getRealPath("/upload/" + filename);
        f.transferTo(new File(path));
        out.printf("<p><img src='../../upload/%s'></p>\n", filename);
      }
    }
-------------------------------------------------------------------------------------
클라이언트가 보내는 데이터를 한 덩어리로 받기
// 클라이언트가 보낸 데이터를 통째로 받으려면 파라미터 앞에 @RequestBody 애노테이션을 붙인다.
      String name,
      int age,
      @RequestBody String data
-------------------------------------------------------------------------------------
★ 컨텐츠 직접 리턴하기(디코딩 제어)
    // 리턴 값이 클라이언트에게 보내는 콘텐트라면
    // 메서드 선언부에 @ResponseBody를 붙인다.
    // => 붙이지 않으면 프론트 컨트롤러는 view URL로 인식한다.
    // => 출력 콘텐트는 브라우저에서 기본으로 HTML로 간주한다.
    //    단 한글은 ISO-8859-1 문자표에 정의된 코드가 아니기 때문에
    //    클라이언트로 보낼 때 '?' 문자로 바꿔 보낸다.
@GetMapping(value = "h2", produces = "text/html;charset=UTF-8")

응답 헤더에 직접 Content-Type을 설정할 수 있다(HttpEntity<String> 리턴)
    HttpHeaders headers = new HttpHeaders();
    headers.add("Content-Type", "text/html;charset=UTF-8");

    HttpEntity<String> entity = new HttpEntity<>(
        "<html><body><h1>abc가각간<h1></body></html>",
        headers);

    return entity;


응답 헤더에 직접 Content-Type을 설정할 수 있다(ResponseEntity<String> 리턴)
    HttpHeaders headers = new HttpHeaders();
    headers.add("Content-Type", "text/html;charset=UTF-8");

    ResponseEntity<String> entity = new ResponseEntity<>(
        "<html><body><h1>abc가각간<h1></body></html>",
        headers,
        HttpStatus.OK // 응답 상태 코드를 설정할 수 있다.
    );

    return entity;
-------------------------------------------------------------------------------------
jsp 페이지(view) 리턴하기
    // 메서드 선언부에 @ResponseBody를 붙이지 않으면
    // 프론트 컨트롤러는 view URL로 간주한다.
    // => 리턴 URL의 '/'는 웹 애플리케이션 루트를 의미한다.
    return "/jsp/c05_2.jsp";

    // MVC 패턴에서는 항상 Controller에 의해 View가 통제되어야 한다.
    // Controller를 경유하지 않고 View를 실행하게 해서는 안된다.
    // 그래야 View에 대해 일관성 있는 제어가 가능하다.
    // 문제는 jsp 파일을 웹 애플리케이션의 일반 폴더에 두게 되면
    // 다음과 같이 클라이언트에서 직접 실행을 요청할 수 있다.
    // http://localhost:9999/eomcs-spring-webmvc/jsp/c05_2.jsp
    //
    // 이것을 막으려면, 다음과 같이 WEB-INF 폴더 밑에 JSP 파일을 두어라.
    // /WEB-INF 폴더에 있는 파일은 클라이언트에서 직접 실행을 요청할 수 없다.
    return "/WEB-INF/jsp/c05_2.jsp";
-------------------------------------------------------------------------------------



2024.03.19(화)
-------------------------------------------------------------------------------------
jsp 객체 리턴
  @GetMapping("h3")
  public View handler3() {
    return new JstlView("/WEB-INF/jsp/c05_2.jsp");
  }
-------------------------------------------------------------------------------------
모델/jsp 객체 리턴
  @GetMapping("h4")
  public ModelAndView handler4() {
    System.out.println("===> /app1/c05_2/h4");
    ModelAndView mv = new ModelAndView();
    mv.setViewName("/WEB-INF/jsp/c05_2.jsp");
    return mv;
  }
-------------------------------------------------------------------------------------
리타이렉트/포워드
 @GetMapping("h6")
  public String handler6() {
     return "redirect:h4";
     return "forward:h4";
}
-------------------------------------------------------------------------------------
프론트 컨트롤러에게 값 전달하기

1)
@GetMapping("h3")
public String handler3(ServletRequest request, Map<String, Object> map, Model model) {

    request.setAttribute("name", "홍길동");
    request.setAttribute("age", 20); // auto-boxing: int ===> Integer 객체
    request.setAttribute("working", true); // auto-boxing: boolean ===> Boolean 객체

    map.put("name", "홍길동");
    map.put("age", 20); // auto-boxing
    map.put("working", true); // auto-boxing

    model.addAttribute("name", "홍길동");
    model.addAttribute("age", 20); // auto-boxing
    model.addAttribute("working", true); // auto-boxing

    return "/WEB-INF/jsp/c05_3.jsp";
}

2)
@GetMapping("h4")
public ModelAndView handler4() {

    // request handler에서 ModelAndView 객체를 만들어 리턴한다.
    // => 이 객체의 용도는 Model과 view URL을 함께 리턴하는 것이다.
    //
    ModelAndView mv = new ModelAndView();

    // JSP가 사용할 데이터를 담고
    mv.addObject("name", "홍길동");
    mv.addObject("age", 20); // auto-boxing
    mv.addObject("working", true); // auto-boxing

    // JSP 주소도 담는다.
    mv.setViewName("/WEB-INF/jsp/c05_3.jsp");

    return mv;
  }
-------------------------------------------------------------------------------------
ViewResolver IoC 컨테이너에 설정
→ view name을 리턴하지 않고 객체를 리턴할 때 주로 사용한다
→ 상대경로를 계산해서 view name을 리턴한다

  @GetMapping("h3")
  public Map<String, Object> handler3() {

    HashMap<String, Object> map = new HashMap<>();
    map.put("name", "홍길동3");
    map.put("age", 40);
-------------
    ModelAndView mv = new ModelAndView();
    mv.addObject("name", "홍길동3");
    mv.addObject("age", 40);
    mv.setViewName("c01_2/h4"); // 없으면 리턴 값으로 view name이 리턴된다
-------------

    // Map 객체에 값을 담아 리턴하면
    // 프론트 컨트롤러는 Map 객체에 보관되어 있는 값들을 ServletRequest 보관소로 옮긴다.
    // 그리고 view URL은 request handler의 URL을 사용한다.
    // => "/WEB-INF/jsp2/" + "c01_2/h3" + ".jsp" = "/WEB-INF/jsp2/c01_2/h3.jsp"
    return map;
  }

  @Bean
  public ViewResolver viewResolver(){
    InternalResourceViewResolver vr = new InternalResourceViewResolver(
        "/WEB-INF/jsp2/",
        ".jsp"
    );
    return vr;
  }
-------------------------------------------------------------------------------------
기존 방법인 URL에 Query String이 아니라 경로에 파라미터 값 삽입하기

http://localhost:8888/app2/c02_1/aaa/30

  @GetMapping("{name}/{age}")
  @ResponseBody
  public String handler2(
      /*
      @PathVariable("name") String name,
      @PathVariable("age") int age
       */
      // URL의 변수 이름을 생략하면 아규먼트 이름을 사용한다.
      @PathVariable String name,
      @PathVariable int age
  ) {
    // URL path에 값을 포함하여 전달할 수 있고, 그 값을 아규먼트로 받을 수 있다.
    // URL path에 포함된 값을 받으려면 request handler의 URL을 설정할 때
    // 다음의 문법으로 선언해야 한다.
    // => .../{변수명}/{변수명}
    // 이렇게 선언된 변수 값을 받으려면 다음과 같이 아규먼트를 선언해야 한다.
    // => @PathVariable(변수명) String 아규먼트
    // 변수명과 아규먼트의 이름이 같다면, 다음과 같이 변수명을 생략할 수 있다.
    // => @PathVariable String 아규먼트
    //
    return String.format("name=%s, age=%d", name, age);
  }
-------------------------------------------------------------------------------------
MatrixVariable 사용하기
 
  @GetMapping(value = "{value}", produces = "text/plain;charset=UTF-8")
  @ResponseBody
  public String handler2(
      @PathVariable("value") String value,
      @MatrixVariable String name,
      @MatrixVariable int age) {
    return String.format("value:%s \n name:%s, age:%d", value, name, age);
  }

      @MatrixVariable(name = "name", pathVar = "team") String name1,
      @MatrixVariable(name = "qty", pathVar = "team") int qty1,
      @MatrixVariable(name = "name", pathVar = "task") String name2,
      @MatrixVariable(name = "qty", pathVar = "task") int qty2

→ ; 으로 구분해서 파라미터 값을 받을 수 있다
http://localhost:8888/app2/c02_2/name=aaa;qty=6/title=bbb;state=2
-------------------------------------------------------------------------------------
MatrixVariable 설정

    // 1) XML 설정
    //    => <mvc:annotation-driven enable-matrix-variables="true"/>
    // 2) Java Config 설정
    //    => @EnableWebMvc 애노테이션을 활성화시킨다.
    //    => WebMvcConfigurer 구현체를 정의한다.
    //    => configurePathMatch 메소드 재정의한다
    //    => UrlPathHelper 객체의 setRemoveSemicolonContent 프로퍼티 값을 false로 설정한다.
-------------------------------------------------------------------------------------
정규표현식

  @GetMapping(
      value="h2/{name:[a-zA-Z0-9]+}/{tel:[0-9]+-[0-9]+-[0-9]+}/{gender:man|woman}", 
      produces="text/plain;charset=UTF-8")
  @ResponseBody
  public String handler2(
      @PathVariable String name, 
      @PathVariable String tel,
      @PathVariable String gender) {
    
    // 패스 변수를 사용할 때,
    // 패스 변수의 값 규칙을 정규표현식으로 정의할 수 있다.
    // 정규 표현식에 어긋간 URL의 경우 예외가 발생할 것이다.
    //
    return String.format("name: %s\n tel: %s \n gender: %s", 
        name, tel, gender);
  }
-------------------------------------------------------------------------------------



2024.03.20(수)
-------------------------------------------------------------------------------------
세션 다루기

@GetMapping(value = "h1", produces = "text/plain;charset=UTF-8")
@ResponseBody
public String handler1(HttpSession session) {
    session.setAttribute("name", "홍길동");
    session.setAttribute("age", "20");

    session.getAttribute("name");
    session.getAttribute("age");

    session.invalidate();
}
-------------------------------------------------------------------------------------
세션과 모델 동시에 저장하기

@Controller
@RequestMapping("/c03_2")
@SessionAttributes({"name2", "age2"})
public class Controller03_2 {
  @GetMapping(value = "h1", produces = "text/plain;charset=UTF-8")
  @ResponseBody
  public String handler1(Model model) {

    model.addAttribute("name2", "임꺽정");
    model.addAttribute("age2", "30");
    model.addAttribute("tel2", "1111-2222");

    return "세션에 값 보관했음!";
  }

  @GetMapping(value = "h4", produces = "text/plain;charset=UTF-8")
  @ResponseBody
  public String handler4(
      // 현재 페이지 컨트롤러의 @SessionAttributes 에 지정된 이름이 아니라면,
      // 프론트 컨트롤러는 요청 파라미터에서 해당 이름의 값을 찾아 넘겨준다.
      // 요청 파라미터에 해당 이름의 값이 없다면,
      // 프론트 컨트롤러는 빈 문자열을 넘겨준다.
      // 세션 값이 우선순위가 더 높다
      @ModelAttribute("name") String name,
      @ModelAttribute("age") String age,
      @ModelAttribute("name2") String name2,
      @ModelAttribute("age2") String age2) {

    return String.format("name=%s, age=%s, name2=%s, age2=%s",
        name, age, name2, age2);
  }
}

status.setComplete();
→ @SessionAttributes로 세션에 저장된 값들을 무효화 시킨다
→ 특정 작업을 진행하는 동안 요청과 요청 사이에 작업을 공유하기 위해 세션 값을 보관한다
→ 작업이 끝나면 중간에 세션에 보관했던 값을 제거한다
-------------------------------------------------------------------------------------
Interceptor
→ 필터라고 보면된다
→ 디스패처가 JSP, 페이지 컨트롤러 실행 전후 기능을 추가, 삭제
// 인터셉터 만들기
// => 프론트 컨트롤러와 페이지 컨트롤러 사이에 코드를 삽입하는 기술
// => 프론트 컨트롤러와 뷰 컴포넌트 사이에 코드를 삽입하는 기술
//
// 인터셉터를 배치하기
// => 프론트 컨트롤러의 IoC 설정 파일에 배치 정보를 추가한다.
// HandlerInterceptor 구현체로 만들기

public class Interceptor1 implements HandlerInterceptor {
  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
      throws Exception {
    System.out.println("Interceptor1.preHandle()");
    return true;
  }
  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
      ModelAndView modelAndView) throws Exception {
    System.out.println("Interceptor1.postHandle()");
  }
  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
      Object handler, Exception ex) throws Exception {
    System.out.println("Interceptor1.afterCompletion()");
  }
}

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    // 인터셉트를 적용할 경로를 지정하지 않으면 모든 request handler에 대해 적용된다
    registry.addInterceptor(new Interceptor1());
    registry.addInterceptor(new Interceptor2()).addPathPatterns("/c04_1/*");
    registry.addInterceptor(new Interceptor3()).addPathPatterns("/c04_1/**");
  }
-------------------------------------------------------------------------------------
JSON 컨텐츠 넣고 출력하기
기존 방식 → 리스트를 model(or map) 객체에 담아서 리턴하고 JSP에서 jstl으로 반복문 반복해서 출력

@GetMapping(value="h2", produces="text/plain;charset=UTF-8")
  @ResponseBody
  public String handler2() {
    return new Gson().toJson(this.list);
  }

  @GetMapping("h3")
  @ResponseBody
  public Object handler3() {
    return this.list; // JSON 형식의 문자열은 자동으로 UTF-8로 인코딩 된다.
  } 
→ MappingJackson2HttpMessageConverter 또는 GsonHttpMessageConverter 객체를 사용
-------------------------------------------------------------------------------------
@RestController
// => 페이지 컨트롤러를 @RestController로 선언하면,
//    리턴 값은 HttpMessageConverter에 의해 자동으로 변환된다.
// => @ResponseBody를 붙일 필요가 없다.
-------------------------------------------------------------------------------------
JSON 객체 통채로 받기
@RestController
@RequestMapping("/c05_3")
public class Controller05_3 {

  @RequestMapping(value="h3", produces="text/plain;charset=UTF-8")
  public Object handler3(@RequestBody String content) throws Exception {
    System.out.println(content);
    System.out.println(URLDecoder.decode(content, "UTF-8"));
    return "OK!";
  }

  @RequestMapping(value="h4", produces="text/plain;charset=UTF-8")
  public Object handler4(@RequestBody Map<String,Object> content) throws Exception {
    System.out.println(content);
    return "OK!";
  }

  @RequestMapping(value="h5", produces="text/plain;charset=UTF-8")
  public Object handler5(@RequestBody Board content) throws Exception {
    System.out.println(content);
    return "OK!";
  }
}
-------------------------------------------------------------------------------------
jacksom ==> json 형태로 변환
  @JsonFormat(shape= JsonFormat.Shape.STRING,pattern="yyyy-MM-dd")
  public void setCreatedDate(Date createdDate) {
    this.createdDate = createdDate;
  }
-------------------------------------------------------------------------------------
오류 처리
  @ExceptionHandler
  public ModelAndView exceptionHandler(Exception ex) {
    System.out.println("Controller06_1.exceptionHandler() 호출됨!");
    ModelAndView mv = new ModelAndView();
    mv.addObject("error", ex);
    mv.setViewName("error6");
    return mv;
  }

    // Request Handler에서 예외를 던졌을 때 처리 절차!
    // 1) 페이지 컨트롤러 안에 예외 처리기가 있다면,
    // => 해당 메서드를 호출한다.
    // 2) @ControllerAdvice 객체에 예외 처리기가 있다면,
    // => 해당 메서드를 호출한다.
    // 3) web.xml 에 지정된 오류 처리 기본 페이지가 설정되어 있다면,
    // => 해당 페이지를 실행한다.
    // 4) 서블릿 컨테이너의 기본 오류 처리 페이지를 실행한다.

  <error-page>
    <location>/app2/error</location>
  </error-page>
-------------------------------------------------------------------------------------



2024.03.21(목)
-------------------------------------------------------------------------------------
과제 75. Spring WebMVC 프레임워크 도입하기
- Spring WebMVC 프레임워크 사용법
- CharacterEncodingFilter 사용법
- ContextLoaderListener 사용법
- DispatcherServlet 사용법
-------------------------------------------------------------------------------------
과제 76. Spring WebMVC를 Java Config로 설정하기
- Java Config를 이용하여 Spring WebMVC를 설정하는 방법
- Log4j2 적용하는 방법
- @GetMapping, @PostMapping, Model, MultipartFile 적용하는 방법
- @ControllerAdvice, @InitBinder 사용하여 파라미터의 PropertyEditor를 등록하는 방법
- 예외가 발생했을 때 출력될 오류 페이지를 설정하는 방법 : @ExceptionHandler
-------------------------------------------------------------------------------------
과제 77. Spring WebMVC의 기본 ViewResolver를 InternalResourceViewResolver로 교체하기
- InternalResourceViewResolver를 설정하는 방법
-------------------------------------------------------------------------------------
Mybatis Persistence Framework(SQL Mapper)
.java {자바코드 + SQL + JDBC 코드}
→ 자바코드
→ SQL
→ {JDBC 코드 + ∂} = Mybatis

이점
→ 코드 가독성이 좋아진다 자바코드와 SQL 코드 분리
→ JDBC 코드 작성 불필요 Mybatis에서 캡슐화
→ 유지보수가 쉬워진다
-------------------------------------------------------------------------------------
SI 와 SM

SI(System Integration)
→ 새로운 시스템을 만들어서 다른 시스템과 연동해서 처리
→ 기능 추가/변경/삭제
→ SQL을 직접 다루지 않는다
 
SM(System Maintenance)
→ 기존 시스템(Legacy)의 기능을 추가
→ 기능 추가/변경/삭제
→ SQL을 직접 다룬다
-------------------------------------------------------------------------------------
Mybatis

1) SQL Mapper(예 : Mybatis)
개발자 → 작성 → SQL → 실행 → DBMS
→ DBMS 특성에 맞춰서 SQL 직접 작성
→ 번거롭다
→ DBMS의 성능을 100% 끌어낼 수 있는 SQL 작성 가능

2) Object-Relation Mapper(예 : Hibernate → JPA)
개발자 → call → API → 생성 → SQL → 실행 → DBMS
→ DBMS 특성에 맞춰 SQL 자동 생성
→ 개발자가 SQL문을 몰라도 된다
→ DBMS의 성능을 최대로 활용할 수 없다
-------------------------------------------------------------------------------------



2024.03.22(금)
-------------------------------------------------------------------------------------
SqlSession 과 Connection, Transaction

1) 트랜잭션을 시작하지 않았을 때
					      DataSource
						↑↓ 생성/반납
SqlSessionFactory → openSession() → SqlSession → Connection1 → Thread1
			        → SqlSession → Connection2 → Thread2
			        → SqlSession → Connection3 → Thread3
→ SqlSession.close() 하면 Connection 반납

2) 트랜잭션을 시작했을 때
					      DataSource
						↑↓ 생성/반납
SqlSessionFactory → openSession() → SqlSession → Connection1 → Thread1
			        → SqlSession		→ 커넥션 공유
			        → SqlSession 
→ TransationManager가 commit/rollback 하고 스레드의 작업이 종료 되었을 때 Connection 반납
→ commit 하면 실제 테이블에 반영
→ rollback 하면 임시 테이블 삭제
-------------------------------------------------------------------------------------
과제 78. Mybatis SQL-mapper 프레임워크 사용하기
- mybatis 프레임워크의 구동 원리 및 사용법
- Spring Fframework에 적용하는 방법
- Mybatis의 Log4j 활성화 하기
-------------------------------------------------------------------------------------
과제 79. Mybatis 설정을 XML에서 Java Config로 바꾸기
- Java Config로 Mybatis를 설정하는 방법
  - 'mybatis-spring' 라이브러리 추가
  - 'spring-jdbc' 라이브러리 추가
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------
→
-------------------------------------------------------------------------------------