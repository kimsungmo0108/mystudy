★ 해시 값 활용 예 ★
톰캣 서버 사이트 → tomcqt.zip 다운 → 로컬
→ 해커가 개입해서 변조된 파일이 다운로드 될 수 있다
→ 서버에 원본 파일과 같은지 검증이 필요하다
→ 해시 알고리즘에 따라서 (PGP, SHA512) 해시 값 참조
→ 우리 해시 값이랑 비교
→ $ certutil -hashfile "apache-tomcat-9.0.84.zip" SHA512 
→ 명령어로 해시 값 만들어서 비교하기

★ 로컬 변수와 클래스 변수 사용
int a;
static int b;

MyClass obj1 = new MyClass();
System.out.println(obj1.a);
System.out.println(MyClass.b);

double EPSILON = 0.00001;
★ System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON); → 비교할 두 실수를 빼서 절댓값을 구한 뒤 개발자가 정해둔 범위보다 작으면 무시하자 ★

★ 연산자를 이용하여 짝수/홀수 알아내기 ★
System.out.println(57 % 2 == 0 ? "짝수" : "홀수");
System.out.println((57 & 0x1) == 0 ? "짝수" : "홀수");
(a == b ? c : d); → a와 b를 비교해서 참이면 c, 거짓이면 d를 실행

★ 메모리 절약
lang2 = lang2 | 0x80 → 비트 연산자를 이용해서 적은 메모리를 더 많은 true/false를 저장 할 수 있다
touch Hello.txt
chmod 755 Hello.txt
final int CSS           = 0x01; // 0000 0001
final int HTML          = 0x02; // 0000 0010
final int PHP           = 0x04; // 0000 0100
final int PYTHON        = 0x08; // 0000 1000
final int JAVASCRIPT    = 0x10; // 0001 0000
final int JAVA          = 0x20; // 0010 0000
final int CPP           = 0x40; // 0100 0000
final int C             = 0x80; // 1000 0000

★ 문자열을 숫자로 변환
String s = '12345';
int a = Integer.valueOf(s);
int b = Integer.parselnt(s);

후위 연산자
int a = 100;
→ int temp(임시 변수) = a; → a = a + 1 → b = temp → b = 100, a = 101
b = a; → a = a + 1
→ 항상 r-value를 먼저 실행한 후에 할당(=) 연산을 수행한다
int a = 100;
a++;
★ 추측 1 → 항상 r-value를 먼저 실행한다
→ int temp = a; → a = a + 1 → a = temp → 100

★ switch 문에서 변수 사용할 때 enum변수 사용
enum Level {
    GUEST, MEMBER, ADMIN
}
Level level = Level.MEMBER;           → enum 변수에는 그 타입에 정의된 값만 저장할 수 있다 → 안전한 코드 작성 가능

★ 리스트
ArrayList<String> list = new ArrayList<>();

★ Hello를 파일에 출력하기
OutputStream output = new FileoutputStream("test.txt");
PrintStream output2 = new PrintStream(output);
output2.pintln("Hello");
output2.close();
밥 a = new 밥(쌀);
밥그릇 b = new 밥그릇(a);
b.먹자("달걀");

★ 배열로 5명의 이름을 연속적으로 입력받기
String[] names = new String[5];
Scanner nameScan = new Scanner(System.in);
for (int i = 0; i < 5; i++) {
	System.out.println("5명의 이름을 적어주세요");
	names[i] = nameScan.nextLine();
      	// System.out.println("입력된 이름 : " + names[i]);
    }
for (String s : names) {
      	System.out.println("입력된 이름 : " + s);
    }
nameScan.close();

★ 입력 받기
java.io.InputStream keyboard = System.in;
java.util.Scanner keyboardScanner = new java.util.Scanner(keyboard);

System.out.print("이름? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("전화? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("이메일? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("나이? ");
System.out.println(keyboardScanner.nextLine());
System.out.print("재직여부? ");
System.out.println(keyboardScanner.nextLine());
keyboardScanner.close();

★ 키보드로 입력받는 메소드 연습
java.io.InputStream in = System.in;
java.util.Scanner numScan = new Scanner(in);
int num = numScan.nextInt();
문자열=="abc"  ===>  if (num.equals("abc"));

★ 메소드(method) = 함수(function)
리턴값의타입 기능이름(값을 받을 변수 선언){
    명령문
}
int plus(int a, int b){
    int result;
    result = a + b;
    return result;
}
static void printMenu(){
}

★ 메소드 활용
main() → main()과 printMenu() 기능을 분리 → main()에서 printMenu()를 호출 → printMenu()에서 출력
printMenu() → 메뉴 목록 배열, ansi 명령, app 제목 → 공통 변수로 분리 

로컬 변수와 클래스 변수(static 변수)
class App{
	static int a; → 클래스 변수(필드) = static field
	void main(){
		int b; → 로컬 변수(local variable) 메소드 안에 선언된 변수, 메소드 실행될 때 생성되고 메소드의 실행이 끝나면 제거된다
	}
}

★ git bash에서 아규먼트 값 받아서 출력
$ javac -d build/classes/java/main src/main/java/com/eomcs/lang/ex07/Exam0610.java
$ java -classpath build/classes/java/main -Da=100 -Db=200 -Dc=300 com.eomcs.lang.ex07.Exam0610

String name = System.getProperty("name");
String s1 = System.getProperty("kor");
String s2 = System.getProperty("eng");
String s3 = System.getProperty("math");
$ javac -d build/classes/java/main src/main/java/com/eomcs/lang/ex07/Exam0620.java 
$ java -classpath build/classes/java/main -Dname=김성모 -Dkor=80 -Deng=50 -Dmath=10 com.eomcs.lang.ex07.Exam0620

★ 클래스 생성자 문법
Score s1 = new Score("홍길동", 100, 90, 85);
public Score(String name, int kor, int eng, int math) {
    this.name = name;
    this.kor = kor;
    this.eng = eng;
    this.math = math;
}

★ 레퍼런스 배열 생성
static Assignment[] assignments = new Assignment[3];

    Assignment assignment = new Assignment();
    assignment.title = Prompt.input("과제명? ");
    assignment.content = Prompt.input("내용? ");
    assignment.deadline = Prompt.input("제출 마감일? ");

    assignments[length] = assignment;
    length++;

★ 원하는 배열 삭제
    int index = Integer.parseInt(Prompt.input("번호? "));
    for (int i = index; i < (length - 1); i++) {
      assignments[i] = assignments[i + 1];
    }
    length--;
    assignments[length] = null;
    System.gc();  // garbage collector 한테 요청

★ 배열 인덱스 오류
    if (index < 0 || index >= length) {
      System.out.println("과제 번호가 유효하지 않습니다.");
      return;
    }

★ 배열 크기 늘리고 새로 생성
    if (length == assignments.length) {
      int oldSize = assignments.length;
      int newSize = oldSize + (oldSize / 2);

      // 이전 배열에 들어 있는 값을 새 배열에 복사
      Assignment[] arr = new Assignment[newSize];
      for (int i = 0; i < oldSize; i++) {
        arr[i] = assignments[i];
      }
      
      // 새 배열을 가리키도록 배열 레퍼런스를 변경
      assignments = arr;

      return;
    }

★ 클래스 로딩 시키기
Class.forName("com.eomcs.oop.ex03.Exam0650$A");

★ 클래스 필드 로딩 순서
  static class A {
    static int a = 7;
    static {
      System.out.println("A.static{}");
      a += B.b;
    }
  }
  static class B {
    static int b = 22;
    static {
      System.out.println("B.static{}");
      b += A.a;
    }
  }
    System.out.println(A.a); // ?
    System.out.println(B.b); // ?

★ Repository에 보관된 목록을 배열로 리턴 받기
방법1 
Board[] boards = new Board[this.objectRepository.size()];
this.objectRepository.toArray(boards);
방법2
Board[] boards = this.objectRepository.toArray(new Board[0]);

Arrays.copyOf(this.objects, this.length);

System.arraycopy(this.objects, index + 1, this.objects, index, this.length - (index + 1));

★ 큰 값 찾기
max = a > b ? a : b;
max = Math.max(a, b);

★ JVM이 외부에서 읽거나 외부로 내보낼 때 문자 규칙
Charset.defaultCharset(); → OS마다 다르다

★ 인스턴스에서 조회
s1.charAt(1);

★ 인스턴스랑 빼기 (비교할 때 사용)
s1.compareTo("Helli");

★ 인스턴스에 아규먼트 값이 들어있는지 여부 확인
s1.contatins("ll");

★ 문자열을 연결해서 새 문자열 만들기
String s2 = s1.concat(", world!"); → 기존 인스턴스의 값은 변경하지 않아서 새로운 변수에 담아야 한다(immutable)

★ 두 인스턴스 문자열이 같은지 비교
s1.equals("Hello");

★ 바이트 배열로 꺼낼 때
byte[] bytes = s3.getBytes();
→ 기본 인코딩 방식(UTF-8)으로 코드 값 저장
byte[] bytes = s3.getBytes("인코딩 방식") 
→ 이런 방식으로 여러 OS에서도 사용하자

★ 형식을 갖춘 문자열을 만들기
String s4 = String.format("%s님 반갑습니다", "홍길동");
→ 스트링 객체를 만들어서 객체 주소 반환

★ 구분자와 문자열들을 파라미터로 받아서 새 문자열을 만든다.
String s5 = String.join(":", "홍길동", "임꺽정", "유관순");

★ primitive 값을 문자열로 만든다.
String s6 = String.valueOf(true); // "true"
String s7 = String.valueOf(3.14f); // "3.14"
String s8 = String.valueOf(100); // "100"
Integer x2 = Integer.valueOf("44", 16); // 16진수라고 지정한다.

★ Integer 객체에서 int 값을 뽑아 낼 때 
int v1 = i2.intValue(); 

★int 변환
int v2 = Integer.parseInt("1280"); // String

★ 2진수, 8진수, 16진수로 변환
String s1 = Integer.toBinaryString(77);
String s2 = Integer.toOctalString(77);
String s3 = Integer.toHexString(77);

★ ValueOf()로 만들면 한 객체만 생성해서 사용(-128~127
Integer i1 = Integer.valueOf(127);
Integer i2 = Integer.valueOf(127);
Integer i3 = Integer.valueOf(127);
→ 인테저 객체를 만든다(-128~127)

★ Math 클래스
// => 절대값 계산
System.out.println(Math.abs(-200));
// => ceil() : 파라미터로 주어진 부동소수점이 바로 위 큰 정수 값을 리턴
// => floor() : 파라미터로 주어니 부동소수점의 바로 밑 작은 정수 값을 리턴
System.out.println(Math.ceil(3.28)); // 4
System.out.println(Math.floor(3.28)); // 3
System.out.println(Math.ceil(-3.28)); // -3
System.out.println(Math.floor(-3.28)); // -4
// => 2의 7승 값을 알고 싶을 때
System.out.println(Math.pow(2, 7));
// => 반올림하여 정수 값 리턴
System.out.println(Math.round(3.14));
System.out.println(Math.round(3.54));

★ 오늘 데이트 객체 만들어서 출력
Date d1 = new Date();
String str0 = d1.toString();
// 인스턴스 메서드 활용
System.out.println(d1.getYear() + 1900);
System.out.println(d1.getMonth() + 1);
System.out.println(d1.getDate());
// 스태틱 메서드 활용
long currMillis = System.currentTimeMillis();
// ★ 생성자 활용
java.sql.Date today = new java.sql.Date(currMillis);
String str = today.toString();
System.out.println(str);
→ YYYY-MM-DD로 출력
// ★ 스태틱 메서드 활용
java.sql.Date d = java.sql.Date.valueOf("2019-12-30");
System.out.println(d);
// println()에 문자열을 주지 않고 그냥 객체(의 주소)를 넘기면
// println() 내부에서 해당 객체의 toString()을 호출한 후에 
// 그 리턴 값을 출력한다.

★ 캘린더 클래스 ★
Calendar c = Calendar.getInstance();
System.out.println(c.get(5));
// 인스턴스 메서드 활용
System.out.println(c.get(1)); // 년도
System.out.println(c.get(2) + 1); // 월(0 ~ 11)
System.out.println(c.get(5)); // 일
System.out.println(c.get(7)); // 요일(1 ~ 7)
System.out.println(c.get(4)); // 그 달의 몇 번째 주
System.out.println(c.get(10)); // 시(0 ~ 11)
System.out.println(c.get(11)); // 시(24시)
System.out.println(c.get(12)); // 분
System.out.println(c.get(13)); // 초
System.out.println("-----------------------");
// 상수의 활용
System.out.println(c.get(Calendar.YEAR)); // 년도
System.out.println(c.get(Calendar.MONTH) + 1); // 월(0 ~ 11)
System.out.println(c.get(Calendar.DATE)); // 일
System.out.println(c.get(Calendar.DAY_OF_WEEK)); // 요일(1 ~ 7)
System.out.println(c.get(Calendar.WEEK_OF_MONTH)); // 그 달의 몇 번째 주
System.out.println(c.get(Calendar.HOUR)); // 시(0 ~ 11)
System.out.println(c.get(Calendar.HOUR_OF_DAY)); // 시(24시)
System.out.println(c.get(Calendar.MINUTE)); // 분
System.out.println(c.get(Calendar.SECOND)); // 초

★ Object 클래스와 instanceof
모든 클래스는 Object 클래스를 상속 받는다
Object 클래스의 주요 메서드
1) toString()
=> 클래스이름과 해시코드를 리턴한다.(클래스 정보 간단히 출력)
2) equals()
=> 같은 인스턴스인지 검사한다. 
3) hashCode()
=> 인스턴스를 식별하는 값을 리턴한다.
4) getClass()
=> 인스턴스의 클래스 정보를 리턴한다.
5) clone()
=> 인스턴스를 복제한 후 그 복제 인스턴스를 리턴한다.
6) finalize()
=> 가비지 컬렉터에 의해 메모리에서 해제되기 직전에 호출된다.

★ 해시 값 출력
obj.toString();

★ 인스턴스 값 비교, equals 메소드를 오버라이딩 해서 쓰기도 한다
str.equals(str1);

★ 해시 값(디지털 지문)
=> 특정 수학 공식(알고리즘)(MD4, MD5, SHA, PGP, CRC 등)에 따라 값을 계산한다.
=> 알고리즘이 좋을수록 같은 값을 가질 확률이 줄어든다
=> 알고리즘이 좋은 이유는 복잡하고, 변환속가 느리고, 결과값이 커지기 때문이다
Object에서 상속 받은 hashCode()는 인스턴스마다 고유의 4바이트 정수 값을 리턴한다.
=> 이 값은 toString()의 출력 값으로 사용된다.
=> System.out.println(Integer.toHexString(obj1.hashCode()));
해시 값 간단 = 정확도 다운 = 생성시간 빠름
해시 값 복잡 = 정확도 업 = 생성시간 느림

★ 클래스 정보 출력
getClass() : 객체타입?+클래스이름 반환
getClass().getName() : obj의 클래스 이름 반환

★ HashSet = Hash + Set ★
→ 값을 저장할 때 해시값을 계산하여 저장 위치를 알아낸다
→ 집합 방식으로 다룬다 → 중복 불가능
→ equals()와 hashCode()를 호출해서 중복 여부 검사
→ equals()와 hashCode()가 같다면 같은 객체로 판단하여 저장하지 않는다
→ 저장할 때 저장 위치는 hashCode()의 리턴 값을 사용하여 계산한다

★ HashMap() ★ 
→ 값을 저장할 key 객체의 해시코드를 이용하여 저장할 위치(인덱스)를 계산한다.
→ 값을 저장할 때 사용한 key 객체로 값을 찾아 꺼낸다.
→ System.out.println(map.get(k3));

★ getClass() ★
→ 레퍼런스를 통해서 클래스의 정보를 간단히 알 수 있다
→ System.out.println(classInfo.getName()); // 패키지명 + 바깥 클래스명 + 클래스명
→ System.out.println(new byte[10].getClass().getName()); //[B → 배열의 클래스 정보 출력
=	String obj1 = new String();
	Class classInfo = obj1.getClass();
	System.out.println(classInfo.getName());
★ Primitive 타입의 클래스 정보
	Class classInfo = byte.class;
	System.out.println(classInfo.getName());
	System.out.println(short.class.getName());
★ 배열 항목의 타입 정보를 가져온다.
	System.out.println(new int[10].getClass().getComponentType().getName());

★ 인스턴스를 복제할 수 있게 하려면 ★
→ Object에서 제공하는 ★clone()을 호출할 수 있어야 한다.
→ 그런데 clone()의 접근 범위가 protected 이라서 같은 패키지의 멤버이거나 서브 클래스가 아니면 호출할 수 없다.
해결
→ Object에서 상속 받은 clone()을 오버라이딩 한다.
→ 다른 패키지의 멤버가 호출하려면 public 으로 접근 제어의 범위를 넓혀야 한다.
→ 오버라이딩 할 클래스 옆에 implements Cloneable를 붙여서 허락을 받는 효과(표시)
public Score clone() throws CloneNotSupportedException {
	return (Score) super.clone();
}
→ Object의 clone() 메서드는 Heap의 존재하는 인스턴스 변수들을 그대로 복제한다.

★ shallow copy ★
→ JVM은 인스턴스를 새 메모리에 그대로 복제
→ 객체(Car)가 포함하는 의존 객체(Engine)는 복제하지 않는다

★ deep copy ★
→ 객체(Car)가 포함하는 의존 객체(Engine)도 새 메모리에 복제한다
→ 의존 객체도 clone()을 오버라이딩을 하고 복제 안에서 복제를 하게끔 설계
	Car copy = (Car) super.clone();
	copy.engine = this.engine.clone();
	return copy;

문자열 결합
"aaa" + obj → 문자열과 레퍼런스 결합
→ "aaa" + "obj.toString() 리턴 값"
→ "aaa리턴값"
  
★ String 클래스
Heap
String s1 = new String("Hello");
String s2 = new String("Hello");
→ new 명령으로는 Heap에 새로운 인스턴스를 만들기 때문에 다른 객체가 생성
★ 상수풀(Constant pool)
String s3 = "Hello";
String s4 = "Hello";
→ 레퍼런스한테 바로 값을 넣으면 상수풀(Constant pool)이라는 곳에 생성된다
→ 상수풀에 같은 값이 있다면 새로운 인스턴스를 만들지 않고 같은 값에 인스턴스 주소를 리턴한다
String s2 = s1.intern();
→ String 객체에 들어 있는 문자열과 동일한 문자열을 갖고 있는 String 객체를 상수풀에서 찾는다.
→ 있으면 그 String 객체의 주소를 리턴한다. 없으면 상수풀에 String 객체를 생성한 후 그 주소를 리턴한다.

★ StringBuffer와 StringBuilder 차이점
→ 여러 스레드가 작업해야 한다면 StringBuffer를 사용하고 한 스레드만 작업해야 한다면 StringBuilder를 사용한다
StringBuffer
→ 여러 스레드가 작업 할때 하나의 스레드만 작업할 수 있게 (동기화 지원)
→ StringBuilder보다 작업시간이 느리다 하지만 작업이 안정적이다
StringBuilder
→ 여러 스레드가 작업 할때 다른 스레드가 작업 권한을 가지게 된다 (동기화 비지원)
→ StringBuffer보다 작업시간이 빠르다 하지만 작업 권한을 막지 못해서 작업이 안정적이지 않다
→ 여러 스레드가 작업해야 한다면 StringBuffer를 사용하고 한 스레드만 작업해야 한다면 StringBuilder를 사용한다

★ String 기타 메소드
String.valueOf(); 메소드
String s2 = String.valueOf(true);
String s4 = String.valueOf(100L); // 100L => "100"
String s7 = String.valueOf('가');
→ 리터럴 값을 문자열로 만들어준다
-----------------------------------------------------------------
String.format(); 메소드
String s1 = String.format("%s,%s,%s,%s,%s", arr[0], arr[1], arr[2], arr[3], arr[4]);
System.out.println(s1);
String s2 = String.format("%s,%s,%s,%s,%s", arr);
System.out.println(s2);
→ 문자열 결합
------------------------------------------------------------------
String.join(); 메소드
String s3 = String.join(",", arr[0], arr[1], arr[2], arr[3], arr[4]);
System.out.println(s3);
String s4 = String.join(",", arr);
System.out.println(s4);
→ 문자열 사이에 끼워넣기
-----------------------------------------------------------------
Arrays.copyOfRange(); 메소드
String[] arr2 = Arrays.copyOfRange(arr, 2, 4);
for (String s : arr2) {
      System.out.println(s);
}
→ 배열에 특정 범위의 항목을 복사하기
-----------------------------------------------------------------
★ 문자 사이에 문자열 받기
java.util.Scanner sc = new java.util.Scanner(System.in);
sc.useDelimiter(":");
-----------------------------------------------------------------
★ 파일에 쓰기
byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
//writeShort(bytes.length);
write(bytes.length >> 8);
write(bytes.length);
write(bytes);
-----------------------------------------------------------------
★ 파일에서 읽기
//int len = readShort();
int len = read() << 8 | read();
byte[] bytes = new byte[len];
read(bytes, 0, len);
//byte[] bytes = readNBytes(len); // java 11 버전부터 사용가능
return new String(bytes, 0, len, StandardCharsets.UTF_8);
-----------------------------------------------------------------
★ 버퍼에서 한번에 쓰기
super.write(buffer, 0, size);
size = 0;
-----------------------------------------------------------------
★ 버퍼에 한번에 읽기
size = super.read(buffer);
-----------------------------------------------------------------
Date 객체 밀리초에서 스트링으로 바꾸기
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd", timezone = ("Asia/Seoul"))
  private Date startDate;
-----------------------------------------------------------------
★ 클래스 정보에서 메소드 추출해서 메소드 호출하기 ★
// command 이름으로 메소드를 찾는다
Method[] methods = dao.getClass().getDeclaredMethods();
Method commandHandler = null;
for (Method m : methods) {
  if (m.getName().equals(command)) {
    commandHandler = m;
    break;
  }
}
// 메소드의 파라미터 정보를 알아낸다
Parameter[] parameters = commandHandler.getParameters();
System.out.printf("파라미터 개수 : %s\n", parameters.length);

// 메소드를 호출할 때 파라미터에 넘겨 줄 데이터를 담을 배열을 준비한다
Object[] args = new Object[parameters.length];

// 아규먼트 값 준비하기
// => 현재 모든 DAO의 메소드는 파라미터가 최대 1개만 있다
// => 1개만 있다는 가정하에서 아규먼트 값을 준비한다
if (parameters.length > 0) {
  // 파라미터 타입을 알아낸다
  Class<?> paramType = parameters[0].getType();

  //클라이언트가 보낸 Json 문자열을 해당 파라미터 타입 객체로 변환한다
  Object paramValue = gson.fromJson(value, paramType);

  // 아큐먼트 배열에 저장한다
  args[0] = paramValue;
}

// 메소드의 리턴 타입을 알아낸다
Class<?> returnType = commandHandler.getReturnType();
System.out.printf("리턴 : %s\n", returnType.getName());

// 메소드를 호출한다
Object returnValue = commandHandler.invoke(dao, args);
-------------------------------------------------------------------------------------
★ 프록시 객체를 사용
m1(), m2(), m3() 호출 → 객체→ invoke() 호출 → InvocationHandler(실제 일을 수행)

MyInterface obj = (MyInterface) Proxy.newProxyInstance(
        Exam0110.class.getClassLoader(), // 클래스를 메모리에 로딩하는 일을 할 객체
        new Class[] {MyInterface.class}, // 자동 생성할 클래스가 구현해야 하는 인터페이스 목록
        new MyInvocationHandler());
-----------------------------------------------------------------
★ 타임아웃 시간 설정하기
1) 소켓을 생성한다.
Socket socket = new Socket();
System.out.println("소켓 생성됨.");

2) 연결할 서버의 주소를 준비한다.
SocketAddress socketAddress = new InetSocketAddress("localhost", 8888);

socket.connect(socketAddress, 5000); // timeout : milliseconds
-----------------------------------------------------------------
PrintWriter
PrintWriter out = new PrintWriter(socket.getOutputStream());
out.println(str);
out.flush();
// character stream 클래스의 경우
// 출력 데이터를 내부 버퍼에 보관하고 있다가
// flush()가 호출되면 비로서 출력을 수행한다.
// 따라서 위 출력 문자열은 클라이언트에 보내지 않는다.
// 주의!
// => 단 close()를 호출하면 close() 내부에서 flush()를 실행한다.
-----------------------------------------------------------------
FileOutPutStream
→ 1바이트 단위로 파일에 쓴다
→ 1바이트를 UTF-16BE방식으로 16진수로 변환해서 파일에 쓴다
FileInPutStream
→ 1바이트 단위로 파일에서 읽어온다
→ UTF-16BE방식으로 인코딩된 16진수 1바이트를 파일에서 읽어온다

★ FileOutputStream out = new FileOutputStream("temp/test1.txt");
out.write('A'); // 0x0041
out.write('가'); // 0xac00
out.write(bytes); // 바이트 배열 전체를 출력한다.
out.write(bytes, 2, 3); // 2번 데이터부터 3 바이트를 출력한다.
byte[] bytes = str.getBytes(); // 문자집합을 지정하지 않으면 file.encoding에 설정된 문자집합으로 인코딩하여 리턴한다.
byte[] bytes = str.getBytes("MS949");
out.write(bytes);

★ FileInputStream in = new FileInputStream("temp/test1.txt");
System.out.printf("%02x\n", in.read());
System.out.printf("%02x\n", in.read());
int count = in.read(buf);
int count = in.read(buf, 10, 40); // 40바이트를 읽어 10번 방부터 저장한다.
String str = new String(buf, 0, count);
String str = new String(buf, 0, count, "CP949"); // MS949 = CP949 
String str = new String(buf, 0, count, "UTF-16");
-----------------------------------------------------------------
FileWriter
→ 영어는 2바이트(UTF-16BE)를 1바이트(UTF-8)로 인코딩해서 파일에 쓴다
→ 한글은 2바이트(UTF-16BE)를 3바이트(UTF-8)로 인코딩해서 파일에 쓴다
FileReader
→ 영어는 1바이트(UTF-8)를 2바이트(UTF-16BE)로 디코딩해서 파일에서 읽는다
→ 한글은 3바이트(UTF-8)를 2바이트(UTF-16BE)로 디코딩해서 파일에서 읽는다

★ FileWriter out = new FileWriter("temp/test2.txt");
out.write(0x7a5f0041);
Charset charset = Charset.forName("UTF-16BE");
FileWriter out = new FileWriter("temp/test2.txt", charset);
char[] chars = new char[] {'A', 'B', 'C', '0', '1', '2', '가', '각', '간', '똘', '똥'};
out.write(chars); // 문자 배열 전체를 출력한다.
out.write(chars, 2, 3); // 2번 문자부터 3 개의 문자를 출력한다.
String str = new String("AB가각");
out.write(str); 

★ FileReader in = new FileReader("sample/utf8.txt");
int ch1 = in.read(); 
Charset charset = Charset.forName("UTF-8");
FileReader in = new FileReader("sample/utf8.txt", charset);
char[] buf = new char[100];
int count = in.read(buf);
String str = new String(buf, 0, count); // 그래서 String 객체를 만들 때 문자집합을 지정할 필요가 없다.
int count = in.read(buf, 10, 40); // 40개의 문자를 읽어 10번 방부터 저장한다.

// FileReader 객체가 읽을 데이터를 저장할 메모리를 준비한다.
CharBuffer charBuf = CharBuffer.allocate(100);

// 읽은 데이터를 CharBuffer 에 저장한다.
int count = in.read(charBuf);

// 버퍼의 데이터를 꺼내기 전에 읽은 위치를 0으로 초기화시킨다.
// - read() 메서드가 파일에서 데이터를 읽어서 버퍼에 채울 때 마다 커서의 위치는 다음으로 이동한다.
// - 버퍼의 데이터를 읽으려면 커서의 위치를 처음으로 되돌려야 한다.(flip)
// - flip() 메서드를 호출하여 커서를 처음으로 옮긴다. 그런 후에 버퍼의 텍스를 읽어야 한다.
charBuf.flip();
System.out.printf("[%s]\n", charBuf.toString());

// 데코레이터를 붙인다.
// => 버퍼 기능 + 한 줄 읽기 기능
BufferedReader in2 = new BufferedReader(in);
System.out.println(in2.readLine());
-----------------------------------------------------------------
★ 인트
int money = 1_3456_7890; // = 0x080557d2
  out.write(money >> 24); // 00000008|0557d2
    out.write(money >> 16); // 00000805|57d2
    out.write(money >> 8);  // 00080557|d2
    out.write(money);       // 080557d2

int value = in.read() << 24;   // 00000008 =>   08000000
    value += (in.read() << 16);    // 00000005 => + 00050000
    value += (in.read() << 8);     // 00000057 => + 00005700
    value += in.read();            // 000000d2 => + 000000d2
    //==========================================>   080557d2
→ short, int ,long, float, double 타입은 이러한 방식으로 숫자를 읽어와서 변환을 한다
→ 문자열은 byte 배열을 읽거나 써서 변환한다
-----------------------------------------------------------------
★ 접속한 클라이언트의 IP 주소 알아내기
InetAddress inetAddr = socket.getInetAddress();
System.out.printf("접속자: %s\n", inetAddr.getHostAddress());
→ 서버에 누가 접속 했는지 알 수 있다
-----------------------------------------------------------------
★ Server(connectionless)
// 데이터 송수신을 담당할 소켓을 먼저 준비한다.
// => 보내는 쪽이나 받는 쪽이나 같은 소켓 클래스를 사용한다.
//    서버 소켓이 따로 없다.
// => 받는 쪽에서는 소켓을 생성할 때 포트번호를 설정한다.
DatagramSocket socket = new DatagramSocket(8888);

// 받은 데이터를 저장할 버퍼 준비
byte[] buf = new byte[8196];

// 빈 패킷 준비
DatagramPacket emptyPacket = new DatagramPacket(buf, buf.length);

// 빈 패킷을 사용하여 클라이언트가 보낸 데이터를 받는다.
// => 데이터를 받을 때까지 리턴하지 않는다.
socket.receive(emptyPacket);
System.out.println("데이터를 받았음!");

socket.close();
keyScan.close();

// 빈 패킷에 저장된 클라이언트가 보낸 데이터를 꺼낸다.
// 패킷에 저장된 UTF-8로 인코딩된 바이트 배열을 가지고 String 객체(UTF-16)를 만든다.

// 1) 패킷 객체에 보관된 바이트 배열을 꺼낸다.
byte[] bytes = emptyPacket.getData();

// getData()가 리턴한 배열은 DatagramPacket 을 만들 당시 넘겨준 배열이다.
System.out.println(buf == bytes);

// 2) 바이트 배열에 보관된 데이터의 개수를 알아낸다.
int len = emptyPacket.getLength();

// 3) 클라이언트에서 받은 바이트 배열을 가지고 String 객체를 생성한다.
String message = new String(bytes, 0, len, "UTF-8");

// 실무에서는 다음과 같이 로컬 변수를 사용하지 않고 직접 패킷 객체를 사용하는 방식으로 코딩한다.
//    String message = new String(//
//        emptyPacket.getData(), // ==> buf, 패킷에서 바이트 배열을 꺼낸다.
//        0, // 버퍼에서 데이터를 꺼낼 때 0번째부터 꺼낸다.
//        emptyPacket.getLength(), // 패킷에서 받은 바이트의 개수만큼 데이터를 꺼낸다.
//        "UTF-8" // 바이트 배열로 인코딩된 문자표의 이름을 지정한다.
//        );

System.out.println(message);
-----------------------------------------------------------------
★ Client(connectionless)
// connectionless 방식으로 통신을 수행할 소켓 생성
// - 클라이언트 쪽은 포트 번호를 지정하지 않는다.
// - 물론 OS가 자동으로 부여할 것이다.
DatagramSocket socket = new DatagramSocket();

// 보낼 데이터를 바이트 배열로 준비
// String message = new String("Hello"); // Heap에 String 객체 생성
// String message = "Hello"; // constant pool에 String 객체 생성
// byte[] bytes = message.getBytes("UTF-8");
byte[] bytes = "Hello".getBytes("UTF-8");

// 보낼 데이터를 패킷에 담는다.
// => 패킷 = 데이터 + 데이터크기 + 받는이의 주소 + 받는이의 포트번호
DatagramPacket packet = new DatagramPacket(bytes, // 데이터가 저장된 바이트 배열
  bytes.length, // 전송할 데이터 개수
  InetAddress.getByName("localhost"), // 데이터를 받을 상대편 주소
  8888 // 포트번호
);

// 데이터 전송
socket.send(packet);
System.out.println("데이터 전송 완료!");

// 자원해제
socket.close();

// 상대편이 네트웍에 연결되었는지 따지지 않고 무조건 데이터를 보낸다.
// 만약 상대편이 연결되어 있지 않다면, 보낸 데이터는 그 쪽 네트웍에서 버려진다.
 	// => 데이터 송수신을 보장하지 않는다.
-----------------------------------------------------------------
★ URL(Uniform Resource Locator) - URL을 다루는 클래스
// 웹 상에서 자원의 위치를 표현하는 방법
// => [프로토콜]://서버주소:포트번호/자원의경로?파라미터명=값&파라미터명=값
// - 프로토콜: http(80), https(443), ftp(21/20) 등
// - 서버주소: IP 주소(192.168.0.1), 도메인명(www.bitcamp.co.kr)
// - 포트번호: 80 또는 443(생략할 수 있다), 8080(프록시 서버) 등
// - 자원의경로: /index.html, /board/list.jsp 등
// - 서버에 보내는 파라미터(Query String): 파라미터명=값&파라미터명=값
//
// 자원
// - 정적 자원(static)
//   - 요청할 때 마다 결과 콘텐트가 변경되지 않는 자원. 즉 파일을 가리킨다.
//   - 예) HTML, GIF, JPEG, PNG, CSS, JavaScript, TXT 등의 파일
// - 동적 자원(dynamic)
//   - 요청할 때 마다 결과 콘텐트가 변할 수 있는 자원. 
//   - 메일 조회, 게시물 변경, 주문 등의 웹 프로그램을 가리킨다.
//   - 예) index.php, index.jsp, /board/list 등
//
URL url = new URL("https://search.naver.com:443/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=bitcamp");

// URL 분석
System.out.printf("프로토콜: %s\n", url.getProtocol());
System.out.printf("서버주소: %s\n", url.getHost());
System.out.printf("포트번호: %d\n", url.getPort()); // 지정하지 않으면 -1 리턴. 실제 접속할 때는 기본 포트번호 사용.
System.out.printf("자원경로: %s\n", url.getPath());
System.out.printf("서버에 보내는 파라미터: %s\n", url.getQuery());
-----------------------------------------------------------------
JAM의 기본 스레드
→ 기본적으로 <<Thread>>main를 갖고 있다

JVM → System/
             → main/
                  → main스레드
	→ InnocuousThreadGroup
	→ Reference Handler
   	→ Finalizer
   	→ Signal Dispatcher
   	→ Attach Listener
   	→ Notification Thread


// 현재 스레드의 이름
Thread main = Thread.currentThread();
System.out.println("실행 흐름명 = " + t.getName());

// 스레드는 그룹에 소속되기도 한다.
// 현재 스레드의 소속 그룹을 알고 싶다면?
ThreadGroup group = main.getThreadGroup();
System.out.println("그룹명 = " + group.getName());

// 스레드 그룹에 소속된 스레드 목록을 알고 싶다면?
Thread[] arr = new Thread[100];
★ int count = mainGroup.enumerate(arr, false);
// 두 번째 파라미터 값을 false로 지정하면,
// 하위 그룹에 소속된 스레드들은 제외한다.
// 즉, 현재 그룹에 소속된 스레드 목록만 가져오라는 뜻!

System.out.println("main 그룹에 소속된 스레드들:");
for (int i = 0; i < count; i++)
  System.out.println("   => " + arr[i].getName());

// 스레드 그룹에 소속된 하위 그룹을 알고 싶다면?
ThreadGroup[] groups = new ThreadGroup[100];
int count = mainGroup.enumerate(groups, false);
// 두 번째 파라미터 값을 false로 지정하면,
// 하위 그룹에 소속된 그룹들은 제외한다.
// 즉, 현재 그룹에 소속된 하위 그룹의 목록만 가져오라는 뜻!

System.out.println("main 그룹에 소속된 하위 그룹들:");
for (int i = 0; i < count; i++)
  System.out.println("   => " + groups[i].getName());

// 스레드 그룹의 부모 그룹을 알고 싶다면?
ThreadGroup parentGroup = mainGroup.getParent();
System.out.printf("main 스레드 그룹의 부모: %s\n", parentGroup.getName());

// "system" 그룹의 부모 그룹은?
ThreadGroup grandparentGroup = parentGroup.getParent();
if (grandparentGroup != null) {
  System.out.printf("%s 스레드 그룹의 부모: %s\n", 
    parentGroup.getName(), 
    grandparentGroup.getName());
}

// System 스레드 그룹의 자식 그룹들
ThreadGroup[] groups = new ThreadGroup[100];
int count = systemGroup.enumerate(groups, false);

System.out.println("system 스레드 그룹의 자식 그룹들:");
for (int i = 0; i < count; i++) {
  System.out.println("   =>" + groups[i].getName());
}

// System 스레드 그룹에 소속된 스레드들
Thread[] arr = new Thread[100];
int count = systemGroup.enumerate(arr, false);

System.out.println("system 스레드 그룹에 소속된 스레드들:");
for (int i = 0; i < count; i++) {
  System.out.println("   =>" + arr[i].getName());
}
-----------------------------------------------------------------
★ java의 ThreadPool → ExecutorService ★
★ 1) 불변 스레드 풀
Executors.newFixedThreadPool(3) → executorService 
Runnable 구현 객체를 생성자에 넣어준다 → executorService.excute() → 스레드 생성 → Thread.start() → run() → pool에 보관

// 스레드풀을 생성한다.
// - 최대 3개의 스레드를 생성한다.
// 스레드풀 개수를 고정하는 객체 생성(=팩토리 메소드)
ExecutorService executorService = Executors.newFixedThreadPool(3);

// 스레드풀에 작업 수행을 요청한다.
// - 작업은 Runnable 구현체로 작성하여 넘겨준다.
// - 스레드풀은 스레드를 생성하여 작업을 수행시킨다.
executorService.execute(() -> System.out.printf("%s - Hello!\n", Thread.currentThread().getName()));

// 스레드풀에 있는 모든 스레드들이 요청한 작업을 끝내면
// 종료하도록 지시한다.
// 모든 스레드가 종료될 때까지 기다리지 않고 바로 리턴한다.
// shutdown() 호출 이후에는 새 작업 요청은 받지 않는다.
// 즉 execute()를 호출하면 예외가 발생한다.
executorService.shutdown();

★ 2) 가변 스레드 풀 
// 스레드의 수를 고정하지 않고 필요할 때마다 스레드를 생성하는 스레드풀이다.
// 물론 작업을 끝낸 스레드는 다시 사용할 수 있도록 pool에 보관한다.
ExecutorService executorService = Executors.newCachedThreadPool();

// 놀고 있는 스레드가 없으면 새 스레드를 생성한다.
//
executorService.execute(new MyRunnable(6000));
executorService.execute(new MyRunnable(2000));
executorService.execute(new MyRunnable(9000));
executorService.execute(new MyRunnable(1000));

// 작업을 끝낸 스레드가 생길 때까지 일부러 기다린다.
//
Thread.sleep(3000);

// 그러면 새 스레드를 생성하지 않고
// 작업을 끝낸 스레드가 요청한 작업을 처리한다.
//
executorService.execute(new MyRunnable(4000));

executorService.shutdown();

★ 3) 싱글 스레드 풀
// 한 개의 스레드만 갖는 스레드풀이다.
ExecutorService executorService = Executors.newSingleThreadExecutor();

// 스레드가 한 개이기 때문에 순차적으로 실행한다.
executorService.execute(new MyRunnable(6000));
executorService.execute(new MyRunnable(3000));
executorService.execute(new MyRunnable(9000));
executorService.execute(new MyRunnable(2000));
executorService.execute(new MyRunnable(4000));

executorService.shutdown();
-----------------------------------------------------------------
★ 스레드 풀 활용

1)
// 스레드풀에 수행할 작업을 등록한다.
// 스레드풀은 execute()를 호출한 순서대로 작업큐에 작업을 보관한다.
// 그리고 놀고 있는 스레드가 있다면, 작업큐에서 작업을 꺼내 수행시킨다.
// 놀고 있는 스레드가 없으면, 새로 스레드를 생성한다.
// 스레드가 최대 개수라면 기존 스레드가 작업을 끝낼 때까지 기다린다.
// => 수행한 작업의 종료 여부를 확인할 수 없다.
executorService.execute(new MyRunnable(6000));

// 더이상 맡은 작업이 없으면 스레드풀을 종료하라고 지시한다
executorService.shutdown();

2)
// execute()와 같다.
// => 단 작업의 종료 상태를 확인할 수 있는 Future 객체를 리턴한다.
// => 커피숍에서 주문한 후 알람벨을 받는 것과 같다!
Future<?> future1 = executorService.submit(new MyRunnable(2000));
Future<?> future2 = executorService.submit(new MyRunnable(4000));

// Future.get()
// => 요청한 작업이 완료될 때 까지 기다린다.(pending)
// => 요청한 작업이 완료되면 null을 리턴한다.
//
future2.get();
System.out.println("두 번째 작업이 끝났음");

future1.get();
System.out.println("첫 번째 작업이 끝났음");
-----------------------------------------------------------------
★ shutdown() vs shutdownNow();

ExecutorService executorService = Executors.newFixedThreadPool(3);
Thread Pool => (T1 | T2 | T3)

executorService.execute(new MyRunnable(작업));
execute(작업1) ------ 
execute(작업2) |	| 
execute(작업3) |	------> Queue(작업5 | 작업4 | 작업3 | 작업2 | 작업1)
execute(작업4) |	|
execute(작업5) ------

T1 → run() → 작업1
T2 → run() → 작업2

// 가능한 현재 수행 중인 작업들을 모두 멈추도록 지시한다.
// => shutdown()과 차이점:
// - 만약 Running 상태의 스레드가 Not Runnable 상태(sleep()/wait())에 놓인다면,
// 바로 스레드를 멈출 기회라고 보고 스레드를 강제 종료할 것이다.
// - 즉 실행 중인 작업만 완료시키고, 대기 중인 작업은 취소시키는 효과가 있다.
// => Running 상태에서 Not Runnable 상태가 될 때까지 기다린다.
// => 그리고 취소한 대기 작업 목록을 리턴해준다.
// => 현재 스레드가 실행 중인 작업은 완료하고 나머지 작업은 취소해!
List<Runnable> tasks = executorService.shutdownNow();
System.out.println("실행 취소된 작업들:");
System.out.println("--------------------------------");
for (Runnable task : tasks) {
      System.out.println(((MyRunnable) task).millisec);
}
System.out.println("--------------------------------");

// 물론 새 작업 요청도 거절한다.
// => 예외 발생!
// executorService.execute(new MyRunnable(4000));

// shutdown() vs shutdownNow();
// - shutdown()
// 진행 중인 작업을 완료하고 대기 중인 작업도 완료한 다음 종료.
// - shutdownNow()
// 진행 중인 작업은 완료하고, 대기 중인 작업은 취소하고 그 목록을 리턴한다.
-----------------------------------------------------------------
스레드풀 종료 대기
→ main 스레드를 유지하고 싶을 때 사용한다

// 스레드풀의 모든 스레드가 종료되면 즉시 true를 리턴한다.
// 만약 지정된 시간(예: 10초)이 경과할 때까지 종료되지 않았다면 false를 리턴한다.
//
if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {
  System.out.println("아직 종료 안된 작업이 있다.");
} else {
  System.out.println("모든 작업을 종료하였다.");
}
-----------------------------------------------------------------
PreparedStatement
→ 값을 가지고 SQL을 만드는 것이 아니다 = Dynamic SQL
→ SQL문과 값을 분리하여 실행한다

PreparedStatement pstmt = con.prepareStatement("insert into x_board(title, contents) values(?,?)");
?,? → in-parameter
→ 주어진 SQL문을 값과 분리하여 DBMS가 이해할 수 있는 형식으로 미리 변환(compile)한다
→ 값은 다로 DBMS에 전달한다

값을 설정하는 방법
pstmt.setxxx(1,'aaa');
→ in-parameter 타입에 맞춰서 적절한 메소드 호출
→ in-parameter 순서, 값
-----------------------------------------------------------------
// => 게시글을 입력할 때 자동 생성된 PK 값을 받겠다고 설정한다.
PreparedStatement boardStmt = con.prepareStatement(
	"insert into x_board(title,contents) values(?,?)", Statement.RETURN_GENERATED_KEYS);
// 위에서 입력한 게시글의 PK 값을 알아내기
ResultSet keyRS = boardStmt.getGeneratedKeys();
keyRS.next(); // PK가 들어있는 레코드를 한 개 가져온다.
// int boardId = keyRS.getInt("board_id"); // PK 값이 들어있는 레코드에서 컬럼 값을 꺼낸다. MariaDB에서 오류 발생!
int boardId = keyRS.getInt(1);
-----------------------------------------------------------------
StringWriter
→ 출력하는 문자열을 내부 버퍼에 유지
print("aaa");
print("bbb");
print("ccc");
→ 버퍼에 보관(aaa, bbb, ccc)
new PrintWriter(new StringWriter());
-----------------------------------------------------------------
자바에서 톰캣 서버 동작

// 톰캣 서버를 구동시키는 객체 준비
Tomcat tomcat = new Tomcat();

// 서버의 포트 번호 설정
tomcat.setPort(8888);

// 톰캣 서버를 실행하는 동안 사용할 임시 폴더 지정
tomcat.setBaseDir("./temp");

// 톰캣 서버의 연결 정보를 설정
Connector connector = tomcat.getConnector();
connector.setURIEncoding("UTF-8");

// 톰캣 서버에 배포할 웹 애플리케이션의 환경 정보 준비
StandardContext ctx = (StandardContext) tomcat.addWebapp(
  "/", // 컨텍스트 경로(웹 애플리케이션 경로)
  new File("./src/main/webapp").getAbsolutePath() // 웹 애플리케이션 파일이 있는 실제 경로
);
ctx.setReloadable(true);

// 웹 애플리케이션 기타 정보 설정
WebResourceRoot resources = new StandardRoot(ctx);

// 웹 애플리케이션의 서블릿 클래스 등록
resources.addPreResources(new DirResourceSet(
  resources, // 루트 웹 애플리케이션 정보
  "/WEB-INF/classes", // 서블릿 클래스 파일의 위치 정보
  new File("build/classes/java/main").getAbsolutePath(), // 서블릿 클래스 파일이 있는 실제 경로
  "/" // 웹 애플리케이션 내부 경로
));

// 웹 애플리케이션 설정 정보를 웹 애플리케이션 환경 정보에 등록
ctx.setResources(resources);

// 톰캣 서버 구동
tomcat.start();

// 톰캣 서버를 구동한 후 종료될 때까지 JVM을 끝내지 말고 기다린다.
tomcat.getServer().await();
-----------------------------------------------------------------
서블릿 만들기
<<interface>> Servlet <------ MyServlet[init(), service(), destroy(), getServletConfig, getServletConfigInfo()]
	          ↑---- <<abstract>> GenericServlet <----- MyServlet[service()]
				↑---- <<abstract>> HttpServlet <---- MyServlet[doGet(), doPost()]
-----------------------------------------------------------------
★ 서블릿에서 출력하기
getWriter() → ServletResponse → PrintWrite 리턴
print(콘텐트) → PrintWriter → 버퍼에 콘텐트 저장
→ 버퍼에 있는 콘텐트를 응답할 때 UTF-16BE를 ISO-8859-1로 변환해서 응답한다
→ 한글은 ISO-859-1 코드표에 존재하지 않는 문자이기 때문에 변환불가!
→ 그런 의미에서 '?' 문자로 변환된다

response.setContentType("text/plain;charset=UTF-8"); // UCS2(UTF-16) ==> UTF-8
PrintWriter out = response.getWriter();

MIME Type : Multi-purpose Internet Mail Extension
 => 콘텐트의 형식을 표현
 => 콘텐트타입/상세타입
 => 예) text/plain, text/css, text/html 등
 => 웹 브라우저는 콘텐트를 출력할 때 서버가 알려준 MIME 타입을 보고 어떤 방식으로 출력할 지 결정한다.
-----------------------------------------------------------------
★ apache commons-fileupload 사용법

DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();
ServletFileUpload multipartDataHandler = new ServletFileUpload(fileItemFactory);

실제 경계 문자열 예) ------WebKitFormBoundaryogFq6gl3Nbl5A4sI
---------------------------------
name=aaa
---------------------------------
age=20
---------------------------------
file1
---------------------------------
file2
---------------------------------
→ 분석 → ServletfileUpload → 파트를 넘긴다 → DiskfileItemFactory → 각 파트마다 FileItem 생성
	→ 멀티파트 데이터 부분		→ 파트의 데이터를 FileItem 객체에 담는다

Part part = get.part(); 
→ Servlet 3.0부터 가능
→ part.write(file); 가능
-----------------------------------------------------------------
★ forward, include, refresh, redirect ★

① forward
 RequestDispatcher 요청배달자 = request.getRequestDispatcher("/ex07/s2");
요청배달자.forward(request, response);

클라이언트 < 요청 / 응답 > 서블릿1 출력1 < RequestDispatcher.forward() / 리턴 > 서블릿2 출력2
→ 출력1은 무시하고 출력2만 출력

② include
RequestDispatcher 요청배달자 = request.getRequestDispatcher("url");
요청배달자.include(request, response);
or
request.getRequestDispatcher("/header").include(request, response);

클라이언트 < 요청 / 응답 > 서블릿1 출력1 < RequestDisPatcher.include() / 리턴 > 서블릿2 출력2
→ 출력1 + 출력2 출력

③ refresh
response.setHeader("Refresh", "1;url=/index.html"); 
or
out.println("<meta http-equiv='Refresh' content='3;url=s100'>");

클라이언트 < 요청 / 응답 > 서블릿1 콘텐트+url
     └> 콘텐트 출력 후 다른 url 요청 / 응답
200 ok
Refresh : url
→ 서블릿1 요청 응답 후 콘텐트 출력 
→ 다른 url 요청

④ redirect 
response.sendRedirect("/board/list?category=" + category);
return;

클라이언트 < 요청 / 응답 > 서블릿1 +url
     └> 다른 url 요청 / 응답
302 Found
Location : url
→ 서블릿1 요청 응답 후 url 요청
→ 콘텐트는 없다
-----------------------------------------------------------------
forward/include 서블릿끼리 객체 공유
클라이언트 → 서블릿1 → forward/include → 서블릿2
	      request, response  → 전달 → request, response
RequestDipatcher rd = request.getRequestDispatcher("/s2");
rd.forward(request, response);
rd.include(request, response);
forward/include 하는 서블릿에게 request와 response를 넘긴다 = 공유한다
-----------------------------------------------------------------
★ 쿠키 사용 하기 ★
Cookie c = new Cookie("v1", "aaa");
Cookie c5 = new Cookie("name3", URLEncoder.encode("홍길동", "UTF-8"));
// 프로토콜 예 => Set-Cookie: name3=%ED%99%8D%EA%B8%B8%EB%8F%99
response.addCookie(c1);
URLDecoder.decode(c5.getValue(), "UTF-8")

c.setMaxAge(60); // 쿠키를 보낸 이후 60초 동안만 유효
c.setPath("/ex10/a"); // 쿠키 범위 설정

// 쿠키 꺼내기
// => 쿠키를 이름으로 한 개씩 추출할 수 없다.
// => 한 번에 배열로 받아야 한다.
// => 요청 헤더에 쿠키가 없으면 리턴 되는 것은 빈 배열이 아니라 null이다.
// => 따라서 무조건 반복문을 돌리면 안된다.
Cookie[] cookies = request.getCookies();
out.printf("%s=%s,%s\n", c.getName(), c.getValue(), URLDecoder.decode(c.getValue(), "UTF-8"));
-----------------------------------------------------------------
★ 세션 사용 하기

HttpSession session = request.getSession();
// 세션에 데이터 보관하기
session.setAttribute("v1", "aaa");
→ 새로 세션을 만들면, 무조건 응답할 때 새 세션의 아이디를 쿠키로 보낸다.
→ 세션 객체를 만들어야 서버가 세션id를 만들어 준다

session.setMaxInactiveInterval(10);
→ 시간(초)이 지나면 session 객체를 무효화 시킨다
→ 기본 설정으로 새로운 session 객체를 만든다

session.invalidate(); // 세션을 무효화시킨다.
-----------------------------------------------------------------
서블릿 배치 정보 설정

1) web.xml에 배치 정보 등록
<servlet>
    <servlet-name>ex12.Servlet01</servlet-name>
    <servlet-class>com.eomcs.web.ex12.Servlet01</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>ex12.Servlet01</servlet-name>
    <url-pattern>/ex12/s01</url-pattern>
</servlet-mapping>

2) 애노테이션에 등록
@WebServlet("/ex12/s02")

3) ★ 객체를 직접 생성하여 등록 : 웹 애플리케이션을 시작할 때 ★
@WebListener
public class Listener01 implements ServletContextListener {
  @Override
  public void contextInitialized(ServletContextEvent sce) {
    ServletContext sc = sce.getServletContext();
    Servlet03 servlet = new Servlet03();
    Dynamic 서블릿설정정보 = sc.addServlet("ex12.Servlet03", servlet); // <servlet>...</servlet>
    서블릿설정정보.addMapping("/ex12/s03"); // <servlet-mapping>...</servlet-mapping>
  }
}
-----------------------------------------------------------------
String text = "#한글 #Java #한글 #한글 #한글";

    // 정규 표현식을 사용하여 해시 태그 추출 (한글 포함)
    Pattern pattern = Pattern.compile("#[\\w가-힣]+");
    Matcher matcher = pattern.matcher(text);

    // 매칭된 해시 태그 출력
    while (matcher.find()) {
      String hashtag = matcher.group();
      System.out.println("Hashtag: " + hashtag);
    }
-----------------------------------------------------------------
// 최대 공약수를 구하는 메소드 (유클리드 호제법)
    public int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
-----------------------------------------------------------------
class Solution {
    public int solution(int n) {
        int gcd = gcd(n, 6); // n과 6의 GCD를 구함
        int lcm = (n * 6) / gcd; // LCM을 구하는 공식
        return lcm / 6; // 최소 피자 판 수를 구함
    }
    
    // 최대 공약수를 구하는 유클리드 호제법
    public int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
-----------------------------------------------------------------
public static String solution(String my_string, String alp) {
        // alp를 대문자로 변환
        String upperAlp = alp.toUpperCase();
        // my_string에서 alp를 대문자로 대체
        String result = my_string.replaceAll(alp, upperAlp);
        return result;
    }
-----------------------------------------------------------------
모든 문자를 소문자로 변환 후 a만 대문자로 변환

 public String solution(String myString) {
        myString = myString.toLowerCase();
        myString = myString.replace('a', 'A');

        return myString;
    }
-----------------------------------------------------------------
★ 문자 배열 조합 & 정렬 & 문자열로 변환
String target = String.join("", spell);
- 문자열 배열을 하나에 문자열로 변환
char[] targetArray = target.toCharArray();
- 문자열을 문자 배열로 변환
Arrays.sort(targetArray);
- 문자 배열 정렬
String sortedTarget = new String(targetArray);
- 문자 배열을 문자열로 변환
-----------------------------------------------------------------
★ 문자열을 오른쪽으로 민 횟수 구하기
class Solution {
    public int solution(String A, String B) {
        String tempB = B + B;
	String tempB = B.repeat(2);
        return tempB.indexOf(A);
        // llohellohe / hello
    }
}
-----------------------------------------------------------------
★ MYSQL 머문 일 수 구하기
SELECT I.ANIMAL_ID, I.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O ON I.ANIMAL_ID = O.ANIMAL_ID
ORDER BY TIMESTAMPDIFF(DAY, I.DATETIME, O.DATETIME) DESC
LIMIT 2;

TIMESTAMPDIFF(단위, 시작시간, 종료시간)
- 단위(unit): YEAR, MONTH, DAY, HOUR, MINUTE, SECOND 등 사용 가능.
- 시작시간(datetime1): 기준이 되는 시간.
- 종료시간(datetime2): 비교할 시간.
-----------------------------------------------------------------
★ 특정 형질을 가지는 대장균 찾기

SELECT COUNT(*) as COUNT
FROM ECOLI_DATA e
WHERE (e.GENOTYPE & 2) = 0  -- 2번 형질이 없는 대장균
  AND ((e.GENOTYPE & 1) > 0 OR (e.GENOTYPE & 4) > 0); -- 또는 3번 형질을 보유
-----------------------------------------------------------------
★ 식품분류별 가장 비싼 식품의 정보 조회하기
- PRODUCT_NAME 컬럼에 값이 GROUP BY 했을 때 PRODUCT_NAME을 올바르게 가져오지 못하는 문제가 생김
- 서브 쿼리로 해결
  - 각 CATEGORY에서 가장 비싼 가격의 제품만 가져오기

SELECT F.CATEGORY, F.PRICE AS MAX_PRICE, F.PRODUCT_NAME
FROM FOOD_PRODUCT F
WHERE F.CATEGORY IN ('과자', '국', '김치', '식용유')
AND F.PRICE = (SELECT MAX(PRICE) 
               FROM FOOD_PRODUCT 
               WHERE CATEGORY = F.CATEGORY)
ORDER BY F.PRICE DESC;
-----------------------------------------------------------------
★ 잡은 물고기 중 가장 큰 물고기의 길이 구하기
- 숫자 값 뒤에 'cm'을 붙여 문자열로 변환

SELECT CONCAT(FORMAT(MAX(LENGTH), 2), 'cm') AS MAX_LENGTH
FROM FISH_INFO;
-----------------------------------------------------------------
★ 잡은 물고기의 평균 길이 구하기
- COALESCE(LENGTH, 10)
  - LENGTH 값이 NULL이면 10으로 변환
- ROUND(..., 2)
  - 소수점 3째 자리에서 반올림하여 소수점 2자리까지 표시

SELECT ROUND(AVG(COALESCE(LENGTH, 10)), 2) AS AVERAGE_LENGTH
FROM FISH_INFO;
-----------------------------------------------------------------
★ 배열에서 중복을 제거하고 오름차순으로 정렬
function removeDuplicatesAndSort(arr) {
    return [...new Set(arr)].sort((a, b) => a - b);
}

- new Set(arr): 배열의 중복을 제거합니다.
- [...new Set(arr)]: Set을 다시 배열로 변환합니다.
- .sort((a, b) => a - b): 숫자 오름차순 정렬을 수행합니다.
-----------------------------------------------------------------
★ [PCCE 기출문제] 3번 / 나이 계산
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int year = sc.nextInt();
        String age_type = sc.next();
        int answer = 0;

        if (age_type.equals("Korea")) {
            answer = 2030 - year + 1;
        }
        else if (age_type.equals("Year")) {
            answer = 2030 - year;
        }

        System.out.println(answer);
    }
}

- 한국식 나이 : 현재 연도 - 출생 연도 + 1
- 연 나이 : 현재 연도 - 출생 연도
